/* tslint:disable */
/* eslint-disable */
/**
 * General Research Full Service Brokerage API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AmtCashoutMethodData
 */
export interface AmtCashoutMethodData {
    /**
     * 
     * @type {string}
     * @memberof AmtCashoutMethodData
     */
    'type'?: AmtCashoutMethodDataTypeEnum;
}

export const AmtCashoutMethodDataTypeEnum = {
    Amt: 'AMT'
} as const;

export type AmtCashoutMethodDataTypeEnum = typeof AmtCashoutMethodDataTypeEnum[keyof typeof AmtCashoutMethodDataTypeEnum];

/**
 * @type Body
 * @export
 */
export type Body = { type: 'CASH_IN_MAIL' } & CreateCashMailCashoutMethodRequest | { type: 'PAYPAL' } & CreatePayPalCashoutMethodRequest;

/**
 * 
 * @export
 * @interface BodyOfferwallSoftpairBlockPostProductIdOfferwall7a89dcdbOfferwallIdPost
 */
export interface BodyOfferwallSoftpairBlockPostProductIdOfferwall7a89dcdbOfferwallIdPost {
    /**
     * 
     * @type {Array<UserQuestionAnswerIn>}
     * @memberof BodyOfferwallSoftpairBlockPostProductIdOfferwall7a89dcdbOfferwallIdPost
     */
    'answers': Array<UserQuestionAnswerIn>;
}
/**
 * 
 * @export
 * @interface BodyOfferwallSoftpairPostProductIdOfferwall37d1da64OfferwallIdPost
 */
export interface BodyOfferwallSoftpairPostProductIdOfferwall37d1da64OfferwallIdPost {
    /**
     * 
     * @type {Array<UserQuestionAnswerIn>}
     * @memberof BodyOfferwallSoftpairPostProductIdOfferwall37d1da64OfferwallIdPost
     */
    'answers': Array<UserQuestionAnswerIn>;
}
/**
 * 
 * @export
 * @interface BodySubmitProfilingQuestionsProductIdProfilingQuestionsPost
 */
export interface BodySubmitProfilingQuestionsProductIdProfilingQuestionsPost {
    /**
     * 
     * @type {Array<UserQuestionAnswerIn>}
     * @memberof BodySubmitProfilingQuestionsProductIdProfilingQuestionsPost
     */
    'answers': Array<UserQuestionAnswerIn>;
}
/**
 * This represents one of the \"tasks\" within a bucket\'s ordered list of tasks.
 * @export
 * @interface BucketTask
 */
export interface BucketTask {
    /**
     * The internal task id for this task within the marketplace
     * @type {string}
     * @memberof BucketTask
     */
    'id': string;
    /**
     * The namespaced task id for this task within the marketplace
     * @type {string}
     * @memberof BucketTask
     */
    'id_code': string;
    /**
     * 
     * @type {Source}
     * @memberof BucketTask
     */
    'source': Source;
    /**
     * expected loi in seconds
     * @type {number}
     * @memberof BucketTask
     */
    'loi': number;
    /**
     * integer cents
     * @type {number}
     * @memberof BucketTask
     */
    'payout': number;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const Cardinality = {
    Star: '*',
    QuestionMark: '?'
} as const;

export type Cardinality = typeof Cardinality[keyof typeof Cardinality];


/**
 * 
 * @export
 * @interface CashMailCashoutMethodData
 */
export interface CashMailCashoutMethodData {
    /**
     * 
     * @type {string}
     * @memberof CashMailCashoutMethodData
     */
    'type'?: CashMailCashoutMethodDataTypeEnum;
    /**
     * Delivery address where payment should be sent
     * @type {USDeliveryAddress}
     * @memberof CashMailCashoutMethodData
     */
    'delivery_address': USDeliveryAddress;
}

export const CashMailCashoutMethodDataTypeEnum = {
    CashInMail: 'CASH_IN_MAIL'
} as const;

export type CashMailCashoutMethodDataTypeEnum = typeof CashMailCashoutMethodDataTypeEnum[keyof typeof CashMailCashoutMethodDataTypeEnum];

/**
 * Shows the expected value of a redemption in a foreign currency.
 * @export
 * @interface CashoutMethodForeignValue
 */
export interface CashoutMethodForeignValue {
    /**
     * Value of the redemption in the currency\'s smallest unit.
     * @type {number}
     * @memberof CashoutMethodForeignValue
     */
    'value': number;
    /**
     * Supported Currencies for Foreign Redemptions  Allowed values:   - __USD__ *(USD)*: US Dollars. Smallest Unit: Cents.  - __CAD__ *(CAD)*: Canadian Dollars. Smallest Unit: Cents.  - __GBP__ *(GBP)*: British Pounds. Smallest Unit: Pence.  - __EUR__ *(EUR)*: Euros. Smallest Unit: Cents.  - __INR__ *(INR)*: Indian Rupees. Smallest Unit: Paise.  - __AUD__ *(AUD)*: Australian Dollars. Smallest Unit: Cents.  - __PLN__ *(PLN)*: Polish Zloty. Smallest Unit: Grosz.  - __SEK__ *(SEK)*: Swedish Krona. Smallest Unit: Ã–re.  - __SGD__ *(SGD)*: Singapore Dollars. Smallest Unit: Cents.  - __MXN__ *(MXN)*: Mexican Pesos. Smallest Unit: Centavos.
     * @type {RedemptionCurrency}
     * @memberof CashoutMethodForeignValue
     */
    'currency': RedemptionCurrency;
    /**
     * A string representation of the value in the currency.
     * @type {string}
     * @memberof CashoutMethodForeignValue
     */
    'value_string': string;
}


/**
 * 
 * @export
 * @interface CashoutMethodForeignValueResponse
 */
export interface CashoutMethodForeignValueResponse {
    /**
     * The status of the API response.
     * @type {string}
     * @memberof CashoutMethodForeignValueResponse
     */
    'status': CashoutMethodForeignValueResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CashoutMethodForeignValueResponse
     */
    'msg'?: string | null;
    /**
     * 
     * @type {CashoutMethodForeignValue}
     * @memberof CashoutMethodForeignValueResponse
     */
    'cashout_method_value': CashoutMethodForeignValue;
}

export const CashoutMethodForeignValueResponseStatusEnum = {
    Success: 'success',
    Error: 'error'
} as const;

export type CashoutMethodForeignValueResponseStatusEnum = typeof CashoutMethodForeignValueResponseStatusEnum[keyof typeof CashoutMethodForeignValueResponseStatusEnum];

/**
 * 
 * @export
 * @interface CashoutMethodOut
 */
export interface CashoutMethodOut {
    /**
     * Unique ID for this cashout method
     * @type {string}
     * @memberof CashoutMethodOut
     */
    'id': string;
    /**
     * The currency of the cashout. Only USD is supported.
     * @type {string}
     * @memberof CashoutMethodOut
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof CashoutMethodOut
     */
    'original_currency'?: string | null;
    /**
     * 
     * @type {Data}
     * @memberof CashoutMethodOut
     */
    'data': Data;
    /**
     * The description of the cashout method.
     * @type {string}
     * @memberof CashoutMethodOut
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof CashoutMethodOut
     */
    'image_url'?: string | null;
    /**
     * (USD cents) The maximum amount that can be cashed out in one transaction.
     * @type {number}
     * @memberof CashoutMethodOut
     */
    'max_value': number;
    /**
     * (USD cents) The minimum amount that can be cashed out in one transaction.
     * @type {number}
     * @memberof CashoutMethodOut
     */
    'min_value': number;
    /**
     * A descriptive name for the cashout method.
     * @type {string}
     * @memberof CashoutMethodOut
     */
    'name': string;
    /**
     * The method in which the requested payout is delivered.  Allowed values:   - __PAYPAL__ *(PAYPAL)*: User is paid out to their personal PayPal email address  - __TANGO__ *(TANGO)*: User is paid uut via a Tango Gift Card  - __DWOLLA__ *(DWOLLA)*: DWOLLA  - __ACH__ *(ACH)*: A payment is made to a bank account using ACH  - __WIRE__ *(WIRE)*: A payment is made to a bank account using ACH  - __CASH_IN_MAIL__ *(CASH_IN_MAIL)*: A payment is made in cash and mailed to the user.  - __PRIZE__ *(PRIZE)*: A payment is made as a prize with some monetary value  - __AMT__ *(AMT)*: This is used to designate either AMT_BONUS or AMT_HIT  - __AMT_BONUS__ *(AMT_BONUS)*: Amazon Mechanical Turk as a Bonus  - __AMT_ASSIGNMENT__ *(AMT_HIT)*: Amazon Mechanical Turk for a HIT
     * @type {PayoutType}
     * @memberof CashoutMethodOut
     */
    'type': PayoutType;
    /**
     * 
     * @type {string}
     * @memberof CashoutMethodOut
     */
    'ext_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CashoutMethodOut
     */
    'product_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CashoutMethodOut
     */
    'product_user_id'?: string | null;
}


/**
 * 
 * @export
 * @interface CashoutMethodResponse
 */
export interface CashoutMethodResponse {
    /**
     * The status of the API response.
     * @type {string}
     * @memberof CashoutMethodResponse
     */
    'status': CashoutMethodResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CashoutMethodResponse
     */
    'msg'?: string | null;
    /**
     * 
     * @type {CashoutMethodOut}
     * @memberof CashoutMethodResponse
     */
    'cashout_method': CashoutMethodOut;
}

export const CashoutMethodResponseStatusEnum = {
    Success: 'success',
    Error: 'error'
} as const;

export type CashoutMethodResponseStatusEnum = typeof CashoutMethodResponseStatusEnum[keyof typeof CashoutMethodResponseStatusEnum];

/**
 * 
 * @export
 * @interface CashoutMethodsResponse
 */
export interface CashoutMethodsResponse {
    /**
     * The status of the API response.
     * @type {string}
     * @memberof CashoutMethodsResponse
     */
    'status': CashoutMethodsResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CashoutMethodsResponse
     */
    'msg'?: string | null;
    /**
     * 
     * @type {Array<CashoutMethodOut>}
     * @memberof CashoutMethodsResponse
     */
    'cashout_methods': Array<CashoutMethodOut>;
}

export const CashoutMethodsResponseStatusEnum = {
    Success: 'success',
    Error: 'error'
} as const;

export type CashoutMethodsResponseStatusEnum = typeof CashoutMethodsResponseStatusEnum[keyof typeof CashoutMethodsResponseStatusEnum];

/**
 * See models.thl.payout: PayoutEvent. We\'ve confused a Cashout and a Payout. This is used only in the API response.
 * @export
 * @interface CashoutRequestInfo
 */
export interface CashoutRequestInfo {
    /**
     * 
     * @type {string}
     * @memberof CashoutRequestInfo
     */
    'id': string | null;
    /**
     * This is the name of the cashout method.
     * @type {string}
     * @memberof CashoutRequestInfo
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof CashoutRequestInfo
     */
    'message'?: string | null;
    /**
     * 
     * @type {PayoutStatus}
     * @memberof CashoutRequestInfo
     */
    'status'?: PayoutStatus | null;
    /**
     * 
     * @type {object}
     * @memberof CashoutRequestInfo
     */
    'transaction_info'?: object | null;
}


/**
 * 
 * @export
 * @interface CashoutRequestResponse
 */
export interface CashoutRequestResponse {
    /**
     * The status of the API response.
     * @type {string}
     * @memberof CashoutRequestResponse
     */
    'status': CashoutRequestResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CashoutRequestResponse
     */
    'msg'?: string | null;
    /**
     * 
     * @type {CashoutRequestInfo}
     * @memberof CashoutRequestResponse
     */
    'cashout': CashoutRequestInfo;
}

export const CashoutRequestResponseStatusEnum = {
    Success: 'success',
    Error: 'error'
} as const;

export type CashoutRequestResponseStatusEnum = typeof CashoutRequestResponseStatusEnum[keyof typeof CashoutRequestResponseStatusEnum];

/**
 * 
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'adwords_vertical_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'label': string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'path': string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'parent_id'?: string | null;
}
/**
 * Used in an offerwall. Stores the association between a category and a bucket, with a score.
 * @export
 * @interface CategoryAssociation
 */
export interface CategoryAssociation {
    /**
     * The category ID
     * @type {string}
     * @memberof CategoryAssociation
     */
    'id': string;
    /**
     * The category label
     * @type {string}
     * @memberof CategoryAssociation
     */
    'label': string;
    /**
     * 
     * @type {string}
     * @memberof CategoryAssociation
     */
    'adwords_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CategoryAssociation
     */
    'adwords_label'?: string | null;
    /**
     * The strength of the association of this bucketwith this category. Will sum to 1 within a bucket.
     * @type {number}
     * @memberof CategoryAssociation
     */
    'p': number;
}
/**
 * Defines the conditions to evaluate to determine when the contest is over. Multiple conditions can be set. The contest is over once ANY conditions are met.
 * @export
 * @interface ContestEndCondition
 */
export interface ContestEndCondition {
    /**
     * 
     * @type {ContestEndConditionTargetEntryAmount}
     * @memberof ContestEndCondition
     */
    'target_entry_amount'?: ContestEndConditionTargetEntryAmount | null;
    /**
     * 
     * @type {string}
     * @memberof ContestEndCondition
     */
    'ends_at'?: string | null;
}
/**
 * 
 * @export
 * @interface ContestEndConditionTargetEntryAmount
 */
export interface ContestEndConditionTargetEntryAmount {
}
/**
 * Defines why a contest ended
 * @export
 * @enum {string}
 */

export const ContestEndReason = {
    Cancelled: 'cancelled',
    TargetEntryAmount: 'target_entry_amount',
    EndsAt: 'ends_at',
    MaxWinners: 'max_winners'
} as const;

export type ContestEndReason = typeof ContestEndReason[keyof typeof ContestEndReason];


/**
 * Defines rules the user must meet to be allowed to enter this contest Only applies if the ContestType is ENTRY!
 * @export
 * @interface ContestEntryRule
 */
export interface ContestEntryRule {
    /**
     * 
     * @type {MaxEntryAmountPerUser}
     * @memberof ContestEntryRule
     */
    'max_entry_amount_per_user'?: MaxEntryAmountPerUser | null;
    /**
     * 
     * @type {number}
     * @memberof ContestEntryRule
     */
    'max_daily_entries_per_user'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ContestEntryRule
     */
    'min_completes'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ContestEntryRule
     */
    'min_membership_level'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof ContestEntryRule
     */
    'id_verified'?: boolean | null;
}
/**
 * Defines what action/event triggers a (possible) entry into the contest (automatically). This only is valid on milestone contests
 * @export
 * @enum {string}
 */

export const ContestEntryTrigger = {
    TaskComplete: 'task_complete',
    TaskAttempt: 'task_attempt',
    Referral: 'referral'
} as const;

export type ContestEntryTrigger = typeof ContestEntryTrigger[keyof typeof ContestEntryTrigger];


/**
 * All entries into a contest must be of the same type, and match the entry_type of the Contest itself.
 * @export
 * @enum {string}
 */

export const ContestEntryType = {
    Count: 'count',
    Cash: 'cash'
} as const;

export type ContestEntryType = typeof ContestEntryType[keyof typeof ContestEntryType];


/**
 * 
 * @export
 * @interface ContestPrize
 */
export interface ContestPrize {
    /**
     *  Allowed values:   - __physical__ *(PHYSICAL)*: A physical prize (e.g. a iPhone, cash in the mail, dinner with Max)  - __promotion__ *(PROMOTION)*: A promotion is a temporary or special offer that provides extra value or benefits (e.g. 20% bonus on completes for the next 7 days)  - __cash__ *(CASH)*: Money is deposited into user\'s virtual wallet
     * @type {ContestPrizeKind}
     * @memberof ContestPrize
     */
    'kind': ContestPrizeKind;
    /**
     * 
     * @type {string}
     * @memberof ContestPrize
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ContestPrize
     */
    'description'?: string | null;
    /**
     * Estimated cash value of prize in USDCents
     * @type {number}
     * @memberof ContestPrize
     */
    'estimated_cash_value': number;
    /**
     * 
     * @type {number}
     * @memberof ContestPrize
     */
    'cash_amount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ContestPrize
     */
    'promotion_id'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ContestPrize
     */
    'leaderboard_rank'?: number | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ContestPrizeKind = {
    Physical: 'physical',
    Promotion: 'promotion',
    Cash: 'cash'
} as const;

export type ContestPrizeKind = typeof ContestPrizeKind[keyof typeof ContestPrizeKind];


/**
 * 
 * @export
 * @enum {string}
 */

export const ContestStatus = {
    Active: 'active',
    Completed: 'completed',
    Cancelled: 'cancelled'
} as const;

export type ContestStatus = typeof ContestStatus[keyof typeof ContestStatus];


/**
 * In a Raffle, the ContestEntryType can be COUNT or CASH. In the CASH type, the unit of entry is 1 USDCent (one penny). Implicitly, each penny entered buys 1 entry into the raffle, and one entry is randomly selected for each prize.  A contest should have as many winners as there are prizes special case 1: there are fewer entries than prizes special case 2: leaderboard contest with ties
 * @export
 * @interface ContestWinner
 */
export interface ContestWinner {
    /**
     * 
     * @type {string}
     * @memberof ContestWinner
     */
    'uuid'?: string;
    /**
     * When this user won this prize
     * @type {string}
     * @memberof ContestWinner
     */
    'created_at'?: string;
    /**
     * 
     * @type {ContestPrize}
     * @memberof ContestWinner
     */
    'prize': ContestPrize;
    /**
     * 
     * @type {number}
     * @memberof ContestWinner
     */
    'awarded_cash_amount'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ContestWinner
     */
    'product_user_id': string | null;
}
/**
 * 
 * @export
 * @interface CountStat
 */
export interface CountStat {
    /**
     * The grouping criteria
     * @type {{ [key: string]: FacetValue; }}
     * @memberof CountStat
     */
    'facet': { [key: string]: FacetValue; };
    /**
     * The count value for the given metric and facet
     * @type {number}
     * @memberof CountStat
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface CreateCashMailCashoutMethodRequest
 */
export interface CreateCashMailCashoutMethodRequest {
    /**
     * (product_user_id) The user to create this cashout method for.
     * @type {string}
     * @memberof CreateCashMailCashoutMethodRequest
     */
    'bpuid': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCashMailCashoutMethodRequest
     */
    'type'?: CreateCashMailCashoutMethodRequestTypeEnum;
    /**
     * Delivery address where payment should be sent
     * @type {USDeliveryAddress}
     * @memberof CreateCashMailCashoutMethodRequest
     */
    'delivery_address': USDeliveryAddress;
}

export const CreateCashMailCashoutMethodRequestTypeEnum = {
    CashInMail: 'CASH_IN_MAIL'
} as const;

export type CreateCashMailCashoutMethodRequestTypeEnum = typeof CreateCashMailCashoutMethodRequestTypeEnum[keyof typeof CreateCashMailCashoutMethodRequestTypeEnum];

/**
 * 
 * @export
 * @interface CreateCashoutRequest
 */
export interface CreateCashoutRequest {
    /**
     * (product_user_id) The user requesting a cashout.
     * @type {string}
     * @memberof CreateCashoutRequest
     */
    'bpuid': string;
    /**
     * (USD cents) The amount requested for the cashout.
     * @type {number}
     * @memberof CreateCashoutRequest
     */
    'amount': number;
    /**
     * Unique ID for the cashout method the cashout is being requested with.
     * @type {string}
     * @memberof CreateCashoutRequest
     */
    'cashout_method_id': string;
}
/**
 * 
 * @export
 * @interface CreatePayPalCashoutMethodRequest
 */
export interface CreatePayPalCashoutMethodRequest {
    /**
     * (product_user_id) The user to create this cashout method for.
     * @type {string}
     * @memberof CreatePayPalCashoutMethodRequest
     */
    'bpuid': string;
    /**
     * 
     * @type {string}
     * @memberof CreatePayPalCashoutMethodRequest
     */
    'type'?: CreatePayPalCashoutMethodRequestTypeEnum;
    /**
     * Email address of the paypal user
     * @type {string}
     * @memberof CreatePayPalCashoutMethodRequest
     */
    'email': string;
}

export const CreatePayPalCashoutMethodRequestTypeEnum = {
    Paypal: 'PAYPAL'
} as const;

export type CreatePayPalCashoutMethodRequestTypeEnum = typeof CreatePayPalCashoutMethodRequestTypeEnum[keyof typeof CreatePayPalCashoutMethodRequestTypeEnum];

/**
 * Sum of all entry amounts
 * @export
 * @interface CurrentAmount
 */
export interface CurrentAmount {
}
/**
 * @type Data
 * @export
 */
export type Data = { type: 'AMT' } & AmtCashoutMethodData | { type: 'CASH_IN_MAIL' } & CashMailCashoutMethodData | { type: 'PAYPAL' } & PaypalCashoutMethodData | { type: 'TANGO' } & TangoCashoutMethodData;

/**
 * Durations are in integer seconds. Describes the statistical distribution of expected durations of tasks within this bucket.
 * @export
 * @interface DurationSummary
 */
export interface DurationSummary {
    /**
     * 
     * @type {number}
     * @memberof DurationSummary
     */
    'min': number;
    /**
     * 
     * @type {number}
     * @memberof DurationSummary
     */
    'max': number;
    /**
     * 
     * @type {number}
     * @memberof DurationSummary
     */
    'mean'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DurationSummary
     */
    'q1': number;
    /**
     * 
     * @type {number}
     * @memberof DurationSummary
     */
    'q2': number;
    /**
     * 
     * @type {number}
     * @memberof DurationSummary
     */
    'q3': number;
    /**
     * 
     * @type {number}
     * @memberof DurationSummary
     */
    'lower_whisker': number;
    /**
     * 
     * @type {number}
     * @memberof DurationSummary
     */
    'upper_whisker': number;
}
/**
 * 
 * @export
 * @interface FacetValue
 */
export interface FacetValue {
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * A leaderboard exists independently for each product_id in each country. Each country is associated with a single timezone. There is a daily, weekly, and monthly leaderboard.
 * @export
 * @interface Leaderboard
 */
export interface Leaderboard {
    /**
     * Unique ID for this leaderboard
     * @type {string}
     * @memberof Leaderboard
     */
    'id'?: string;
    /**
     * Descriptive name for the leaderboard based on the board_code
     * @type {string}
     * @memberof Leaderboard
     */
    'name'?: string;
    /**
     * The type of leaderboard. What the \"values\" represent.  Allowed values:   - __complete_count__ *(COMPLETE_COUNT)*: Number of Completes  - __largest_user_payout__ *(LARGEST_PAYOUT)*: Largest Single Payout  - __sum_user_payout__ *(SUM_PAYOUTS)*: (Sum of) Total Payouts
     * @type {LeaderboardCode}
     * @memberof Leaderboard
     */
    'board_code': LeaderboardCode;
    /**
     * product_id
     * @type {string}
     * @memberof Leaderboard
     */
    'bpid': string;
    /**
     * The country this leaderboard is for.
     * @type {string}
     * @memberof Leaderboard
     */
    'country_iso': string;
    /**
     * The time period range for the leaderboard.  Allowed values:   - __daily__ *(DAILY)*: UTC midnight to UTC midnight  - __weekly__ *(WEEKLY)*: Sunday Midnight to Sunday Midnight UTC  - __monthly__ *(MONTHLY)*: Jan 1 00:00:00
     * @type {LeaderboardFrequency}
     * @memberof Leaderboard
     */
    'freq': LeaderboardFrequency;
    /**
     * The timezone for the requested country
     * @type {string}
     * @memberof Leaderboard
     */
    'timezone_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Leaderboard
     */
    'sort_order'?: LeaderboardSortOrderEnum;
    /**
     * The total number of rows in the leaderboard.
     * @type {number}
     * @memberof Leaderboard
     */
    'row_count': number;
    /**
     * 
     * @type {Array<LeaderboardRow>}
     * @memberof Leaderboard
     */
    'rows'?: Array<LeaderboardRow>;
    /**
     * (unix timestamp) The start time of the time range this leaderboard covers.
     * @type {number}
     * @memberof Leaderboard
     */
    'start_timestamp': number;
    /**
     * (unix timestamp) The end time of the time range this leaderboard covers.
     * @type {number}
     * @memberof Leaderboard
     */
    'end_timestamp': number;
    /**
     * The UTC offset for the timezone
     * @type {string}
     * @memberof Leaderboard
     */
    'utc_offset': string;
    /**
     * The start time of the time range this leaderboard covers (local time, in the leaderboard\'s timezone).
     * @type {string}
     * @memberof Leaderboard
     */
    'local_start_time': string;
    /**
     * The end time of the time range this leaderboard covers (local time, in the leaderboard\'s timezone).
     * @type {string}
     * @memberof Leaderboard
     */
    'local_end_time': string;
    /**
     * A formatted string for time period covered by this leaderboard. Can be used to display to users.
     * @type {string}
     * @memberof Leaderboard
     */
    'start_end_str': string;
}

export const LeaderboardSortOrderEnum = {
    Ascending: 'ascending',
    Descending: 'descending'
} as const;

export type LeaderboardSortOrderEnum = typeof LeaderboardSortOrderEnum[keyof typeof LeaderboardSortOrderEnum];

/**
 * The type of leaderboard. What the \"values\" represent.
 * @export
 * @enum {string}
 */

export const LeaderboardCode = {
    CompleteCount: 'complete_count',
    LargestUserPayout: 'largest_user_payout',
    SumUserPayout: 'sum_user_payout'
} as const;

export type LeaderboardCode = typeof LeaderboardCode[keyof typeof LeaderboardCode];


/**
 * The time period range for the leaderboard.
 * @export
 * @enum {string}
 */

export const LeaderboardFrequency = {
    Daily: 'daily',
    Weekly: 'weekly',
    Monthly: 'monthly'
} as const;

export type LeaderboardFrequency = typeof LeaderboardFrequency[keyof typeof LeaderboardFrequency];


/**
 * 
 * @export
 * @interface LeaderboardResponse
 */
export interface LeaderboardResponse {
    /**
     * The status of the API response.
     * @type {string}
     * @memberof LeaderboardResponse
     */
    'status': LeaderboardResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardResponse
     */
    'msg'?: string | null;
    /**
     * 
     * @type {Leaderboard}
     * @memberof LeaderboardResponse
     */
    'leaderboard': Leaderboard;
}

export const LeaderboardResponseStatusEnum = {
    Success: 'success',
    Error: 'error'
} as const;

export type LeaderboardResponseStatusEnum = typeof LeaderboardResponseStatusEnum[keyof typeof LeaderboardResponseStatusEnum];

/**
 * 
 * @export
 * @interface LeaderboardRow
 */
export interface LeaderboardRow {
    /**
     * product_user_id
     * @type {string}
     * @memberof LeaderboardRow
     */
    'bpuid': string;
    /**
     * The numerical data ranks (1 through n) of the values. Ties are ranked using the lowest rank in the group.
     * @type {number}
     * @memberof LeaderboardRow
     */
    'rank': number;
    /**
     * The value. The meaning of the value is dependent on the LeaderboardCode.
     * @type {number}
     * @memberof LeaderboardRow
     */
    'value': number;
}
/**
 * 
 * @export
 * @interface LeaderboardWinner
 */
export interface LeaderboardWinner {
    /**
     * The user\'s final rank in the leaderboard
     * @type {number}
     * @memberof LeaderboardWinner
     */
    'rank': number;
    /**
     * The time period range for the leaderboard.  Allowed values:   - __daily__ *(DAILY)*: UTC midnight to UTC midnight  - __weekly__ *(WEEKLY)*: Sunday Midnight to Sunday Midnight UTC  - __monthly__ *(MONTHLY)*: Jan 1 00:00:00
     * @type {LeaderboardFrequency}
     * @memberof LeaderboardWinner
     */
    'freq': LeaderboardFrequency;
    /**
     * The type of leaderboard. What the \"values\" represent.  Allowed values:   - __complete_count__ *(COMPLETE_COUNT)*: Number of Completes  - __largest_user_payout__ *(LARGEST_PAYOUT)*: Largest Single Payout  - __sum_user_payout__ *(SUM_PAYOUTS)*: (Sum of) Total Payouts
     * @type {LeaderboardCode}
     * @memberof LeaderboardWinner
     */
    'board_code': LeaderboardCode;
    /**
     * The country this leaderboard is for.
     * @type {string}
     * @memberof LeaderboardWinner
     */
    'country_iso': string;
    /**
     * When the prize was issued.
     * @type {string}
     * @memberof LeaderboardWinner
     */
    'issued': string;
    /**
     * product_user_id
     * @type {string}
     * @memberof LeaderboardWinner
     */
    'bpuid': string;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardWinner
     */
    'description': string;
    /**
     * (USD cents) The reward amount
     * @type {number}
     * @memberof LeaderboardWinner
     */
    'amount': number;
    /**
     * The amount as a formatted string in USD. Can be displayed to the user.
     * @type {string}
     * @memberof LeaderboardWinner
     */
    'amount_str': string;
    /**
     * When the leaderboard started
     * @type {string}
     * @memberof LeaderboardWinner
     */
    'contest_start': string;
    /**
     * When the leaderboard ended
     * @type {string}
     * @memberof LeaderboardWinner
     */
    'contest_end': string;
}


/**
 * 
 * @export
 * @interface LeaderboardWinnerResponse
 */
export interface LeaderboardWinnerResponse {
    /**
     * The status of the API response.
     * @type {string}
     * @memberof LeaderboardWinnerResponse
     */
    'status': LeaderboardWinnerResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof LeaderboardWinnerResponse
     */
    'msg'?: string | null;
    /**
     * 
     * @type {Array<LeaderboardWinner>}
     * @memberof LeaderboardWinnerResponse
     */
    'winners'?: Array<LeaderboardWinner>;
}

export const LeaderboardWinnerResponseStatusEnum = {
    Success: 'success',
    Error: 'error'
} as const;

export type LeaderboardWinnerResponseStatusEnum = typeof LeaderboardWinnerResponseStatusEnum[keyof typeof LeaderboardWinnerResponseStatusEnum];

/**
 * 
 * @export
 * @interface ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInner
 */
export interface ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInner {
    /**
     * Name of contest. Can be displayed to user.
     * @type {string}
     * @memberof ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInner
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInner
     */
    'contest_type'?: ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInnerContestTypeEnum;
    /**
     * 
     * @type {MilestoneContestEndCondition}
     * @memberof ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInner
     */
    'end_condition': MilestoneContestEndCondition;
    /**
     * 
     * @type {Array<ContestPrize>}
     * @memberof ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInner
     */
    'prizes'?: Array<ContestPrize>;
    /**
     * When the contest starts
     * @type {string}
     * @memberof ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInner
     */
    'starts_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInner
     */
    'terms_and_conditions'?: string;
    /**
     * 
     * @type {ContestStatus}
     * @memberof ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInner
     */
    'status'?: ContestStatus;
    /**
     * 
     * @type {string}
     * @memberof ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInner
     */
    'country_isos'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInner
     */
    'uuid'?: string;
    /**
     * Contest applies only to a single BP
     * @type {string}
     * @memberof ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInner
     */
    'product_id': string;
    /**
     * When this contest was created
     * @type {string}
     * @memberof ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInner
     */
    'created_at'?: string;
    /**
     * When this contest was last modified. Does not include entries being created/modified
     * @type {string}
     * @memberof ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInner
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInner
     */
    'ended_at'?: string;
    /**
     * 
     * @type {ContestEndReason}
     * @memberof ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInner
     */
    'end_reason'?: ContestEndReason;
    /**
     * 
     * @type {string}
     * @memberof ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInner
     */
    'product_user_id': string;
    /**
     * The prizes won in this contest by the requested user
     * @type {Array<ContestWinner>}
     * @memberof ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInner
     */
    'user_winnings'?: Array<ContestWinner>;
    /**
     * 
     * @type {string}
     * @memberof ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInner
     */
    'entry_type': ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInnerEntryTypeEnum;
    /**
     * 
     * @type {ContestEntryRule}
     * @memberof ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInner
     */
    'entry_rule'?: ContestEntryRule;
    /**
     * 
     * @type {CurrentAmount}
     * @memberof ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInner
     */
    'current_amount'?: CurrentAmount;
    /**
     * Count of unique participants
     * @type {number}
     * @memberof ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInner
     */
    'current_participants'?: number;
    /**
     * The total amount for this user for this contest
     * @type {number}
     * @memberof ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInner
     */
    'user_amount': number;
    /**
     * 
     * @type {UserAmountToday}
     * @memberof ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInner
     */
    'user_amount_today': UserAmountToday;
    /**
     * Probability of this user winning 1 or more prizes, if the contestended right now
     * @type {number}
     * @memberof ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInner
     */
    'current_win_probability': number;
    /**
     * 
     * @type {number}
     * @memberof ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInner
     */
    'projected_win_probability': number;
    /**
     * Each user \'wins\' (receives prizes) once this target amount is reached.
     * @type {number}
     * @memberof ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInner
     */
    'target_amount': number;
    /**
     * 
     * @type {ContestEntryTrigger}
     * @memberof ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInner
     */
    'entry_trigger'?: ContestEntryTrigger;
    /**
     * 
     * @type {string}
     * @memberof ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInner
     */
    'valid_for'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInner
     */
    'valid_for_event'?: ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInnerValidForEventEnum;
    /**
     * The number of times the milestone has been reached.
     * @type {number}
     * @memberof ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInner
     */
    'win_count'?: number;
}

export const ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInnerContestTypeEnum = {
    Milestone: 'milestone'
} as const;

export type ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInnerContestTypeEnum = typeof ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInnerContestTypeEnum[keyof typeof ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInnerContestTypeEnum];
export const ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInnerEntryTypeEnum = {
    Count: 'count'
} as const;

export type ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInnerEntryTypeEnum = typeof ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInnerEntryTypeEnum[keyof typeof ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInnerEntryTypeEnum];
export const ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInnerValidForEventEnum = {
    Signup: 'signup'
} as const;

export type ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInnerValidForEventEnum = typeof ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInnerValidForEventEnum[keyof typeof ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInnerValidForEventEnum];

/**
 * 
 * @export
 * @interface MarketProfileKnowledge
 */
export interface MarketProfileKnowledge {
    /**
     * Name of the source
     * @type {string}
     * @memberof MarketProfileKnowledge
     */
    'source': string;
    /**
     * 
     * @type {string}
     * @memberof MarketProfileKnowledge
     */
    'question_id': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof MarketProfileKnowledge
     */
    'answer'?: Array<string>;
    /**
     * When the User submitted this Profiling data
     * @type {string}
     * @memberof MarketProfileKnowledge
     */
    'created': string;
}
/**
 * 
 * @export
 * @interface MarketplaceBucket
 */
export interface MarketplaceBucket {
    /**
     * Unique identifier this particular bucket
     * @type {string}
     * @memberof MarketplaceBucket
     */
    'id': string;
    /**
     * The URL to send a respondent into. Must not edit this URL in any way
     * @type {string}
     * @memberof MarketplaceBucket
     */
    'uri': string;
    /**
     * For UI. Provides a dimensionality position for the bucket on the x-axis.
     * @type {number}
     * @memberof MarketplaceBucket
     */
    'x'?: number;
    /**
     * For UI. Provides a dimensionality position for the bucket on the y-axis.
     * @type {number}
     * @memberof MarketplaceBucket
     */
    'y'?: number;
    /**
     * Currently unused. Will always return empty string
     * @type {string}
     * @memberof MarketplaceBucket
     */
    'name'?: string;
    /**
     * Currently unused. Will always return empty string
     * @type {string}
     * @memberof MarketplaceBucket
     */
    'description'?: string;
    /**
     * 
     * @type {Array<CategoryAssociation>}
     * @memberof MarketplaceBucket
     */
    'category'?: Array<CategoryAssociation>;
    /**
     * 
     * @type {Array<BucketTask>}
     * @memberof MarketplaceBucket
     */
    'contents': Array<BucketTask>;
    /**
     * 
     * @type {DurationSummary}
     * @memberof MarketplaceBucket
     */
    'duration': DurationSummary;
    /**
     * 
     * @type {PayoutSummary}
     * @memberof MarketplaceBucket
     */
    'payout': PayoutSummary;
    /**
     * this is the source of the contents
     * @type {string}
     * @memberof MarketplaceBucket
     */
    'source': MarketplaceBucketSourceEnum;
}

export const MarketplaceBucketSourceEnum = {
    Innovate: 'innovate',
    Dynata: 'dynata',
    Schlesinger: 'schlesinger',
    Purespectrum: 'purespectrum',
    Morning: 'morning',
    Pollfish: 'pollfish',
    Precision: 'precision',
    Repdata: 'repdata',
    Prodege: 'prodege'
} as const;

export type MarketplaceBucketSourceEnum = typeof MarketplaceBucketSourceEnum[keyof typeof MarketplaceBucketSourceEnum];

/**
 * 
 * @export
 * @interface MarketplaceInventorySummary
 */
export interface MarketplaceInventorySummary {
    /**
     * The count of tasks that are currently live
     * @type {Array<CountStat>}
     * @memberof MarketplaceInventorySummary
     */
    'live_tasks'?: Array<CountStat>;
    /**
     * The count of gen-pop tasks that are currently live
     * @type {Array<CountStat>}
     * @memberof MarketplaceInventorySummary
     */
    'live_gen_pop_tasks'?: Array<CountStat>;
    /**
     * The count of tasks created
     * @type {Array<CountStat>}
     * @memberof MarketplaceInventorySummary
     */
    'tasks_created'?: Array<CountStat>;
    /**
     * Number of finishes needed across all live tasks
     * @type {Array<CountStat>}
     * @memberof MarketplaceInventorySummary
     */
    'required_finishes'?: Array<CountStat>;
    /**
     * The distribution of payouts for all live tasks
     * @type {Array<StatisticalSummaryStat>}
     * @memberof MarketplaceInventorySummary
     */
    'payout'?: Array<StatisticalSummaryStat>;
    /**
     * The distribution of expected durations for all live tasks
     * @type {Array<StatisticalSummaryStat>}
     * @memberof MarketplaceInventorySummary
     */
    'expected_duration'?: Array<StatisticalSummaryStat>;
    /**
     * The distribution of required finishes on all live tasks
     * @type {Array<StatisticalSummaryStat>}
     * @memberof MarketplaceInventorySummary
     */
    'required_finishes_per_task'?: Array<StatisticalSummaryStat>;
}
/**
 * Returns buckets grouped by marketplace, one per marketplace, with the tasks ordered by quality.  Offerwall code: `5fa23085`
 * @export
 * @interface MarketplaceOfferwall
 */
export interface MarketplaceOfferwall {
    /**
     * Unique identifier to reference a generated offerwall
     * @type {string}
     * @memberof MarketplaceOfferwall
     */
    'id': string;
    /**
     * Total opportunities available for specific bpuid respondent and parameters. This value changes frequently and can be used to determine if a respondent has potential tasks available, regardless of the offerwall type being requested. If the value is 0, no buckets will be generated.
     * @type {number}
     * @memberof MarketplaceOfferwall
     */
    'availability_count': number;
    /**
     * 
     * @type {Array<MarketplaceBucket>}
     * @memberof MarketplaceOfferwall
     */
    'buckets'?: Array<MarketplaceBucket>;
}
/**
 * 
 * @export
 * @interface MarketplaceOfferwallResponse
 */
export interface MarketplaceOfferwallResponse {
    /**
     * 
     * @type {OfferWallInfo}
     * @memberof MarketplaceOfferwallResponse
     */
    'info': OfferWallInfo;
    /**
     * 
     * @type {MarketplaceOfferwall}
     * @memberof MarketplaceOfferwallResponse
     */
    'offerwall': MarketplaceOfferwall;
}
/**
 * 
 * @export
 * @interface MarketplaceSummary
 */
export interface MarketplaceSummary {
    /**
     * Inventory of the marketplace
     * @type {MarketplaceInventorySummary}
     * @memberof MarketplaceSummary
     */
    'inventory': MarketplaceInventorySummary;
    /**
     * 
     * @type {string}
     * @memberof MarketplaceSummary
     */
    'user_activity'?: string | null;
}
/**
 * Maximum total value of entries per user
 * @export
 * @interface MaxEntryAmountPerUser
 */
export interface MaxEntryAmountPerUser {
}
/**
 * Defines the conditions to evaluate to determine when the contest is over. Multiple conditions can be set. The contest is over once ANY conditions are met.
 * @export
 * @interface MilestoneContestEndCondition
 */
export interface MilestoneContestEndCondition {
    /**
     * 
     * @type {number}
     * @memberof MilestoneContestEndCondition
     */
    'max_winners'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof MilestoneContestEndCondition
     */
    'ends_at'?: string | null;
}
/**
 * 
 * @export
 * @interface MilestoneUserView
 */
export interface MilestoneUserView {
    /**
     * Each user \'wins\' (receives prizes) once this target amount is reached.
     * @type {number}
     * @memberof MilestoneUserView
     */
    'target_amount': number;
    /**
     * 
     * @type {ContestEntryTrigger}
     * @memberof MilestoneUserView
     */
    'entry_trigger'?: ContestEntryTrigger | null;
    /**
     * 
     * @type {string}
     * @memberof MilestoneUserView
     */
    'valid_for'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MilestoneUserView
     */
    'valid_for_event'?: MilestoneUserViewValidForEventEnum | null;
    /**
     * Name of contest. Can be displayed to user.
     * @type {string}
     * @memberof MilestoneUserView
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MilestoneUserView
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MilestoneUserView
     */
    'contest_type'?: MilestoneUserViewContestTypeEnum;
    /**
     * 
     * @type {MilestoneContestEndCondition}
     * @memberof MilestoneUserView
     */
    'end_condition': MilestoneContestEndCondition;
    /**
     * 
     * @type {Array<ContestPrize>}
     * @memberof MilestoneUserView
     */
    'prizes'?: Array<ContestPrize>;
    /**
     * When the contest starts
     * @type {string}
     * @memberof MilestoneUserView
     */
    'starts_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof MilestoneUserView
     */
    'terms_and_conditions'?: string | null;
    /**
     * 
     * @type {ContestStatus}
     * @memberof MilestoneUserView
     */
    'status'?: ContestStatus;
    /**
     * 
     * @type {string}
     * @memberof MilestoneUserView
     */
    'country_isos'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MilestoneUserView
     */
    'uuid'?: string;
    /**
     * Contest applies only to a single BP
     * @type {string}
     * @memberof MilestoneUserView
     */
    'product_id': string;
    /**
     * When this contest was created
     * @type {string}
     * @memberof MilestoneUserView
     */
    'created_at'?: string;
    /**
     * When this contest was last modified. Does not include entries being created/modified
     * @type {string}
     * @memberof MilestoneUserView
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof MilestoneUserView
     */
    'ended_at'?: string | null;
    /**
     * 
     * @type {ContestEndReason}
     * @memberof MilestoneUserView
     */
    'end_reason'?: ContestEndReason | null;
    /**
     * 
     * @type {string}
     * @memberof MilestoneUserView
     */
    'product_user_id': string;
    /**
     * The prizes won in this contest by the requested user
     * @type {Array<ContestWinner>}
     * @memberof MilestoneUserView
     */
    'user_winnings'?: Array<ContestWinner>;
    /**
     * 
     * @type {string}
     * @memberof MilestoneUserView
     */
    'entry_type'?: MilestoneUserViewEntryTypeEnum;
    /**
     * The number of times the milestone has been reached.
     * @type {number}
     * @memberof MilestoneUserView
     */
    'win_count'?: number;
    /**
     * The total amount for this user for this contest
     * @type {number}
     * @memberof MilestoneUserView
     */
    'user_amount': number;
}

export const MilestoneUserViewValidForEventEnum = {
    Signup: 'signup'
} as const;

export type MilestoneUserViewValidForEventEnum = typeof MilestoneUserViewValidForEventEnum[keyof typeof MilestoneUserViewValidForEventEnum];
export const MilestoneUserViewContestTypeEnum = {
    Milestone: 'milestone'
} as const;

export type MilestoneUserViewContestTypeEnum = typeof MilestoneUserViewContestTypeEnum[keyof typeof MilestoneUserViewContestTypeEnum];
export const MilestoneUserViewEntryTypeEnum = {
    Count: 'count'
} as const;

export type MilestoneUserViewEntryTypeEnum = typeof MilestoneUserViewEntryTypeEnum[keyof typeof MilestoneUserViewEntryTypeEnum];

/**
 * 
 * @export
 * @interface OfferWallInfo
 */
export interface OfferWallInfo {
    /**
     * 
     * @type {boolean}
     * @memberof OfferWallInfo
     */
    'success': boolean;
}
/**
 * Each bucket has only 1 single task, and only basic info is returned     about each bucket.  Offerwall code: `6f27b1ae`
 * @export
 * @interface OneShotOfferwall
 */
export interface OneShotOfferwall {
    /**
     * Unique identifier to reference a generated offerwall
     * @type {string}
     * @memberof OneShotOfferwall
     */
    'id': string;
    /**
     * Total opportunities available for specific bpuid respondent and parameters. This value changes frequently and can be used to determine if a respondent has potential tasks available, regardless of the offerwall type being requested. If the value is 0, no buckets will be generated.
     * @type {number}
     * @memberof OneShotOfferwall
     */
    'availability_count': number;
    /**
     * 
     * @type {Array<OneShotOfferwallBucket>}
     * @memberof OneShotOfferwall
     */
    'buckets'?: Array<OneShotOfferwallBucket>;
}
/**
 * 
 * @export
 * @interface OneShotOfferwallBucket
 */
export interface OneShotOfferwallBucket {
    /**
     * Unique identifier this particular bucket
     * @type {string}
     * @memberof OneShotOfferwallBucket
     */
    'id': string;
    /**
     * The URL to send a respondent into. Must not edit this URL in any way
     * @type {string}
     * @memberof OneShotOfferwallBucket
     */
    'uri': string;
    /**
     * The bucket\'s expected duration, in seconds
     * @type {number}
     * @memberof OneShotOfferwallBucket
     */
    'duration': number;
    /**
     * The bucket\'s min payout, in usd cents
     * @type {number}
     * @memberof OneShotOfferwallBucket
     */
    'min_payout': number;
}
/**
 * 
 * @export
 * @interface OneShotOfferwallResponse
 */
export interface OneShotOfferwallResponse {
    /**
     * 
     * @type {OfferWallInfo}
     * @memberof OneShotOfferwallResponse
     */
    'info': OfferWallInfo;
    /**
     * 
     * @type {OneShotOfferwall}
     * @memberof OneShotOfferwallResponse
     */
    'offerwall': OneShotOfferwall;
}
/**
 * 
 * @export
 * @interface PatternValidation
 */
export interface PatternValidation {
    /**
     * Message to display if validation fails
     * @type {string}
     * @memberof PatternValidation
     */
    'message': string;
    /**
     * Regex string to validate. min_length and max_length are checked separately, even if they are part of the regex.
     * @type {string}
     * @memberof PatternValidation
     */
    'pattern': string;
}
/**
 * Store configuration related to payouts, payout transformation, and user payout formatting.
 * @export
 * @interface PayoutConfig
 */
export interface PayoutConfig {
    /**
     * 
     * @type {string}
     * @memberof PayoutConfig
     */
    'payout_format'?: string | null;
    /**
     * 
     * @type {PayoutTransformation}
     * @memberof PayoutConfig
     */
    'payout_transformation'?: PayoutTransformation | null;
}
/**
 * The max size of the db field that holds this value is 20, so please don\'t add new values longer than that!
 * @export
 * @enum {string}
 */

export const PayoutStatus = {
    Pending: 'PENDING',
    Approved: 'APPROVED',
    Rejected: 'REJECTED',
    Cancelled: 'CANCELLED',
    Failed: 'FAILED',
    Complete: 'COMPLETE'
} as const;

export type PayoutStatus = typeof PayoutStatus[keyof typeof PayoutStatus];


/**
 * Payouts are in Integer USD Cents
 * @export
 * @interface PayoutSummary
 */
export interface PayoutSummary {
    /**
     * 
     * @type {number}
     * @memberof PayoutSummary
     */
    'min': number;
    /**
     * 
     * @type {number}
     * @memberof PayoutSummary
     */
    'max': number;
    /**
     * 
     * @type {number}
     * @memberof PayoutSummary
     */
    'mean'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PayoutSummary
     */
    'q1': number;
    /**
     * 
     * @type {number}
     * @memberof PayoutSummary
     */
    'q2': number;
    /**
     * 
     * @type {number}
     * @memberof PayoutSummary
     */
    'q3': number;
    /**
     * 
     * @type {number}
     * @memberof PayoutSummary
     */
    'lower_whisker': number;
    /**
     * 
     * @type {number}
     * @memberof PayoutSummary
     */
    'upper_whisker': number;
}
/**
 * This model describe how the bp_payout is converted to the user_payout. If None, the user_payout is None.  If the user_wallet_enabled is `False`, the user_payout is used to     1) know how to transform the expected payouts for offerwall buckets         (if min_payout is requested, this is based on the user_payout)     2) show the user (using the payout_format) how much they made (in         the Task Status Response). If the user_wallet_enabled is `True`, then in addition to the above, the     user_payout is the amount actually paid to the user\'s wallet.
 * @export
 * @interface PayoutTransformation
 */
export interface PayoutTransformation {
    /**
     * The name of the transformation function to use.
     * @type {string}
     * @memberof PayoutTransformation
     */
    'f': PayoutTransformationFEnum;
    /**
     * The kwargs to pass to the transformation function.
     * @type {PayoutTransformationPercentArgs}
     * @memberof PayoutTransformation
     */
    'kwargs': PayoutTransformationPercentArgs;
}

export const PayoutTransformationFEnum = {
    PayoutTransformationPercent: 'payout_transformation_percent'
} as const;

export type PayoutTransformationFEnum = typeof PayoutTransformationFEnum[keyof typeof PayoutTransformationFEnum];

/**
 * 
 * @export
 * @interface PayoutTransformationPercentArgs
 */
export interface PayoutTransformationPercentArgs {
    /**
     * The percentage of the bp_payout to pay the user
     * @type {number}
     * @memberof PayoutTransformationPercentArgs
     */
    'pct': number;
    /**
     * 
     * @type {string}
     * @memberof PayoutTransformationPercentArgs
     */
    'min_payout'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PayoutTransformationPercentArgs
     */
    'max_payout'?: string | null;
}
/**
 * The method in which the requested payout is delivered.
 * @export
 * @enum {string}
 */

export const PayoutType = {
    Paypal: 'PAYPAL',
    Tango: 'TANGO',
    Dwolla: 'DWOLLA',
    Ach: 'ACH',
    Wire: 'WIRE',
    CashInMail: 'CASH_IN_MAIL',
    Prize: 'PRIZE',
    Amt: 'AMT',
    AmtBonus: 'AMT_BONUS',
    AmtAssignment: 'AMT_ASSIGNMENT'
} as const;

export type PayoutType = typeof PayoutType[keyof typeof PayoutType];


/**
 * 
 * @export
 * @interface PaypalCashoutMethodData
 */
export interface PaypalCashoutMethodData {
    /**
     * 
     * @type {string}
     * @memberof PaypalCashoutMethodData
     */
    'type'?: PaypalCashoutMethodDataTypeEnum;
    /**
     * Email address of the paypal user
     * @type {string}
     * @memberof PaypalCashoutMethodData
     */
    'email': string;
}

export const PaypalCashoutMethodDataTypeEnum = {
    Paypal: 'PAYPAL'
} as const;

export type PaypalCashoutMethodDataTypeEnum = typeof PaypalCashoutMethodDataTypeEnum[keyof typeof PaypalCashoutMethodDataTypeEnum];

/**
 * 
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * Unique identifier of the Brokerage Product
     * @type {string}
     * @memberof Product
     */
    'id'?: string;
    /**
     * Name of the Brokerage Product. Must be unique within a Team
     * @type {string}
     * @memberof Product
     */
    'name': string;
    /**
     * This is only used to hard block a Product in order to immediately & safely protect against fraud entrances.
     * @type {boolean}
     * @memberof Product
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'created'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'team_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    'business_id'?: string | null;
    /**
     * Tags which are used to annotate supplier traffic
     * @type {Set<SupplierTag>}
     * @memberof Product
     */
    'tags'?: Set<SupplierTag>;
    /**
     * Where to redirect the user after finishing a session. When a user get redirected back to the supplier, a query param will be added with the name \'tsid\', and the value of the TSID for the session. For example: callback_uri: \'https://www.example.com/test/?a=1&b=2\' might result in the user getting redirected to: \'https://www.example.com/grl-callback/?a=1&b=2&tsid=c6ab6ba1e75b44e2bf5aab00fc68e3b7\'.
     * @type {string}
     * @memberof Product
     */
    'redirect_url': string;
    /**
     * This is the domain that is used for the GRS (General Research Survey) platform. This is a simple javascript application which may profile the respondent for anyprofiling questions, along with collecting any browserbased security information. The value is a scheme+domain only (no path).
     * @type {string}
     * @memberof Product
     */
    'harmonizer_domain'?: string;
    /**
     * 
     * @type {SourcesConfig}
     * @memberof Product
     */
    'sources_config'?: SourcesConfig;
    /**
     * 
     * @type {SessionConfig}
     * @memberof Product
     */
    'session_config'?: SessionConfig;
    /**
     * 
     * @type {PayoutConfig}
     * @memberof Product
     */
    'payout_config'?: PayoutConfig;
    /**
     * 
     * @type {UserWalletConfig}
     * @memberof Product
     */
    'user_wallet_config'?: UserWalletConfig;
    /**
     * 
     * @type {UserCreateConfig}
     * @memberof Product
     */
    'user_create_config'?: UserCreateConfig;
    /**
     * 
     * @type {object}
     * @memberof Product
     */
    'offerwall_config'?: object;
    /**
     * 
     * @type {ProfilingConfig}
     * @memberof Product
     */
    'profiling_config'?: ProfilingConfig;
    /**
     * 
     * @type {UserHealthConfig}
     * @memberof Product
     */
    'user_health_config'?: UserHealthConfig;
    /**
     * 
     * @type {object}
     * @memberof Product
     */
    'yield_man_config'?: object;
    /**
     * 
     * @type {UserWalletConfig}
     * @memberof Product
     */
    'user_wallet': UserWalletConfig;
}
/**
 * 
 * @export
 * @interface ProfilingConfig
 */
export interface ProfilingConfig {
    /**
     * If False, the harmonizer/profiling system is not used at all. This should never be False unless special circumstances
     * @type {boolean}
     * @memberof ProfilingConfig
     */
    'enabled'?: boolean;
    /**
     * If grs_enabled is False, and is_grs is passed in the profiling-questions call,          then don\'t actually return any questions. This allows a client to hit the endpoint with no limit          and still get questions. In effect, this means that we\'ll redirect the user through the GRS         system but won\'t present them any questions.
     * @type {boolean}
     * @memberof ProfilingConfig
     */
    'grs_enabled'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ProfilingConfig
     */
    'n_questions'?: number | null;
    /**
     * The max number of questions we would ask in a session
     * @type {number}
     * @memberof ProfilingConfig
     */
    'max_questions'?: number;
    /**
     * The average number of questions to ask in a session
     * @type {number}
     * @memberof ProfilingConfig
     */
    'avg_question_count'?: number;
    /**
     * Scale how frequently we inject profiling questions, relative to the default.1 is default, 2 is twice as often. 10 means always. 0.5 half as often
     * @type {number}
     * @memberof ProfilingConfig
     */
    'task_injection_freq_mult'?: number;
    /**
     * Non-us multiplier, used to increase freq and length of profilers in all non-us countries.This value is multiplied by task_injection_freq_mult and avg_question_count.
     * @type {number}
     * @memberof ProfilingConfig
     */
    'non_us_mult'?: number;
    /**
     * How frequently we should refresh hidden questions
     * @type {number}
     * @memberof ProfilingConfig
     */
    'hidden_questions_expiration_hours'?: number;
}
/**
 * 
 * @export
 * @interface ProfilingInfoResponse
 */
export interface ProfilingInfoResponse {
    /**
     * The status of the API response.
     * @type {string}
     * @memberof ProfilingInfoResponse
     */
    'status': ProfilingInfoResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ProfilingInfoResponse
     */
    'msg'?: string | null;
    /**
     * 
     * @type {Array<QuestionInfo>}
     * @memberof ProfilingInfoResponse
     */
    'profiling-info': Array<QuestionInfo>;
}

export const ProfilingInfoResponseStatusEnum = {
    Success: 'success',
    Error: 'error'
} as const;

export type ProfilingInfoResponseStatusEnum = typeof ProfilingInfoResponseStatusEnum[keyof typeof ProfilingInfoResponseStatusEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const PropertyType = {
    I: 'i',
    N: 'n',
    X: 'x'
} as const;

export type PropertyType = typeof PropertyType[keyof typeof PropertyType];


/**
 * 
 * @export
 * @interface QuestionInfo
 */
export interface QuestionInfo {
    /**
     * 
     * @type {string}
     * @memberof QuestionInfo
     */
    'property_id': string;
    /**
     * 
     * @type {string}
     * @memberof QuestionInfo
     */
    'property_label': string;
    /**
     *  Allowed values:   - __i__ *(UPK_ITEM)*: UserProfileKnowledge Item  - __n__ *(UPK_NUMERICAL)*: UserProfileKnowledge Numerical  - __x__ *(UPK_TEXT)*: UserProfileKnowledge Text
     * @type {string}
     * @memberof QuestionInfo
     */
    'prop_type'?: QuestionInfoPropTypeEnum;
    /**
     *  Allowed values:   - __*__ *(ZERO_OR_MORE)*: Zero or More  - __?__ *(ZERO_OR_ONE)*: Zero or One
     * @type {string}
     * @memberof QuestionInfo
     */
    'cardinality'?: QuestionInfoCardinalityEnum;
    /**
     * 
     * @type {string}
     * @memberof QuestionInfo
     */
    'country_iso': string;
    /**
     * A Gold-Standard question has been enumerated for all possible values (per country) as best as possible by GRL,allowing it to be mapped across inventory sources. A property not marked as Gold-Standard may have: 1) marketplace qid associations & 2) category associations, but doesn\'t have a defined \'range\' (list of allowed itemsin a multiple choice question). This is used for exposing a user\'s profiling data & forthe Nudge API.
     * @type {boolean}
     * @memberof QuestionInfo
     */
    'gold_standard'?: boolean;
    /**
     * 
     * @type {Array<QuestionOption>}
     * @memberof QuestionInfo
     */
    'options'?: Array<QuestionOption>;
    /**
     * 
     * @type {Array<Category>}
     * @memberof QuestionInfo
     */
    'category': Array<Category>;
}

export const QuestionInfoPropTypeEnum = {
    I: 'i',
    N: 'n',
    X: 'x'
} as const;

export type QuestionInfoPropTypeEnum = typeof QuestionInfoPropTypeEnum[keyof typeof QuestionInfoPropTypeEnum];
export const QuestionInfoCardinalityEnum = {
    Star: '*',
    QuestionMark: '?'
} as const;

export type QuestionInfoCardinalityEnum = typeof QuestionInfoCardinalityEnum[keyof typeof QuestionInfoCardinalityEnum];

/**
 * 
 * @export
 * @interface QuestionOption
 */
export interface QuestionOption {
    /**
     * 
     * @type {string}
     * @memberof QuestionOption
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof QuestionOption
     */
    'label': string;
}
/**
 * 
 * @export
 * @interface RaffleUserView
 */
export interface RaffleUserView {
    /**
     * Name of contest. Can be displayed to user.
     * @type {string}
     * @memberof RaffleUserView
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof RaffleUserView
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RaffleUserView
     */
    'contest_type'?: RaffleUserViewContestTypeEnum;
    /**
     * 
     * @type {ContestEndCondition}
     * @memberof RaffleUserView
     */
    'end_condition': ContestEndCondition;
    /**
     * 
     * @type {Array<ContestPrize>}
     * @memberof RaffleUserView
     */
    'prizes'?: Array<ContestPrize>;
    /**
     * When the contest starts
     * @type {string}
     * @memberof RaffleUserView
     */
    'starts_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof RaffleUserView
     */
    'terms_and_conditions'?: string | null;
    /**
     * 
     * @type {ContestStatus}
     * @memberof RaffleUserView
     */
    'status'?: ContestStatus;
    /**
     * 
     * @type {string}
     * @memberof RaffleUserView
     */
    'country_isos'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RaffleUserView
     */
    'uuid'?: string;
    /**
     * Contest applies only to a single BP
     * @type {string}
     * @memberof RaffleUserView
     */
    'product_id': string;
    /**
     * When this contest was created
     * @type {string}
     * @memberof RaffleUserView
     */
    'created_at'?: string;
    /**
     * When this contest was last modified. Does not include entries being created/modified
     * @type {string}
     * @memberof RaffleUserView
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof RaffleUserView
     */
    'ended_at'?: string | null;
    /**
     * 
     * @type {ContestEndReason}
     * @memberof RaffleUserView
     */
    'end_reason'?: ContestEndReason | null;
    /**
     * 
     * @type {string}
     * @memberof RaffleUserView
     */
    'product_user_id': string;
    /**
     * The prizes won in this contest by the requested user
     * @type {Array<ContestWinner>}
     * @memberof RaffleUserView
     */
    'user_winnings'?: Array<ContestWinner>;
    /**
     * 
     * @type {ContestEntryType}
     * @memberof RaffleUserView
     */
    'entry_type': ContestEntryType;
    /**
     * 
     * @type {ContestEntryRule}
     * @memberof RaffleUserView
     */
    'entry_rule'?: ContestEntryRule;
    /**
     * 
     * @type {CurrentAmount}
     * @memberof RaffleUserView
     */
    'current_amount'?: CurrentAmount;
    /**
     * Count of unique participants
     * @type {number}
     * @memberof RaffleUserView
     */
    'current_participants'?: number;
    /**
     * 
     * @type {UserAmount}
     * @memberof RaffleUserView
     */
    'user_amount': UserAmount;
    /**
     * 
     * @type {UserAmountToday}
     * @memberof RaffleUserView
     */
    'user_amount_today': UserAmountToday;
    /**
     * Probability of this user winning 1 or more prizes, if the contestended right now
     * @type {number}
     * @memberof RaffleUserView
     */
    'current_win_probability': number;
    /**
     * 
     * @type {number}
     * @memberof RaffleUserView
     */
    'projected_win_probability': number | null;
}

export const RaffleUserViewContestTypeEnum = {
    Raffle: 'raffle'
} as const;

export type RaffleUserViewContestTypeEnum = typeof RaffleUserViewContestTypeEnum[keyof typeof RaffleUserViewContestTypeEnum];

/**
 * Supported Currencies for Foreign Redemptions
 * @export
 * @enum {string}
 */

export const RedemptionCurrency = {
    Usd: 'USD',
    Cad: 'CAD',
    Gbp: 'GBP',
    Eur: 'EUR',
    Inr: 'INR',
    Aud: 'AUD',
    Pln: 'PLN',
    Sek: 'SEK',
    Sgd: 'SGD',
    Mxn: 'MXN'
} as const;

export type RedemptionCurrency = typeof RedemptionCurrency[keyof typeof RedemptionCurrency];


/**
 * 
 * @export
 * @interface ReportTask
 */
export interface ReportTask {
    /**
     * The unique identifier for the user, which is set by the Supplier.
     * @type {string}
     * @memberof ReportTask
     */
    'bpuid': string;
    /**
     * The reason a user reported a task.  Allowed values:   - __0__ *(REASON_UNKNOWN)*: Used to indicate the user exited the task without giving feedback  - __1__ *(TECHNICAL_ERROR)*: Task is in the wrong language/country, unanswerable question, won\'t proceed to next question, loading forever, error message  - __2__ *(NO_REDIRECT)*: Task ended (completed or failed, and showed the user some dialog indicating the task was over), but failed to redirect  - __3__ *(PRIVACY_INVASION)*: Asked for full name, home address, identity on another site, cc  - __4__ *(UNCOMFORTABLE_TOPICS)*: Asked about children, employer, medical issues, drug use, STDs, etc.  - __5__ *(ASKED_FOR_NOT_ALLOWED_ACTION)*: Asked to install software, signup/login to external site, access webcam, promise to pay using external site, etc.  - __6__ *(BAD_ON_MOBILE)*: Task doesn\'t work well on a mobile device  - __7__ *(DIDNT_LIKE)*: Too long, too boring, confusing, complicated, too many open-ended/free-response questions
     * @type {Array<ReportValue>}
     * @memberof ReportTask
     */
    'reasons'?: Array<ReportValue>;
    /**
     * 
     * @type {string}
     * @memberof ReportTask
     */
    'notes'?: string;
}
/**
 * The reason a user reported a task.
 * @export
 * @enum {number}
 */

export const ReportValue = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4,
    NUMBER_5: 5,
    NUMBER_6: 6,
    NUMBER_7: 7
} as const;

export type ReportValue = typeof ReportValue[keyof typeof ReportValue];


/**
 * 
 * @export
 * @interface ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGet
 */
export interface ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGet {
    /**
     * Name of contest. Can be displayed to user.
     * @type {string}
     * @memberof ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGet
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGet
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGet
     */
    'contest_type'?: ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGetContestTypeEnum;
    /**
     * 
     * @type {MilestoneContestEndCondition}
     * @memberof ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGet
     */
    'end_condition': MilestoneContestEndCondition;
    /**
     * 
     * @type {Array<ContestPrize>}
     * @memberof ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGet
     */
    'prizes'?: Array<ContestPrize>;
    /**
     * When the contest starts
     * @type {string}
     * @memberof ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGet
     */
    'starts_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGet
     */
    'terms_and_conditions'?: string;
    /**
     * 
     * @type {ContestStatus}
     * @memberof ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGet
     */
    'status'?: ContestStatus;
    /**
     * 
     * @type {string}
     * @memberof ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGet
     */
    'country_isos'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGet
     */
    'uuid'?: string;
    /**
     * Contest applies only to a single BP
     * @type {string}
     * @memberof ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGet
     */
    'product_id': string;
    /**
     * When this contest was created
     * @type {string}
     * @memberof ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGet
     */
    'created_at'?: string;
    /**
     * When this contest was last modified. Does not include entries being created/modified
     * @type {string}
     * @memberof ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGet
     */
    'updated_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGet
     */
    'ended_at'?: string;
    /**
     * 
     * @type {ContestEndReason}
     * @memberof ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGet
     */
    'end_reason'?: ContestEndReason;
    /**
     * 
     * @type {string}
     * @memberof ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGet
     */
    'product_user_id': string;
    /**
     * The prizes won in this contest by the requested user
     * @type {Array<ContestWinner>}
     * @memberof ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGet
     */
    'user_winnings'?: Array<ContestWinner>;
    /**
     * 
     * @type {string}
     * @memberof ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGet
     */
    'entry_type': ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGetEntryTypeEnum;
    /**
     * 
     * @type {ContestEntryRule}
     * @memberof ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGet
     */
    'entry_rule'?: ContestEntryRule;
    /**
     * 
     * @type {CurrentAmount}
     * @memberof ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGet
     */
    'current_amount'?: CurrentAmount;
    /**
     * Count of unique participants
     * @type {number}
     * @memberof ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGet
     */
    'current_participants'?: number;
    /**
     * The total amount for this user for this contest
     * @type {number}
     * @memberof ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGet
     */
    'user_amount': number;
    /**
     * 
     * @type {UserAmountToday}
     * @memberof ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGet
     */
    'user_amount_today': UserAmountToday;
    /**
     * Probability of this user winning 1 or more prizes, if the contestended right now
     * @type {number}
     * @memberof ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGet
     */
    'current_win_probability': number;
    /**
     * 
     * @type {number}
     * @memberof ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGet
     */
    'projected_win_probability': number;
    /**
     * Each user \'wins\' (receives prizes) once this target amount is reached.
     * @type {number}
     * @memberof ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGet
     */
    'target_amount': number;
    /**
     * 
     * @type {ContestEntryTrigger}
     * @memberof ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGet
     */
    'entry_trigger'?: ContestEntryTrigger;
    /**
     * 
     * @type {string}
     * @memberof ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGet
     */
    'valid_for'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGet
     */
    'valid_for_event'?: ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGetValidForEventEnum;
    /**
     * The number of times the milestone has been reached.
     * @type {number}
     * @memberof ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGet
     */
    'win_count'?: number;
}

export const ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGetContestTypeEnum = {
    Milestone: 'milestone'
} as const;

export type ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGetContestTypeEnum = typeof ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGetContestTypeEnum[keyof typeof ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGetContestTypeEnum];
export const ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGetEntryTypeEnum = {
    Count: 'count'
} as const;

export type ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGetEntryTypeEnum = typeof ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGetEntryTypeEnum[keyof typeof ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGetEntryTypeEnum];
export const ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGetValidForEventEnum = {
    Signup: 'signup'
} as const;

export type ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGetValidForEventEnum = typeof ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGetValidForEventEnum[keyof typeof ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGetValidForEventEnum];

/**
 * 
 * @export
 * @interface Selector
 */
export interface Selector {
}
/**
 * An adjusted_status is set if a session is adjusted by the marketplace after the original return. A session can be adjusted multiple times. This is the most recent status. If a session was originally a complete, was adjusted to incomplete, then back to complete, the adjusted_status will be None, but the adjusted_timestamp will be set to the most recent change.
 * @export
 * @enum {string}
 */

export const SessionAdjustedStatus = {
    Ac: 'ac',
    Af: 'af',
    Pa: 'pa'
} as const;

export type SessionAdjustedStatus = typeof SessionAdjustedStatus[keyof typeof SessionAdjustedStatus];


/**
 * Stores configuration related to the Session, a session being a users experience attempting to do work.
 * @export
 * @interface SessionConfig
 */
export interface SessionConfig {
    /**
     * The amount of time (in seconds) that a respondent may spend attempting to get into a survey within a session.If NULL, there is no limit.
     * @type {number}
     * @memberof SessionConfig
     */
    'max_session_len'?: number;
    /**
     * The number of surveys that a respondent may attempt within a session before the session is terminated.
     * @type {number}
     * @memberof SessionConfig
     */
    'max_session_hard_retry'?: number;
    /**
     * The minimum amount the user should be paid for a complete. If          no payout transformation is defined, the value is based on the BP\'s payout.          If a payout transformation is defined, the min_payout is applied on the          user\'s payout. Note, this is separate and distinct from the payout          transformation\'s min payout. The payout transformation\'s min_payout does not          care what the task\'s actual payout was. This min_payout will prevent         the user from being show any tasks that would pay below this amount.
     * @type {string}
     * @memberof SessionConfig
     */
    'min_payout'?: string;
}
/**
 * __Status Detail__ This should be set if the Session.status_code_1 is SESSION_XXX_FAIL
 * @export
 * @enum {number}
 */

export const SessionStatusCode2 = {
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4,
    NUMBER_5: 5,
    NUMBER_6: 6,
    NUMBER_7: 7,
    NUMBER_8: 8,
    NUMBER_9: 9,
    NUMBER_10: 10,
    NUMBER_11: 11,
    NUMBER_12: 12,
    NUMBER_13: 13
} as const;

export type SessionStatusCode2 = typeof SessionStatusCode2[keyof typeof SessionStatusCode2];


/**
 * 
 * @export
 * @interface SingleEntryBucket
 */
export interface SingleEntryBucket {
    /**
     * Unique identifier this particular bucket
     * @type {string}
     * @memberof SingleEntryBucket
     */
    'id': string;
    /**
     * The URL to send a respondent into. Must not edit this URL in any way
     * @type {string}
     * @memberof SingleEntryBucket
     */
    'uri': string;
}
/**
 * Only returns a single bucket with the top scoring tasks.  Offerwall code: `5fl8bpv5`
 * @export
 * @interface SingleEntryOfferWall
 */
export interface SingleEntryOfferWall {
    /**
     * Unique identifier to reference a generated offerwall
     * @type {string}
     * @memberof SingleEntryOfferWall
     */
    'id': string;
    /**
     * Total opportunities available for specific bpuid respondent and parameters. This value changes frequently and can be used to determine if a respondent has potential tasks available, regardless of the offerwall type being requested. If the value is 0, no buckets will be generated.
     * @type {number}
     * @memberof SingleEntryOfferWall
     */
    'availability_count': number;
    /**
     * 
     * @type {Array<SingleEntryBucket>}
     * @memberof SingleEntryOfferWall
     */
    'buckets'?: Array<SingleEntryBucket>;
    /**
     *  The format describing the str representation of a payout. Typically, this would be displayed to a user. The payout_format is similar to python format string with a subset of functionality supported. Only float with a precision are supported along with an optional comma for a thousands separator. In addition, a mathematical operator can be applied, such as dividing by 100.  Examples are shown assuming payout = 100 (one dollar). - \"{payout*10:,.0f} Points\" -> \"1,000 Points\" - \"${payout/100:.2f}\" -> \"$1.00\" 
     * @type {string}
     * @memberof SingleEntryOfferWall
     */
    'payout_format': string;
}
/**
 * 
 * @export
 * @interface SingleEntryOfferWallResponse
 */
export interface SingleEntryOfferWallResponse {
    /**
     * 
     * @type {OfferWallInfo}
     * @memberof SingleEntryOfferWallResponse
     */
    'info': OfferWallInfo;
    /**
     * 
     * @type {SingleEntryOfferWall}
     * @memberof SingleEntryOfferWallResponse
     */
    'offerwall': SingleEntryOfferWall;
}
/**
 * 
 * @export
 * @interface SoftPairBucket
 */
export interface SoftPairBucket {
    [key: string]: any;

    /**
     * Unique identifier this particular bucket
     * @type {string}
     * @memberof SoftPairBucket
     */
    'id': string;
    /**
     * 
     * @type {Uri}
     * @memberof SoftPairBucket
     */
    'uri': Uri;
    /**
     * 
     * @type {Array<CategoryAssociation>}
     * @memberof SoftPairBucket
     */
    'category'?: Array<CategoryAssociation>;
    /**
     * 
     * @type {Array<BucketTask>}
     * @memberof SoftPairBucket
     */
    'contents': Array<BucketTask>;
    /**
     * 
     * @type {string}
     * @memberof SoftPairBucket
     */
    'eligibility': SoftPairBucketEligibilityEnum;
    /**
     * 
     * @type {Array<string | null>}
     * @memberof SoftPairBucket
     */
    'missing_questions'?: Array<string | null>;
    /**
     * this is the max loi of the contents
     * @type {number}
     * @memberof SoftPairBucket
     */
    'loi': number;
    /**
     * this is the min payout of the contents
     * @type {number}
     * @memberof SoftPairBucket
     */
    'payout': number;
}

export const SoftPairBucketEligibilityEnum = {
    Conditional: 'conditional',
    Unconditional: 'unconditional',
    Ineligible: 'ineligible'
} as const;

export type SoftPairBucketEligibilityEnum = typeof SoftPairBucketEligibilityEnum[keyof typeof SoftPairBucketEligibilityEnum];

/**
 * This offerwall contains tasks for which the user has a conditional eligibility. The questions that a user must answer to determine the eligibility are included within each bucket. Additionally, the question definitions are included for convenience.  Offerwall code: `37d1da64`
 * @export
 * @interface SoftPairOfferwall
 */
export interface SoftPairOfferwall {
    [key: string]: any;

    /**
     * Unique identifier to reference a generated offerwall
     * @type {string}
     * @memberof SoftPairOfferwall
     */
    'id': string;
    /**
     * Total opportunities available for specific bpuid respondent and parameters. This value changes frequently and can be used to determine if a respondent has potential tasks available, regardless of the offerwall type being requested. If the value is 0, no buckets will be generated.
     * @type {number}
     * @memberof SoftPairOfferwall
     */
    'availability_count': number;
    /**
     * 
     * @type {Array<SoftPairBucket>}
     * @memberof SoftPairOfferwall
     */
    'buckets'?: Array<SoftPairBucket>;
    /**
     * 
     * @type {{ [key: string]: UpkQuestion; }}
     * @memberof SoftPairOfferwall
     */
    'question_info'?: { [key: string]: UpkQuestion; };
}
/**
 * 
 * @export
 * @interface SoftPairOfferwallResponse
 */
export interface SoftPairOfferwallResponse {
    /**
     * 
     * @type {OfferWallInfo}
     * @memberof SoftPairOfferwallResponse
     */
    'info': OfferWallInfo;
    /**
     * 
     * @type {SoftPairOfferwall}
     * @memberof SoftPairOfferwallResponse
     */
    'offerwall': SoftPairOfferwall;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const Source = {
    G: 'g',
    C: 'c',
    A: 'a',
    D: 'd',
    Et: 'et',
    F: 'f',
    I: 'i',
    L: 'l',
    M: 'm',
    N: 'n',
    O: 'o',
    E: 'e',
    R: 'r',
    Pr: 'pr',
    P: 'p',
    Rd: 'rd',
    H: 'h',
    S: 's',
    T: 't',
    U: 'u',
    W: 'w'
} as const;

export type Source = typeof Source[keyof typeof Source];


/**
 * 
 * @export
 * @interface SourceConfig
 */
export interface SourceConfig {
    /**
     * 
     * @type {Source}
     * @memberof SourceConfig
     */
    'name': Source;
    /**
     * 
     * @type {boolean}
     * @memberof SourceConfig
     */
    'active'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof SourceConfig
     */
    'banned_countries'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof SourceConfig
     */
    'allow_mobile_ip'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SourceConfig
     */
    'supplier_id'?: string | null;
    /**
     * Allow Tasks from Buyers that want traffic that comes from Suppliers that can identify their users. Only supported on Pure Spectrum.
     * @type {boolean}
     * @memberof SourceConfig
     */
    'allow_pii_only_buyers'?: boolean;
    /**
     * Return Tasks from Buyers that don\'t have URL hashing enabled. Only supported on Pure Spectrum.
     * @type {boolean}
     * @memberof SourceConfig
     */
    'allow_unhashed_buyers'?: boolean;
    /**
     * For some Products, we may have privacy agreements prohibiting us from sharing information with the inventorySource. If True, don\'t add MRPQ (Market Research ProfilingQuestion) onto the entry link.
     * @type {boolean}
     * @memberof SourceConfig
     */
    'withhold_profiling'?: boolean;
    /**
     * Not used at the moment
     * @type {boolean}
     * @memberof SourceConfig
     */
    'pass_unconditional_eligible_unknowns'?: boolean;
}


/**
 * Describes the marketplaces or sources that a BP can access and their respective configs
 * @export
 * @interface SourcesConfig
 */
export interface SourcesConfig {
    /**
     * 
     * @type {Array<SourceConfig>}
     * @memberof SourcesConfig
     */
    'user_defined'?: Array<SourceConfig>;
}
/**
 * An offerwall with buckets that are clustered by setting as seeds the highest scoring surveys for each bin, then the rest are distributed according to their Euclidean distance using the bucket\'s features.  Offerwall code: `b59a2d2b`
 * @export
 * @interface StarwallOfferWall
 */
export interface StarwallOfferWall {
    /**
     * Unique identifier to reference a generated offerwall
     * @type {string}
     * @memberof StarwallOfferWall
     */
    'id': string;
    /**
     * Total opportunities available for specific bpuid respondent and parameters. This value changes frequently and can be used to determine if a respondent has potential tasks available, regardless of the offerwall type being requested. If the value is 0, no buckets will be generated.
     * @type {number}
     * @memberof StarwallOfferWall
     */
    'availability_count': number;
    /**
     * 
     * @type {Array<TopNBucket>}
     * @memberof StarwallOfferWall
     */
    'buckets'?: Array<TopNBucket>;
    /**
     *  The format describing the str representation of a payout. Typically, this would be displayed to a user. The payout_format is similar to python format string with a subset of functionality supported. Only float with a precision are supported along with an optional comma for a thousands separator. In addition, a mathematical operator can be applied, such as dividing by 100.  Examples are shown assuming payout = 100 (one dollar). - \"{payout*10:,.0f} Points\" -> \"1,000 Points\" - \"${payout/100:.2f}\" -> \"$1.00\" 
     * @type {string}
     * @memberof StarwallOfferWall
     */
    'payout_format': string;
}
/**
 * 
 * @export
 * @interface StarwallOfferWallResponse
 */
export interface StarwallOfferWallResponse {
    /**
     * 
     * @type {OfferWallInfo}
     * @memberof StarwallOfferWallResponse
     */
    'info': OfferWallInfo;
    /**
     * 
     * @type {StarwallOfferWall}
     * @memberof StarwallOfferWallResponse
     */
    'offerwall': StarwallOfferWall;
}
/**
 * Same as the StarwallOfferWall, but the buckets include contents and no buckets are returned if the user is blocked.  Offerwall code: `7fa1b3f4`
 * @export
 * @interface StarwallPlusBlockOfferWall
 */
export interface StarwallPlusBlockOfferWall {
    /**
     * Unique identifier to reference a generated offerwall
     * @type {string}
     * @memberof StarwallPlusBlockOfferWall
     */
    'id': string;
    /**
     * Total opportunities available for specific bpuid respondent and parameters. This value changes frequently and can be used to determine if a respondent has potential tasks available, regardless of the offerwall type being requested. If the value is 0, no buckets will be generated.
     * @type {number}
     * @memberof StarwallPlusBlockOfferWall
     */
    'availability_count': number;
    /**
     * 
     * @type {Array<TopNPlusBucket>}
     * @memberof StarwallPlusBlockOfferWall
     */
    'buckets'?: Array<TopNPlusBucket>;
}
/**
 * 
 * @export
 * @interface StarwallPlusBlockOfferWallResponse
 */
export interface StarwallPlusBlockOfferWallResponse {
    /**
     * 
     * @type {OfferWallInfo}
     * @memberof StarwallPlusBlockOfferWallResponse
     */
    'info': OfferWallInfo;
    /**
     * 
     * @type {StarwallPlusBlockOfferWall}
     * @memberof StarwallPlusBlockOfferWallResponse
     */
    'offerwall': StarwallPlusBlockOfferWall;
}
/**
 * Same as the StarwallOfferWall, but the buckets include contents, no buckets are returned if the user is blocked, and each bucket includes a recontact key.  Offerwall code: `630db2a4`
 * @export
 * @interface StarwallPlusBlockRecontactOfferWall
 */
export interface StarwallPlusBlockRecontactOfferWall {
    /**
     * Unique identifier to reference a generated offerwall
     * @type {string}
     * @memberof StarwallPlusBlockRecontactOfferWall
     */
    'id': string;
    /**
     * Total opportunities available for specific bpuid respondent and parameters. This value changes frequently and can be used to determine if a respondent has potential tasks available, regardless of the offerwall type being requested. If the value is 0, no buckets will be generated.
     * @type {number}
     * @memberof StarwallPlusBlockRecontactOfferWall
     */
    'availability_count': number;
    /**
     * 
     * @type {Array<TopNPlusRecontactBucket>}
     * @memberof StarwallPlusBlockRecontactOfferWall
     */
    'buckets'?: Array<TopNPlusRecontactBucket>;
}
/**
 * 
 * @export
 * @interface StarwallPlusBlockRecontactOfferWallResponse
 */
export interface StarwallPlusBlockRecontactOfferWallResponse {
    /**
     * 
     * @type {OfferWallInfo}
     * @memberof StarwallPlusBlockRecontactOfferWallResponse
     */
    'info': OfferWallInfo;
    /**
     * 
     * @type {StarwallPlusBlockRecontactOfferWall}
     * @memberof StarwallPlusBlockRecontactOfferWallResponse
     */
    'offerwall': StarwallPlusBlockRecontactOfferWall;
}
/**
 * Same as the StarwallOfferWall, but the buckets include contents.  Offerwall code: `5481f322`
 * @export
 * @interface StarwallPlusOfferWall
 */
export interface StarwallPlusOfferWall {
    /**
     * Unique identifier to reference a generated offerwall
     * @type {string}
     * @memberof StarwallPlusOfferWall
     */
    'id': string;
    /**
     * Total opportunities available for specific bpuid respondent and parameters. This value changes frequently and can be used to determine if a respondent has potential tasks available, regardless of the offerwall type being requested. If the value is 0, no buckets will be generated.
     * @type {number}
     * @memberof StarwallPlusOfferWall
     */
    'availability_count': number;
    /**
     * 
     * @type {Array<TopNPlusBucket>}
     * @memberof StarwallPlusOfferWall
     */
    'buckets'?: Array<TopNPlusBucket>;
}
/**
 * 
 * @export
 * @interface StarwallPlusOfferWallResponse
 */
export interface StarwallPlusOfferWallResponse {
    /**
     * 
     * @type {OfferWallInfo}
     * @memberof StarwallPlusOfferWallResponse
     */
    'info': OfferWallInfo;
    /**
     * 
     * @type {StarwallPlusOfferWall}
     * @memberof StarwallPlusOfferWallResponse
     */
    'offerwall': StarwallPlusOfferWall;
}
/**
 * 
 * @export
 * @interface StatisticalSummaryStat
 */
export interface StatisticalSummaryStat {
    /**
     * The grouping criteria
     * @type {{ [key: string]: FacetValue; }}
     * @memberof StatisticalSummaryStat
     */
    'facet': { [key: string]: FacetValue; };
    /**
     * Statistical Summary for the given metric and facet
     * @type {StatisticalSummaryValue}
     * @memberof StatisticalSummaryStat
     */
    'value': StatisticalSummaryValue;
}
/**
 * 
 * @export
 * @interface StatisticalSummaryValue
 */
export interface StatisticalSummaryValue {
    /**
     * 
     * @type {number}
     * @memberof StatisticalSummaryValue
     */
    'min': number;
    /**
     * 
     * @type {number}
     * @memberof StatisticalSummaryValue
     */
    'max': number;
    /**
     * 
     * @type {number}
     * @memberof StatisticalSummaryValue
     */
    'mean': number;
    /**
     * 
     * @type {number}
     * @memberof StatisticalSummaryValue
     */
    'q1': number;
    /**
     * equal to the median
     * @type {number}
     * @memberof StatisticalSummaryValue
     */
    'q2': number;
    /**
     * 
     * @type {number}
     * @memberof StatisticalSummaryValue
     */
    'q3': number;
    /**
     * 
     * @type {number}
     * @memberof StatisticalSummaryValue
     */
    'lower_whisker': number;
    /**
     * 
     * @type {number}
     * @memberof StatisticalSummaryValue
     */
    'upper_whisker': number;
}
/**
 * __High level status code for outcome of the session.__ This should only be NULL if the Status is ABANDON or TIMEOUT
 * @export
 * @enum {number}
 */

export const StatusCode1 = {
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4,
    NUMBER_5: 5,
    NUMBER_6: 6,
    NUMBER_7: 7,
    NUMBER_8: 8,
    NUMBER_9: 9,
    NUMBER_10: 10,
    NUMBER_11: 11,
    NUMBER_12: 12,
    NUMBER_13: 13,
    NUMBER_14: 14,
    NUMBER_15: 15,
    NUMBER_16: 16,
    NUMBER_17: 17,
    NUMBER_18: 18,
    NUMBER_19: 19
} as const;

export type StatusCode1 = typeof StatusCode1[keyof typeof StatusCode1];


/**
 * 
 * @export
 * @interface StatusInfoResponseFail
 */
export interface StatusInfoResponseFail {
    /**
     * 
     * @type {StatusSuccessFail}
     * @memberof StatusInfoResponseFail
     */
    'info': StatusSuccessFail;
    /**
     * An optional message, if success is False
     * @type {string}
     * @memberof StatusInfoResponseFail
     */
    'msg': string;
}
/**
 * 
 * @export
 * @interface StatusResponse
 */
export interface StatusResponse {
    /**
     * The status of the API response.
     * @type {string}
     * @memberof StatusResponse
     */
    'status': StatusResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof StatusResponse
     */
    'msg'?: string | null;
}

export const StatusResponseStatusEnum = {
    Success: 'success',
    Error: 'error'
} as const;

export type StatusResponseStatusEnum = typeof StatusResponseStatusEnum[keyof typeof StatusResponseStatusEnum];

/**
 * 
 * @export
 * @interface StatusResponseFailure
 */
export interface StatusResponseFailure {
    /**
     * The status of the API response.
     * @type {string}
     * @memberof StatusResponseFailure
     */
    'status': StatusResponseFailureStatusEnum;
    /**
     * An optional message, if the status is failure.
     * @type {string}
     * @memberof StatusResponseFailure
     */
    'msg': string;
}

export const StatusResponseFailureStatusEnum = {
    Failure: 'failure'
} as const;

export type StatusResponseFailureStatusEnum = typeof StatusResponseFailureStatusEnum[keyof typeof StatusResponseFailureStatusEnum];

/**
 * 
 * @export
 * @interface StatusSuccessFail
 */
export interface StatusSuccessFail {
    /**
     * Whether the API response is successful.
     * @type {boolean}
     * @memberof StatusSuccessFail
     */
    'success'?: boolean;
}
/**
 * Available tags which can be used to annotate supplier traffic  Note: should not include commas!
 * @export
 * @enum {string}
 */

export const SupplierTag = {
    Mobile: 'mobile',
    JsOfferwall: 'js-offerwall',
    DoubleOptIn: 'double-opt-in',
    SingleSignOn: 'single-sign-on',
    PhoneNumberVerified: 'phone-number-verified',
    TestA: 'test-a',
    TestB: 'test-b'
} as const;

export type SupplierTag = typeof SupplierTag[keyof typeof SupplierTag];


/**
 * 
 * @export
 * @interface TangoCashoutMethodData
 */
export interface TangoCashoutMethodData {
    /**
     * 
     * @type {string}
     * @memberof TangoCashoutMethodData
     */
    'type'?: TangoCashoutMethodDataTypeEnum;
    /**
     * tango utid
     * @type {string}
     * @memberof TangoCashoutMethodData
     */
    'utid': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TangoCashoutMethodData
     */
    'countries': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof TangoCashoutMethodData
     */
    'value_type': TangoCashoutMethodDataValueTypeEnum;
}

export const TangoCashoutMethodDataTypeEnum = {
    Tango: 'TANGO'
} as const;

export type TangoCashoutMethodDataTypeEnum = typeof TangoCashoutMethodDataTypeEnum[keyof typeof TangoCashoutMethodDataTypeEnum];
export const TangoCashoutMethodDataValueTypeEnum = {
    Variable: 'variable',
    Fixed: 'fixed'
} as const;

export type TangoCashoutMethodDataValueTypeEnum = typeof TangoCashoutMethodDataValueTypeEnum[keyof typeof TangoCashoutMethodDataValueTypeEnum];

/**
 * Used in the Task Status API call when queried using a TSID (task status ID)  Note: the api response is a little different from the internal representation b/c:  - Include some old stuff: \"currency\": \"USD\", \"final_status\": 0,  - status_code_1 and status_code_2 use the enum NAME, not the value  - The status is the grpc\'s enum value, NOT the pydantic\'s  - payout, user_payout, and user_payout_string are not Nullable  - payout_format is null on list statuses
 * @export
 * @interface TaskStatusResponseOut
 */
export interface TaskStatusResponseOut {
    /**
     * A unique identifier for the session
     * @type {string}
     * @memberof TaskStatusResponseOut
     */
    'tsid': string;
    /**
     * The BP ID of the associated respondent
     * @type {string}
     * @memberof TaskStatusResponseOut
     */
    'product_id': string;
    /**
     * A unique identifier for each user, which is set by the Supplier
     * @type {string}
     * @memberof TaskStatusResponseOut
     */
    'product_user_id': string;
    /**
     * When the session was started
     * @type {string}
     * @memberof TaskStatusResponseOut
     */
    'started': string;
    /**
     * 
     * @type {string}
     * @memberof TaskStatusResponseOut
     */
    'finished'?: string | null;
    /**
     * The outcome of a session.   - 0 - UNKNOWN   - 1 - ENTER (the user has not yet returned)   - 2 - INCOMPLETE (the user failed)   - 3 - COMPLETE (the user completed the task)
     * @type {number}
     * @memberof TaskStatusResponseOut
     */
    'status'?: number;
    /**
     * 
     * @type {number}
     * @memberof TaskStatusResponseOut
     */
    'payout'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof TaskStatusResponseOut
     */
    'user_payout'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof TaskStatusResponseOut
     */
    'payout_format'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TaskStatusResponseOut
     */
    'user_payout_string'?: string | null;
    /**
     * Any extra url params used in the offerwall request will be passed back here
     * @type {{ [key: string]: string; }}
     * @memberof TaskStatusResponseOut
     */
    'kwargs'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof TaskStatusResponseOut
     */
    'status_code_1'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TaskStatusResponseOut
     */
    'status_code_2'?: string | null;
    /**
     * 
     * @type {SessionAdjustedStatus}
     * @memberof TaskStatusResponseOut
     */
    'adjusted_status'?: SessionAdjustedStatus | null;
    /**
     * 
     * @type {string}
     * @memberof TaskStatusResponseOut
     */
    'adjusted_timestamp'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TaskStatusResponseOut
     */
    'adjusted_payout'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof TaskStatusResponseOut
     */
    'adjusted_user_payout'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof TaskStatusResponseOut
     */
    'adjusted_user_payout_string'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof TaskStatusResponseOut
     */
    'currency'?: TaskStatusResponseOutCurrencyEnum;
    /**
     * This is deprecated
     * @type {number}
     * @memberof TaskStatusResponseOut
     */
    'final_status'?: number;
    /**
     * 
     * @type {string}
     * @memberof TaskStatusResponseOut
     */
    'bpuid': string;
}

export const TaskStatusResponseOutCurrencyEnum = {
    Usd: 'USD'
} as const;

export type TaskStatusResponseOutCurrencyEnum = typeof TaskStatusResponseOutCurrencyEnum[keyof typeof TaskStatusResponseOutCurrencyEnum];

/**
 * 
 * @export
 * @interface TasksStatusResponseOut
 */
export interface TasksStatusResponseOut {
    /**
     * 
     * @type {Array<TaskStatusResponseOut>}
     * @memberof TasksStatusResponseOut
     */
    'tasks_status'?: Array<TaskStatusResponseOut>;
}
/**
 * 
 * @export
 * @interface TopNBucket
 */
export interface TopNBucket {
    /**
     * Unique identifier this particular bucket
     * @type {string}
     * @memberof TopNBucket
     */
    'id': string;
    /**
     * The URL to send a respondent into. Must not edit this URL in any way
     * @type {string}
     * @memberof TopNBucket
     */
    'uri': string;
    /**
     * For UI. Provides a dimensionality position for the bucket on the x-axis.
     * @type {number}
     * @memberof TopNBucket
     */
    'x'?: number;
    /**
     * For UI. Provides a dimensionality position for the bucket on the y-axis.
     * @type {number}
     * @memberof TopNBucket
     */
    'y'?: number;
    /**
     * Currently unused. Will always return empty string
     * @type {string}
     * @memberof TopNBucket
     */
    'name'?: string;
    /**
     * Currently unused. Will always return empty string
     * @type {string}
     * @memberof TopNBucket
     */
    'description'?: string;
    /**
     * 
     * @type {Array<CategoryAssociation>}
     * @memberof TopNBucket
     */
    'category'?: Array<CategoryAssociation>;
    /**
     * 
     * @type {DurationSummary}
     * @memberof TopNBucket
     */
    'duration': DurationSummary;
    /**
     * 
     * @type {PayoutSummary}
     * @memberof TopNBucket
     */
    'payout': PayoutSummary;
    /**
     * A proprietary score to determine the overall quality of the tasks that are within the bucket. Higher is better.
     * @type {number}
     * @memberof TopNBucket
     */
    'quality_score': number;
}
/**
 * An offerwall with buckets that are clustered by the `split_by` argument using KMeans clustering.  Offerwall code: `45b7228a7`
 * @export
 * @interface TopNOfferWall
 */
export interface TopNOfferWall {
    /**
     * Unique identifier to reference a generated offerwall
     * @type {string}
     * @memberof TopNOfferWall
     */
    'id': string;
    /**
     * Total opportunities available for specific bpuid respondent and parameters. This value changes frequently and can be used to determine if a respondent has potential tasks available, regardless of the offerwall type being requested. If the value is 0, no buckets will be generated.
     * @type {number}
     * @memberof TopNOfferWall
     */
    'availability_count': number;
    /**
     * 
     * @type {Array<TopNBucket>}
     * @memberof TopNOfferWall
     */
    'buckets'?: Array<TopNBucket>;
    /**
     *  The format describing the str representation of a payout. Typically, this would be displayed to a user. The payout_format is similar to python format string with a subset of functionality supported. Only float with a precision are supported along with an optional comma for a thousands separator. In addition, a mathematical operator can be applied, such as dividing by 100.  Examples are shown assuming payout = 100 (one dollar). - \"{payout*10:,.0f} Points\" -> \"1,000 Points\" - \"${payout/100:.2f}\" -> \"$1.00\" 
     * @type {string}
     * @memberof TopNOfferWall
     */
    'payout_format': string;
}
/**
 * 
 * @export
 * @interface TopNOfferWallResponse
 */
export interface TopNOfferWallResponse {
    /**
     * 
     * @type {OfferWallInfo}
     * @memberof TopNOfferWallResponse
     */
    'info': OfferWallInfo;
    /**
     * 
     * @type {TopNOfferWall}
     * @memberof TopNOfferWallResponse
     */
    'offerwall': TopNOfferWall;
}
/**
 * Same as the TopNOfferWall, but the buckets include contents and no buckets are returned if the user is blocked.  Offerwall code: `d48cce47`
 * @export
 * @interface TopNPlusBlockOfferWall
 */
export interface TopNPlusBlockOfferWall {
    /**
     * Unique identifier to reference a generated offerwall
     * @type {string}
     * @memberof TopNPlusBlockOfferWall
     */
    'id': string;
    /**
     * Total opportunities available for specific bpuid respondent and parameters. This value changes frequently and can be used to determine if a respondent has potential tasks available, regardless of the offerwall type being requested. If the value is 0, no buckets will be generated.
     * @type {number}
     * @memberof TopNPlusBlockOfferWall
     */
    'availability_count': number;
    /**
     * 
     * @type {Array<TopNPlusBucket>}
     * @memberof TopNPlusBlockOfferWall
     */
    'buckets'?: Array<TopNPlusBucket>;
}
/**
 * 
 * @export
 * @interface TopNPlusBlockOfferWallResponse
 */
export interface TopNPlusBlockOfferWallResponse {
    /**
     * 
     * @type {OfferWallInfo}
     * @memberof TopNPlusBlockOfferWallResponse
     */
    'info': OfferWallInfo;
    /**
     * 
     * @type {TopNPlusBlockOfferWall}
     * @memberof TopNPlusBlockOfferWallResponse
     */
    'offerwall': TopNPlusBlockOfferWall;
}
/**
 * Same as the TopNOfferWall, but the buckets include contents, no buckets are returned if the user is blocked, and each bucket includes a `is_recontact` key.  Offerwall code: `1e5f0af8`
 * @export
 * @interface TopNPlusBlockRecontactOfferWall
 */
export interface TopNPlusBlockRecontactOfferWall {
    /**
     * Unique identifier to reference a generated offerwall
     * @type {string}
     * @memberof TopNPlusBlockRecontactOfferWall
     */
    'id': string;
    /**
     * Total opportunities available for specific bpuid respondent and parameters. This value changes frequently and can be used to determine if a respondent has potential tasks available, regardless of the offerwall type being requested. If the value is 0, no buckets will be generated.
     * @type {number}
     * @memberof TopNPlusBlockRecontactOfferWall
     */
    'availability_count': number;
    /**
     * 
     * @type {Array<TopNPlusRecontactBucket>}
     * @memberof TopNPlusBlockRecontactOfferWall
     */
    'buckets'?: Array<TopNPlusRecontactBucket>;
}
/**
 * 
 * @export
 * @interface TopNPlusBlockRecontactOfferWallResponse
 */
export interface TopNPlusBlockRecontactOfferWallResponse {
    /**
     * 
     * @type {OfferWallInfo}
     * @memberof TopNPlusBlockRecontactOfferWallResponse
     */
    'info': OfferWallInfo;
    /**
     * 
     * @type {TopNPlusBlockRecontactOfferWall}
     * @memberof TopNPlusBlockRecontactOfferWallResponse
     */
    'offerwall': TopNPlusBlockRecontactOfferWall;
}
/**
 * 
 * @export
 * @interface TopNPlusBucket
 */
export interface TopNPlusBucket {
    /**
     * Unique identifier this particular bucket
     * @type {string}
     * @memberof TopNPlusBucket
     */
    'id': string;
    /**
     * The URL to send a respondent into. Must not edit this URL in any way
     * @type {string}
     * @memberof TopNPlusBucket
     */
    'uri': string;
    /**
     * For UI. Provides a dimensionality position for the bucket on the x-axis.
     * @type {number}
     * @memberof TopNPlusBucket
     */
    'x'?: number;
    /**
     * For UI. Provides a dimensionality position for the bucket on the y-axis.
     * @type {number}
     * @memberof TopNPlusBucket
     */
    'y'?: number;
    /**
     * Currently unused. Will always return empty string
     * @type {string}
     * @memberof TopNPlusBucket
     */
    'name'?: string;
    /**
     * Currently unused. Will always return empty string
     * @type {string}
     * @memberof TopNPlusBucket
     */
    'description'?: string;
    /**
     * 
     * @type {Array<CategoryAssociation>}
     * @memberof TopNPlusBucket
     */
    'category'?: Array<CategoryAssociation>;
    /**
     * 
     * @type {Array<BucketTask>}
     * @memberof TopNPlusBucket
     */
    'contents': Array<BucketTask>;
    /**
     * 
     * @type {DurationSummary}
     * @memberof TopNPlusBucket
     */
    'duration': DurationSummary;
    /**
     * 
     * @type {PayoutSummary}
     * @memberof TopNPlusBucket
     */
    'payout': PayoutSummary;
    /**
     * 
     * @type {number}
     * @memberof TopNPlusBucket
     */
    'quality_score': number;
    /**
     * This will always be \'USD\'
     * @type {string}
     * @memberof TopNPlusBucket
     */
    'currency'?: string;
}
/**
 * Same as the TopNOfferWall, but the buckets include contents.  Offerwall code: `b145b803`
 * @export
 * @interface TopNPlusOfferWall
 */
export interface TopNPlusOfferWall {
    /**
     * Unique identifier to reference a generated offerwall
     * @type {string}
     * @memberof TopNPlusOfferWall
     */
    'id': string;
    /**
     * Total opportunities available for specific bpuid respondent and parameters. This value changes frequently and can be used to determine if a respondent has potential tasks available, regardless of the offerwall type being requested. If the value is 0, no buckets will be generated.
     * @type {number}
     * @memberof TopNPlusOfferWall
     */
    'availability_count': number;
    /**
     * 
     * @type {Array<TopNPlusBucket>}
     * @memberof TopNPlusOfferWall
     */
    'buckets'?: Array<TopNPlusBucket>;
}
/**
 * 
 * @export
 * @interface TopNPlusOfferWallResponse
 */
export interface TopNPlusOfferWallResponse {
    /**
     * 
     * @type {OfferWallInfo}
     * @memberof TopNPlusOfferWallResponse
     */
    'info': OfferWallInfo;
    /**
     * 
     * @type {TopNPlusOfferWall}
     * @memberof TopNPlusOfferWallResponse
     */
    'offerwall': TopNPlusOfferWall;
}
/**
 * 
 * @export
 * @interface TopNPlusRecontactBucket
 */
export interface TopNPlusRecontactBucket {
    /**
     * Unique identifier this particular bucket
     * @type {string}
     * @memberof TopNPlusRecontactBucket
     */
    'id': string;
    /**
     * The URL to send a respondent into. Must not edit this URL in any way
     * @type {string}
     * @memberof TopNPlusRecontactBucket
     */
    'uri': string;
    /**
     * For UI. Provides a dimensionality position for the bucket on the x-axis.
     * @type {number}
     * @memberof TopNPlusRecontactBucket
     */
    'x'?: number;
    /**
     * For UI. Provides a dimensionality position for the bucket on the y-axis.
     * @type {number}
     * @memberof TopNPlusRecontactBucket
     */
    'y'?: number;
    /**
     * Currently unused. Will always return empty string
     * @type {string}
     * @memberof TopNPlusRecontactBucket
     */
    'name'?: string;
    /**
     * Currently unused. Will always return empty string
     * @type {string}
     * @memberof TopNPlusRecontactBucket
     */
    'description'?: string;
    /**
     * 
     * @type {Array<CategoryAssociation>}
     * @memberof TopNPlusRecontactBucket
     */
    'category'?: Array<CategoryAssociation>;
    /**
     * 
     * @type {Array<BucketTask>}
     * @memberof TopNPlusRecontactBucket
     */
    'contents': Array<BucketTask>;
    /**
     * 
     * @type {DurationSummary}
     * @memberof TopNPlusRecontactBucket
     */
    'duration': DurationSummary;
    /**
     * 
     * @type {PayoutSummary}
     * @memberof TopNPlusRecontactBucket
     */
    'payout': PayoutSummary;
    /**
     * 
     * @type {number}
     * @memberof TopNPlusRecontactBucket
     */
    'quality_score': number;
    /**
     * 
     * @type {boolean}
     * @memberof TopNPlusRecontactBucket
     */
    'is_recontact': boolean;
    /**
     * This will always be \'USD\'
     * @type {string}
     * @memberof TopNPlusRecontactBucket
     */
    'currency'?: string;
}
/**
 * 
 * @export
 * @interface UPKImportance
 */
export interface UPKImportance {
    /**
     * 
     * @type {number}
     * @memberof UPKImportance
     */
    'task_count'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof UPKImportance
     */
    'task_score'?: number | null;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof UPKImportance
     */
    'marketplace_task_count'?: { [key: string]: number; } | null;
}
/**
 * 
 * @export
 * @interface USDeliveryAddress
 */
export interface USDeliveryAddress {
    /**
     * 
     * @type {string}
     * @memberof USDeliveryAddress
     */
    'name_or_attn': string;
    /**
     * 
     * @type {string}
     * @memberof USDeliveryAddress
     */
    'company'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof USDeliveryAddress
     */
    'phone_number'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof USDeliveryAddress
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof USDeliveryAddress
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof USDeliveryAddress
     */
    'state': string;
    /**
     * 
     * @type {string}
     * @memberof USDeliveryAddress
     */
    'postal_code': string;
    /**
     * 
     * @type {string}
     * @memberof USDeliveryAddress
     */
    'country'?: string;
}
/**
 * 
 * @export
 * @interface UpkQuestion
 */
export interface UpkQuestion {
    /**
     * 
     * @type {string}
     * @memberof UpkQuestion
     */
    'question_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpkQuestion
     */
    'ext_question_id'?: string | null;
    /**
     * 
     * @type {UpkQuestionType}
     * @memberof UpkQuestion
     */
    'question_type': UpkQuestionType;
    /**
     * 
     * @type {string}
     * @memberof UpkQuestion
     */
    'country_iso': string;
    /**
     * 
     * @type {string}
     * @memberof UpkQuestion
     */
    'language_iso': string;
    /**
     * The text shown to respondents
     * @type {string}
     * @memberof UpkQuestion
     */
    'question_text': string;
    /**
     * 
     * @type {Array<UpkQuestionChoice>}
     * @memberof UpkQuestion
     */
    'choices'?: Array<UpkQuestionChoice> | null;
    /**
     * 
     * @type {Selector}
     * @memberof UpkQuestion
     */
    'selector'?: Selector;
    /**
     * 
     * @type {UpkQuestionConfiguration}
     * @memberof UpkQuestion
     */
    'configuration'?: UpkQuestionConfiguration | null;
    /**
     * 
     * @type {UpkQuestionValidation}
     * @memberof UpkQuestion
     */
    'validation'?: UpkQuestionValidation | null;
    /**
     * 
     * @type {UPKImportance}
     * @memberof UpkQuestion
     */
    'importance'?: UPKImportance | null;
    /**
     * Categories associated with this question
     * @type {Array<Category>}
     * @memberof UpkQuestion
     */
    'categories'?: Array<Category>;
}


/**
 * 
 * @export
 * @interface UpkQuestionChoice
 */
export interface UpkQuestionChoice {
    /**
     * The unique identifier for a response to a qualification
     * @type {string}
     * @memberof UpkQuestionChoice
     */
    'choice_id': string;
    /**
     * The response text shown to respondents
     * @type {string}
     * @memberof UpkQuestionChoice
     */
    'choice_text': string;
    /**
     * 
     * @type {number}
     * @memberof UpkQuestionChoice
     */
    'order': number;
    /**
     * 
     * @type {number}
     * @memberof UpkQuestionChoice
     */
    'group'?: number | null;
    /**
     * If answer is exclusive, it can be the only option selected
     * @type {boolean}
     * @memberof UpkQuestionChoice
     */
    'exclusive'?: boolean;
    /**
     * 
     * @type {UPKImportance}
     * @memberof UpkQuestionChoice
     */
    'importance'?: UPKImportance | null;
}
/**
 * 
 * @export
 * @interface UpkQuestionChoiceOut
 */
export interface UpkQuestionChoiceOut {
    /**
     * The unique identifier for a response to a qualification
     * @type {string}
     * @memberof UpkQuestionChoiceOut
     */
    'choice_id': string;
    /**
     * The response text shown to respondents
     * @type {string}
     * @memberof UpkQuestionChoiceOut
     */
    'choice_text': string;
    /**
     * 
     * @type {number}
     * @memberof UpkQuestionChoiceOut
     */
    'order': number;
    /**
     * 
     * @type {number}
     * @memberof UpkQuestionChoiceOut
     */
    'group'?: number | null;
    /**
     * If answer is exclusive, it can be the only option selected
     * @type {boolean}
     * @memberof UpkQuestionChoiceOut
     */
    'exclusive'?: boolean;
}
/**
 * @type UpkQuestionConfiguration
 * @export
 */
export type UpkQuestionConfiguration = { type: 'MC' } & UpkQuestionConfigurationMC | { type: 'SLIDER' } & UpkQuestionConfigurationSLIDER | { type: 'TE' } & UpkQuestionConfigurationTE;

/**
 * 
 * @export
 * @interface UpkQuestionConfigurationMC
 */
export interface UpkQuestionConfigurationMC {
    /**
     * 
     * @type {number}
     * @memberof UpkQuestionConfigurationMC
     */
    'max_select'?: number | null;
}
/**
 * 
 * @export
 * @interface UpkQuestionConfigurationSLIDER
 */
export interface UpkQuestionConfigurationSLIDER {
    /**
     * 
     * @type {number}
     * @memberof UpkQuestionConfigurationSLIDER
     */
    'slider_min'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof UpkQuestionConfigurationSLIDER
     */
    'slider_max'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof UpkQuestionConfigurationSLIDER
     */
    'slider_start'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof UpkQuestionConfigurationSLIDER
     */
    'slider_step'?: number | null;
}
/**
 * 
 * @export
 * @interface UpkQuestionConfigurationTE
 */
export interface UpkQuestionConfigurationTE {
    /**
     * 
     * @type {number}
     * @memberof UpkQuestionConfigurationTE
     */
    'max_length'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof UpkQuestionConfigurationTE
     */
    'min_length'?: number | null;
}
/**
 * 
 * @export
 * @interface UpkQuestionOut
 */
export interface UpkQuestionOut {
    /**
     * 
     * @type {string}
     * @memberof UpkQuestionOut
     */
    'question_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpkQuestionOut
     */
    'ext_question_id'?: string | null;
    /**
     * 
     * @type {UpkQuestionType}
     * @memberof UpkQuestionOut
     */
    'question_type': UpkQuestionType;
    /**
     * 
     * @type {string}
     * @memberof UpkQuestionOut
     */
    'country_iso': string;
    /**
     * 
     * @type {string}
     * @memberof UpkQuestionOut
     */
    'language_iso': string;
    /**
     * The text shown to respondents
     * @type {string}
     * @memberof UpkQuestionOut
     */
    'question_text': string;
    /**
     * 
     * @type {Array<UpkQuestionChoiceOut>}
     * @memberof UpkQuestionOut
     */
    'choices'?: Array<UpkQuestionChoiceOut> | null;
    /**
     * 
     * @type {Selector}
     * @memberof UpkQuestionOut
     */
    'selector'?: Selector;
    /**
     * 
     * @type {UpkQuestionConfiguration}
     * @memberof UpkQuestionOut
     */
    'configuration'?: UpkQuestionConfiguration | null;
    /**
     * 
     * @type {UpkQuestionValidation}
     * @memberof UpkQuestionOut
     */
    'validation'?: UpkQuestionValidation | null;
    /**
     * 
     * @type {UPKImportance}
     * @memberof UpkQuestionOut
     */
    'importance'?: UPKImportance | null;
    /**
     * Categories associated with this question
     * @type {Array<Category>}
     * @memberof UpkQuestionOut
     */
    'categories'?: Array<Category>;
    /**
     * 
     * @type {number}
     * @memberof UpkQuestionOut
     */
    'task_count'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof UpkQuestionOut
     */
    'task_score'?: number | null;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof UpkQuestionOut
     */
    'marketplace_task_count'?: { [key: string]: number; } | null;
}


/**
 * 
 * @export
 * @interface UpkQuestionResponse
 */
export interface UpkQuestionResponse {
    /**
     * The status of the API response.
     * @type {string}
     * @memberof UpkQuestionResponse
     */
    'status': UpkQuestionResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof UpkQuestionResponse
     */
    'msg'?: string | null;
    /**
     * 
     * @type {Array<UpkQuestionOut>}
     * @memberof UpkQuestionResponse
     */
    'questions': Array<UpkQuestionOut>;
    /**
     * For internal use
     * @type {Array<object>}
     * @memberof UpkQuestionResponse
     */
    'consent_questions'?: Array<object>;
    /**
     * For internal use
     * @type {Array<object>}
     * @memberof UpkQuestionResponse
     */
    'special_questions'?: Array<object>;
    /**
     * The number of questions returned
     * @type {number}
     * @memberof UpkQuestionResponse
     */
    'count': number;
}

export const UpkQuestionResponseStatusEnum = {
    Success: 'success',
    Error: 'error'
} as const;

export type UpkQuestionResponseStatusEnum = typeof UpkQuestionResponseStatusEnum[keyof typeof UpkQuestionResponseStatusEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const UpkQuestionSelectorHIDDEN = {
    Hidden: 'HIDDEN'
} as const;

export type UpkQuestionSelectorHIDDEN = typeof UpkQuestionSelectorHIDDEN[keyof typeof UpkQuestionSelectorHIDDEN];


/**
 * 
 * @export
 * @enum {string}
 */

export const UpkQuestionSelectorMC = {
    Sa: 'SA',
    Ma: 'MA',
    Dl: 'DL',
    Sb: 'SB',
    Msb: 'MSB'
} as const;

export type UpkQuestionSelectorMC = typeof UpkQuestionSelectorMC[keyof typeof UpkQuestionSelectorMC];


/**
 * 
 * @export
 * @enum {string}
 */

export const UpkQuestionSelectorSLIDER = {
    Hslider: 'HSLIDER',
    Vslider: 'VSLIDER'
} as const;

export type UpkQuestionSelectorSLIDER = typeof UpkQuestionSelectorSLIDER[keyof typeof UpkQuestionSelectorSLIDER];


/**
 * 
 * @export
 * @enum {string}
 */

export const UpkQuestionSelectorTE = {
    Sl: 'SL',
    Ml: 'ML',
    Etb: 'ETB'
} as const;

export type UpkQuestionSelectorTE = typeof UpkQuestionSelectorTE[keyof typeof UpkQuestionSelectorTE];


/**
 * 
 * @export
 * @enum {string}
 */

export const UpkQuestionType = {
    Mc: 'MC',
    Te: 'TE',
    Slider: 'SLIDER',
    Hidden: 'HIDDEN'
} as const;

export type UpkQuestionType = typeof UpkQuestionType[keyof typeof UpkQuestionType];


/**
 * 
 * @export
 * @interface UpkQuestionValidation
 */
export interface UpkQuestionValidation {
    /**
     * 
     * @type {Array<PatternValidation>}
     * @memberof UpkQuestionValidation
     */
    'patterns': Array<PatternValidation> | null;
}
/**
 * The URL to send a respondent into. Must not edit this URL in any way. If the eligibility is conditional or ineligible, the uri will be null.
 * @export
 * @interface Uri
 */
export interface Uri {
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'uuid'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'product_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'product_user_id'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'blocked'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'created'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'last_seen'?: string | null;
}
/**
 * The total amount this user has entered
 * @export
 * @interface UserAmount
 */
export interface UserAmount {
}
/**
 * The total amount this user has entered in the past 24 hours
 * @export
 * @interface UserAmountToday
 */
export interface UserAmountToday {
}
/**
 * Stores configuration for the user creation experience.  The user creation limit is determined dynamically based on the median     daily completion rate. min_hourly_create_limit &     max_hourly_create_limit can be used to constrain the dynamically     determined rate limit within set values.
 * @export
 * @interface UserCreateConfig
 */
export interface UserCreateConfig {
    /**
     * The smallest allowed value for the hourly user create limit.
     * @type {number}
     * @memberof UserCreateConfig
     */
    'min_hourly_create_limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserCreateConfig
     */
    'max_hourly_create_limit'?: number | null;
}
/**
 * 
 * @export
 * @interface UserHealthConfig
 */
export interface UserHealthConfig {
    /**
     * 
     * @type {Array<string>}
     * @memberof UserHealthConfig
     */
    'banned_countries'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof UserHealthConfig
     */
    'allow_ban_iphist'?: boolean;
}
/**
 * 
 * @export
 * @interface UserInfo
 */
export interface UserInfo {
    /**
     * 
     * @type {Array<UserProfileKnowledge>}
     * @memberof UserInfo
     */
    'user_profile_knowledge'?: Array<UserProfileKnowledge>;
    /**
     * 
     * @type {Array<MarketProfileKnowledge>}
     * @memberof UserInfo
     */
    'marketplace_profile_knowledge'?: Array<MarketProfileKnowledge>;
}
/**
 * 
 * @export
 * @interface UserInfoResponse
 */
export interface UserInfoResponse {
    /**
     * The status of the API response.
     * @type {string}
     * @memberof UserInfoResponse
     */
    'status': UserInfoResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof UserInfoResponse
     */
    'msg'?: string | null;
    /**
     * 
     * @type {UserInfo}
     * @memberof UserInfoResponse
     */
    'user-profile': UserInfo;
}

export const UserInfoResponseStatusEnum = {
    Success: 'success',
    Error: 'error'
} as const;

export type UserInfoResponseStatusEnum = typeof UserInfoResponseStatusEnum[keyof typeof UserInfoResponseStatusEnum];

/**
 * 
 * @export
 * @interface UserProfile
 */
export interface UserProfile {
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'email_address'?: string | null;
    /**
     * 
     * @type {User}
     * @memberof UserProfile
     */
    'user': User;
    /**
     * User\'s PID in marketplaces
     * @type {{ [key: string]: string; }}
     * @memberof UserProfile
     */
    'marketplace_pids'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'email_md5': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'email_sha1': string | null;
    /**
     * 
     * @type {string}
     * @memberof UserProfile
     */
    'email_sha256': string | null;
}
/**
 * 
 * @export
 * @interface UserProfileKnowledge
 */
export interface UserProfileKnowledge {
    /**
     * 
     * @type {string}
     * @memberof UserProfileKnowledge
     */
    'property_id': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileKnowledge
     */
    'property_label': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileKnowledge
     */
    'translation': string;
    /**
     * 
     * @type {Array<UserProfileKnowledgeAnswer>}
     * @memberof UserProfileKnowledge
     */
    'answer'?: Array<UserProfileKnowledgeAnswer>;
    /**
     * When the User submitted this Profiling data
     * @type {string}
     * @memberof UserProfileKnowledge
     */
    'created': string;
}
/**
 * 
 * @export
 * @interface UserProfileKnowledgeAnswer
 */
export interface UserProfileKnowledgeAnswer {
    /**
     * 
     * @type {string}
     * @memberof UserProfileKnowledgeAnswer
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserProfileKnowledgeAnswer
     */
    'label'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserProfileKnowledgeAnswer
     */
    'translation'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserProfileKnowledgeAnswer
     */
    'value'?: string | null;
}
/**
 * 
 * @export
 * @interface UserProfileResponse
 */
export interface UserProfileResponse {
    /**
     * The status of the API response.
     * @type {string}
     * @memberof UserProfileResponse
     */
    'status': UserProfileResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof UserProfileResponse
     */
    'msg'?: string | null;
    /**
     * 
     * @type {UserProfile}
     * @memberof UserProfileResponse
     */
    'user-profile': UserProfile;
}

export const UserProfileResponseStatusEnum = {
    Success: 'success',
    Error: 'error'
} as const;

export type UserProfileResponseStatusEnum = typeof UserProfileResponseStatusEnum[keyof typeof UserProfileResponseStatusEnum];

/**
 * 
 * @export
 * @interface UserProfileUpdateRequest
 */
export interface UserProfileUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof UserProfileUpdateRequest
     */
    'email_address': string;
}
/**
 * 
 * @export
 * @interface UserProfilesResponse
 */
export interface UserProfilesResponse {
    /**
     * The status of the API response.
     * @type {string}
     * @memberof UserProfilesResponse
     */
    'status': UserProfilesResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof UserProfilesResponse
     */
    'msg'?: string | null;
    /**
     * 
     * @type {Array<UserProfile>}
     * @memberof UserProfilesResponse
     */
    'user-profiles': Array<UserProfile>;
}

export const UserProfilesResponseStatusEnum = {
    Success: 'success',
    Error: 'error'
} as const;

export type UserProfilesResponseStatusEnum = typeof UserProfilesResponseStatusEnum[keyof typeof UserProfilesResponseStatusEnum];

/**
 * Send the answers to one or more questions for a user. A question is uniquely specified by the question_id key. The answer is: the choice_id if the question_type is \"MC\" the actual entered text if the question_type is \"TE\"  TODO: look up the question_type from the question_id to apply MC or     TE specific validation on the answer(s)
 * @export
 * @interface UserQuestionAnswerIn
 */
export interface UserQuestionAnswerIn {
    /**
     * 
     * @type {string}
     * @memberof UserQuestionAnswerIn
     */
    'question_id': string;
    /**
     * The user\'s answers to this question. Must pass the choice_id if the question is a Multiple Choice, or the actual text if the question is Text Entry
     * @type {Array<string>}
     * @memberof UserQuestionAnswerIn
     */
    'answer': Array<string>;
}
/**
 * 
 * @export
 * @interface UserTransactionHistoryResponse
 */
export interface UserTransactionHistoryResponse {
    /**
     * The status of the API response.
     * @type {string}
     * @memberof UserTransactionHistoryResponse
     */
    'status': UserTransactionHistoryResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof UserTransactionHistoryResponse
     */
    'msg'?: string | null;
    /**
     * 
     * @type {Array<UserTransactionRow>}
     * @memberof UserTransactionHistoryResponse
     */
    'transaction_history'?: Array<UserTransactionRow>;
}

export const UserTransactionHistoryResponseStatusEnum = {
    Success: 'success',
    Error: 'error'
} as const;

export type UserTransactionHistoryResponseStatusEnum = typeof UserTransactionHistoryResponseStatusEnum[keyof typeof UserTransactionHistoryResponseStatusEnum];

/**
 * 
 * @export
 * @interface UserTransactionRow
 */
export interface UserTransactionRow {
    /**
     * (USD cents) Positive is an increase in the user\'s wallet balance. For e.g.requesting a gift card would show as a negative amount.
     * @type {number}
     * @memberof UserTransactionRow
     */
    'amount': number;
    /**
     * The \'amount\' with the payout_format applied. Can be displayed to the user.
     * @type {string}
     * @memberof UserTransactionRow
     */
    'amount_string': string;
    /**
     * The product_user_id
     * @type {string}
     * @memberof UserTransactionRow
     */
    'bpuid': string;
    /**
     * This is the name of the cashout method.
     * @type {string}
     * @memberof UserTransactionRow
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof UserTransactionRow
     */
    'id': string;
    /**
     *  The format describing the str representation of a payout. Typically, this would be displayed to a user. The payout_format is similar to python format string with a subset of functionality supported. Only float with a precision are supported along with an optional comma for a thousands separator. In addition, a mathematical operator can be applied, such as dividing by 100.  Examples are shown assuming payout = 100 (one dollar). - \"{payout*10:,.0f} Points\" -> \"1,000 Points\" - \"${payout/100:.2f}\" -> \"$1.00\" 
     * @type {string}
     * @memberof UserTransactionRow
     */
    'payout_format': string;
    /**
     * 
     * @type {PayoutStatus}
     * @memberof UserTransactionRow
     */
    'status'?: PayoutStatus | null;
    /**
     * 
     * @type {string}
     * @memberof UserTransactionRow
     */
    'timestamp': string;
    /**
     *  - `TASK_COMPLETE` = TASK_COMPLETE  - `RECONCILE` = RECONCILE  - `CASHOUT` = CASHOUT  - `BONUS` = BONUS
     * @type {UserWalletTransactionType}
     * @memberof UserTransactionRow
     */
    'type': UserWalletTransactionType;
}


/**
 * 
 * @export
 * @interface UserWalletBalance
 */
export interface UserWalletBalance {
    /**
     * (USD cents) The amount in the user\'s wallet.
     * @type {number}
     * @memberof UserWalletBalance
     */
    'amount': number;
    /**
     * (USD cents) The amount in the user\'s wallet this is currently redeemable.
     * @type {number}
     * @memberof UserWalletBalance
     */
    'redeemable_amount': number;
    /**
     *  The format describing the str representation of a payout. Typically, this would be displayed to a user. The payout_format is similar to python format string with a subset of functionality supported. Only float with a precision are supported along with an optional comma for a thousands separator. In addition, a mathematical operator can be applied, such as dividing by 100.  Examples are shown assuming payout = 100 (one dollar). - \"{payout*10:,.0f} Points\" -> \"1,000 Points\" - \"${payout/100:.2f}\" -> \"$1.00\" 
     * @type {string}
     * @memberof UserWalletBalance
     */
    'payout_format': string;
    /**
     * The \'amount\' with the payout_format applied. Can be displayed to the user.
     * @type {string}
     * @memberof UserWalletBalance
     */
    'amount_string': string;
    /**
     * The \'redeemable_amount\' with the payout_format applied. Can be displayed to the user.
     * @type {string}
     * @memberof UserWalletBalance
     */
    'redeemable_amount_string': string;
}
/**
 * 
 * @export
 * @interface UserWalletBalanceResponse
 */
export interface UserWalletBalanceResponse {
    /**
     * The status of the API response.
     * @type {string}
     * @memberof UserWalletBalanceResponse
     */
    'status': UserWalletBalanceResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof UserWalletBalanceResponse
     */
    'msg'?: string | null;
    /**
     * 
     * @type {UserWalletBalance}
     * @memberof UserWalletBalanceResponse
     */
    'wallet': UserWalletBalance;
}

export const UserWalletBalanceResponseStatusEnum = {
    Success: 'success',
    Error: 'error'
} as const;

export type UserWalletBalanceResponseStatusEnum = typeof UserWalletBalanceResponseStatusEnum[keyof typeof UserWalletBalanceResponseStatusEnum];

/**
 * Stores configuration for the user wallet handling
 * @export
 * @interface UserWalletConfig
 */
export interface UserWalletConfig {
    /**
     * If enabled, the users\' wallets are managed.
     * @type {boolean}
     * @memberof UserWalletConfig
     */
    'enabled'?: boolean;
    /**
     * Uses Amazon Mechanical Turk
     * @type {boolean}
     * @memberof UserWalletConfig
     */
    'amt'?: boolean;
    /**
     * 
     * @type {Set<PayoutType>}
     * @memberof UserWalletConfig
     */
    'supported_payout_types'?: Set<PayoutType>;
    /**
     * 
     * @type {string}
     * @memberof UserWalletConfig
     */
    'min_cashout'?: string | null;
}
/**
 * The type of transaction
 * @export
 * @enum {string}
 */

export const UserWalletTransactionType = {
    TaskComplete: 'TASK_COMPLETE',
    Reconcile: 'RECONCILE',
    Cashout: 'CASHOUT',
    Bonus: 'BONUS'
} as const;

export type UserWalletTransactionType = typeof UserWalletTransactionType[keyof typeof UserWalletTransactionType];


/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<ValidationErrorLocInner>}
     * @memberof ValidationError
     */
    'loc': Array<ValidationErrorLocInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ValidationErrorLocInner
 */
export interface ValidationErrorLocInner {
}
/**
 * Returns buckets from WXET as single tasks Offerwall code: `55a4e1a9`
 * @export
 * @interface WXETOfferwall
 */
export interface WXETOfferwall {
    /**
     * Unique identifier to reference a generated offerwall
     * @type {string}
     * @memberof WXETOfferwall
     */
    'id': string;
    /**
     * Total opportunities available for specific bpuid respondent and parameters. This value changes frequently and can be used to determine if a respondent has potential tasks available, regardless of the offerwall type being requested. If the value is 0, no buckets will be generated.
     * @type {number}
     * @memberof WXETOfferwall
     */
    'availability_count': number;
    /**
     * 
     * @type {Array<WXETOfferwallBucket>}
     * @memberof WXETOfferwall
     */
    'buckets'?: Array<WXETOfferwallBucket>;
}
/**
 * 
 * @export
 * @interface WXETOfferwallBucket
 */
export interface WXETOfferwallBucket {
    /**
     * Unique identifier this particular bucket
     * @type {string}
     * @memberof WXETOfferwallBucket
     */
    'id': string;
    /**
     * The URL to send a respondent into. Must not edit this URL in any way
     * @type {string}
     * @memberof WXETOfferwallBucket
     */
    'uri': string;
    /**
     * The bucket\'s expected duration, in seconds
     * @type {number}
     * @memberof WXETOfferwallBucket
     */
    'duration': number;
    /**
     * The bucket\'s min payout, in usd cents
     * @type {number}
     * @memberof WXETOfferwallBucket
     */
    'min_payout': number;
}
/**
 * 
 * @export
 * @interface WXETOfferwallResponse
 */
export interface WXETOfferwallResponse {
    /**
     * 
     * @type {OfferWallInfo}
     * @memberof WXETOfferwallResponse
     */
    'info': OfferWallInfo;
    /**
     * 
     * @type {WXETOfferwall}
     * @memberof WXETOfferwallResponse
     */
    'offerwall': WXETOfferwall;
}

/**
 * ContestApi - axios parameter creator
 * @export
 */
export const ContestApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets a Contest. Includes several keys that are specific to the requesting user:      e.g. user_winnings, user_amount.
         * @summary Get Contest User View
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} contestUuid 
         * @param {string} productUserId A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContestUserViewProductIdContestContestUuidUserProductUserIdGet: async (productId: string, contestUuid: string, productUserId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getContestUserViewProductIdContestContestUuidUserProductUserIdGet', 'productId', productId)
            // verify required parameter 'contestUuid' is not null or undefined
            assertParamExists('getContestUserViewProductIdContestContestUuidUserProductUserIdGet', 'contestUuid', contestUuid)
            // verify required parameter 'productUserId' is not null or undefined
            assertParamExists('getContestUserViewProductIdContestContestUuidUserProductUserIdGet', 'productUserId', productUserId)
            const localVarPath = `/{product_id}/contest/{contest_uuid}/user/{product_user_id}/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"contest_uuid"}}`, encodeURIComponent(String(contestUuid)))
                .replace(`{${"product_user_id"}}`, encodeURIComponent(String(productUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get contests the requesting user is eligible for. Contest eligibility may involve the user\'s country, which is determined by the ip address     of THIS request.
         * @summary List Contests User Eligible
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} productUserId A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContestsUserEligibleProductIdContestUserProductUserIdEligibleGet: async (productId: string, productUserId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('listContestsUserEligibleProductIdContestUserProductUserIdEligibleGet', 'productId', productId)
            // verify required parameter 'productUserId' is not null or undefined
            assertParamExists('listContestsUserEligibleProductIdContestUserProductUserIdEligibleGet', 'productUserId', productUserId)
            const localVarPath = `/{product_id}/contest/user/{product_user_id}/eligible/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"product_user_id"}}`, encodeURIComponent(String(productUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get contests the requesting user has entered. This includes contests such as milestone     contests where the user was automatically entered by having a complete for instance.
         * @summary List Contests User Entered
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} productUserId A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContestsUserEnteredProductIdContestUserProductUserIdEnteredGet: async (productId: string, productUserId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('listContestsUserEnteredProductIdContestUserProductUserIdEnteredGet', 'productId', productId)
            // verify required parameter 'productUserId' is not null or undefined
            assertParamExists('listContestsUserEnteredProductIdContestUserProductUserIdEnteredGet', 'productUserId', productUserId)
            const localVarPath = `/{product_id}/contest/user/{product_user_id}/entered/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"product_user_id"}}`, encodeURIComponent(String(productUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get contests the requesting user has won a prize for.
         * @summary List Contests User Winner
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} productUserId A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContestsUserWinnerProductIdContestUserProductUserIdWinnerGet: async (productId: string, productUserId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('listContestsUserWinnerProductIdContestUserProductUserIdWinnerGet', 'productId', productId)
            // verify required parameter 'productUserId' is not null or undefined
            assertParamExists('listContestsUserWinnerProductIdContestUserProductUserIdWinnerGet', 'productUserId', productUserId)
            const localVarPath = `/{product_id}/contest/user/{product_user_id}/winner/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"product_user_id"}}`, encodeURIComponent(String(productUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContestApi - functional programming interface
 * @export
 */
export const ContestApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContestApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets a Contest. Includes several keys that are specific to the requesting user:      e.g. user_winnings, user_amount.
         * @summary Get Contest User View
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} contestUuid 
         * @param {string} productUserId A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContestUserViewProductIdContestContestUuidUserProductUserIdGet(productId: string, contestUuid: string, productUserId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContestUserViewProductIdContestContestUuidUserProductUserIdGet(productId, contestUuid, productUserId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContestApi.getContestUserViewProductIdContestContestUuidUserProductUserIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get contests the requesting user is eligible for. Contest eligibility may involve the user\'s country, which is determined by the ip address     of THIS request.
         * @summary List Contests User Eligible
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} productUserId A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContestsUserEligibleProductIdContestUserProductUserIdEligibleGet(productId: string, productUserId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listContestsUserEligibleProductIdContestUserProductUserIdEligibleGet(productId, productUserId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContestApi.listContestsUserEligibleProductIdContestUserProductUserIdEligibleGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get contests the requesting user has entered. This includes contests such as milestone     contests where the user was automatically entered by having a complete for instance.
         * @summary List Contests User Entered
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} productUserId A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContestsUserEnteredProductIdContestUserProductUserIdEnteredGet(productId: string, productUserId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listContestsUserEnteredProductIdContestUserProductUserIdEnteredGet(productId, productUserId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContestApi.listContestsUserEnteredProductIdContestUserProductUserIdEnteredGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get contests the requesting user has won a prize for.
         * @summary List Contests User Winner
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} productUserId A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContestsUserWinnerProductIdContestUserProductUserIdWinnerGet(productId: string, productUserId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listContestsUserWinnerProductIdContestUserProductUserIdWinnerGet(productId, productUserId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContestApi.listContestsUserWinnerProductIdContestUserProductUserIdWinnerGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContestApi - factory interface
 * @export
 */
export const ContestApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContestApiFp(configuration)
    return {
        /**
         * Gets a Contest. Includes several keys that are specific to the requesting user:      e.g. user_winnings, user_amount.
         * @summary Get Contest User View
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} contestUuid 
         * @param {string} productUserId A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContestUserViewProductIdContestContestUuidUserProductUserIdGet(productId: string, contestUuid: string, productUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGetContestUserViewProductIdContestContestUuidUserProductUserIdGet> {
            return localVarFp.getContestUserViewProductIdContestContestUuidUserProductUserIdGet(productId, contestUuid, productUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get contests the requesting user is eligible for. Contest eligibility may involve the user\'s country, which is determined by the ip address     of THIS request.
         * @summary List Contests User Eligible
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} productUserId A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContestsUserEligibleProductIdContestUserProductUserIdEligibleGet(productId: string, productUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInner>> {
            return localVarFp.listContestsUserEligibleProductIdContestUserProductUserIdEligibleGet(productId, productUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get contests the requesting user has entered. This includes contests such as milestone     contests where the user was automatically entered by having a complete for instance.
         * @summary List Contests User Entered
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} productUserId A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContestsUserEnteredProductIdContestUserProductUserIdEnteredGet(productId: string, productUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInner>> {
            return localVarFp.listContestsUserEnteredProductIdContestUserProductUserIdEnteredGet(productId, productUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get contests the requesting user has won a prize for.
         * @summary List Contests User Winner
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} productUserId A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContestsUserWinnerProductIdContestUserProductUserIdWinnerGet(productId: string, productUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<ListContestsUserEnteredProductIdContestUserProductUserIdEnteredGet200ResponseInner>> {
            return localVarFp.listContestsUserWinnerProductIdContestUserProductUserIdWinnerGet(productId, productUserId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContestApi - object-oriented interface
 * @export
 * @class ContestApi
 * @extends {BaseAPI}
 */
export class ContestApi extends BaseAPI {
    /**
     * Gets a Contest. Includes several keys that are specific to the requesting user:      e.g. user_winnings, user_amount.
     * @summary Get Contest User View
     * @param {string} productId The Brokerage Product ID provided by GRL.
     * @param {string} contestUuid 
     * @param {string} productUserId A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContestApi
     */
    public getContestUserViewProductIdContestContestUuidUserProductUserIdGet(productId: string, contestUuid: string, productUserId: string, options?: RawAxiosRequestConfig) {
        return ContestApiFp(this.configuration).getContestUserViewProductIdContestContestUuidUserProductUserIdGet(productId, contestUuid, productUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get contests the requesting user is eligible for. Contest eligibility may involve the user\'s country, which is determined by the ip address     of THIS request.
     * @summary List Contests User Eligible
     * @param {string} productId The Brokerage Product ID provided by GRL.
     * @param {string} productUserId A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContestApi
     */
    public listContestsUserEligibleProductIdContestUserProductUserIdEligibleGet(productId: string, productUserId: string, options?: RawAxiosRequestConfig) {
        return ContestApiFp(this.configuration).listContestsUserEligibleProductIdContestUserProductUserIdEligibleGet(productId, productUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get contests the requesting user has entered. This includes contests such as milestone     contests where the user was automatically entered by having a complete for instance.
     * @summary List Contests User Entered
     * @param {string} productId The Brokerage Product ID provided by GRL.
     * @param {string} productUserId A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContestApi
     */
    public listContestsUserEnteredProductIdContestUserProductUserIdEnteredGet(productId: string, productUserId: string, options?: RawAxiosRequestConfig) {
        return ContestApiFp(this.configuration).listContestsUserEnteredProductIdContestUserProductUserIdEnteredGet(productId, productUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get contests the requesting user has won a prize for.
     * @summary List Contests User Winner
     * @param {string} productId The Brokerage Product ID provided by GRL.
     * @param {string} productUserId A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContestApi
     */
    public listContestsUserWinnerProductIdContestUserProductUserIdWinnerGet(productId: string, productUserId: string, options?: RawAxiosRequestConfig) {
        return ContestApiFp(this.configuration).listContestsUserWinnerProductIdContestUserProductUserIdWinnerGet(productId, productUserId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DashboardApi - axios parameter creator
 * @export
 */
export const DashboardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Marketplace Inventory
         * @param {MarketplaceInventoryDashboardInventoryGetMarketplaceEnum} marketplace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceInventoryDashboardInventoryGet: async (marketplace: MarketplaceInventoryDashboardInventoryGetMarketplaceEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketplace' is not null or undefined
            assertParamExists('marketplaceInventoryDashboardInventoryGet', 'marketplace', marketplace)
            const localVarPath = `/dashboard/inventory/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (marketplace !== undefined) {
                localVarQueryParameter['marketplace'] = marketplace;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DashboardApi - functional programming interface
 * @export
 */
export const DashboardApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DashboardApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Marketplace Inventory
         * @param {MarketplaceInventoryDashboardInventoryGetMarketplaceEnum} marketplace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async marketplaceInventoryDashboardInventoryGet(marketplace: MarketplaceInventoryDashboardInventoryGetMarketplaceEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MarketplaceSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.marketplaceInventoryDashboardInventoryGet(marketplace, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardApi.marketplaceInventoryDashboardInventoryGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DashboardApi - factory interface
 * @export
 */
export const DashboardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DashboardApiFp(configuration)
    return {
        /**
         * 
         * @summary Marketplace Inventory
         * @param {MarketplaceInventoryDashboardInventoryGetMarketplaceEnum} marketplace 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceInventoryDashboardInventoryGet(marketplace: MarketplaceInventoryDashboardInventoryGetMarketplaceEnum, options?: RawAxiosRequestConfig): AxiosPromise<MarketplaceSummary> {
            return localVarFp.marketplaceInventoryDashboardInventoryGet(marketplace, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DashboardApi - object-oriented interface
 * @export
 * @class DashboardApi
 * @extends {BaseAPI}
 */
export class DashboardApi extends BaseAPI {
    /**
     * 
     * @summary Marketplace Inventory
     * @param {MarketplaceInventoryDashboardInventoryGetMarketplaceEnum} marketplace 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public marketplaceInventoryDashboardInventoryGet(marketplace: MarketplaceInventoryDashboardInventoryGetMarketplaceEnum, options?: RawAxiosRequestConfig) {
        return DashboardApiFp(this.configuration).marketplaceInventoryDashboardInventoryGet(marketplace, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const MarketplaceInventoryDashboardInventoryGetMarketplaceEnum = {
    Wxet: 'WXET'
} as const;
export type MarketplaceInventoryDashboardInventoryGetMarketplaceEnum = typeof MarketplaceInventoryDashboardInventoryGetMarketplaceEnum[keyof typeof MarketplaceInventoryDashboardInventoryGetMarketplaceEnum];


/**
 * LeaderboardApi - axios parameter creator
 * @export
 */
export const LeaderboardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the Winners of leaderboard contests
         * @summary Leaderboard Winners
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {LeaderboardCode} boardCode The type of leaderboard. What the \&quot;values\&quot; represent.  Allowed values:   - __complete_count__ *(COMPLETE_COUNT)*: Number of Completes  - __largest_user_payout__ *(LARGEST_PAYOUT)*: Largest Single Payout  - __sum_user_payout__ *(SUM_PAYOUTS)*: (Sum of) Total Payouts
         * @param {LeaderboardFrequency} freq The time period range for the leaderboard.  Allowed values:   - __daily__ *(DAILY)*: UTC midnight to UTC midnight  - __weekly__ *(WEEKLY)*: Sunday Midnight to Sunday Midnight UTC  - __monthly__ *(MONTHLY)*: Jan 1 00:00:00
         * @param {string} [countryIso] Country ISO Code (ISO 3166-1 alpha-2, lowercase) of the requested leaderboard. If not passed, thecountry is determined from the IP address of the HTTP request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboardWinnersProductIdLeaderboardTimespanBoardCodeWinnersGet: async (productId: string, boardCode: LeaderboardCode, freq: LeaderboardFrequency, countryIso?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('leaderboardWinnersProductIdLeaderboardTimespanBoardCodeWinnersGet', 'productId', productId)
            // verify required parameter 'boardCode' is not null or undefined
            assertParamExists('leaderboardWinnersProductIdLeaderboardTimespanBoardCodeWinnersGet', 'boardCode', boardCode)
            // verify required parameter 'freq' is not null or undefined
            assertParamExists('leaderboardWinnersProductIdLeaderboardTimespanBoardCodeWinnersGet', 'freq', freq)
            const localVarPath = `/{product_id}/leaderboard/timespan/{board_code}/winners/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"board_code"}}`, encodeURIComponent(String(boardCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (freq !== undefined) {
                localVarQueryParameter['freq'] = freq;
            }

            if (countryIso !== undefined) {
                localVarQueryParameter['country_iso'] = countryIso;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Timespan Leaderboard
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {LeaderboardCode} boardCode The type of leaderboard. What the \&quot;values\&quot; represent.  Allowed values:   - __complete_count__ *(COMPLETE_COUNT)*: Number of Completes  - __largest_user_payout__ *(LARGEST_PAYOUT)*: Largest Single Payout  - __sum_user_payout__ *(SUM_PAYOUTS)*: (Sum of) Total Payouts
         * @param {LeaderboardFrequency} freq The time period range for the leaderboard.  Allowed values:   - __daily__ *(DAILY)*: UTC midnight to UTC midnight  - __weekly__ *(WEEKLY)*: Sunday Midnight to Sunday Midnight UTC  - __monthly__ *(MONTHLY)*: Jan 1 00:00:00
         * @param {string} [countryIso] Country ISO Code (ISO 3166-1 alpha-2, lowercase) of the requested leaderboard. If not passed, thecountry is determined from the IP address of the HTTP request.
         * @param {string} [bpuid] Brokerage Product User ID. If passed, this results in the filtering of rows to include this user\&#39;s row, plus rows above and below in rank (up to &#x60;limit&#x60; rows). Otherwise, the top &#x60;limit&#x60; rows are returned.
         * @param {string} [withinTime] Any local timestamp falling within the desired leaderboard\&#39;s period. If not passed, uses the country\&#39;s current time period.
         * @param {number} [limit] Max number of rows to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timespanLeaderboardProductIdLeaderboardTimespanBoardCodeGet: async (productId: string, boardCode: LeaderboardCode, freq: LeaderboardFrequency, countryIso?: string, bpuid?: string, withinTime?: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('timespanLeaderboardProductIdLeaderboardTimespanBoardCodeGet', 'productId', productId)
            // verify required parameter 'boardCode' is not null or undefined
            assertParamExists('timespanLeaderboardProductIdLeaderboardTimespanBoardCodeGet', 'boardCode', boardCode)
            // verify required parameter 'freq' is not null or undefined
            assertParamExists('timespanLeaderboardProductIdLeaderboardTimespanBoardCodeGet', 'freq', freq)
            const localVarPath = `/{product_id}/leaderboard/timespan/{board_code}/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"board_code"}}`, encodeURIComponent(String(boardCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (freq !== undefined) {
                localVarQueryParameter['freq'] = freq;
            }

            if (countryIso !== undefined) {
                localVarQueryParameter['country_iso'] = countryIso;
            }

            if (bpuid !== undefined) {
                localVarQueryParameter['bpuid'] = bpuid;
            }

            if (withinTime !== undefined) {
                localVarQueryParameter['within_time'] = (withinTime as any instanceof Date) ?
                    (withinTime as any).toISOString() :
                    withinTime;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LeaderboardApi - functional programming interface
 * @export
 */
export const LeaderboardApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LeaderboardApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the Winners of leaderboard contests
         * @summary Leaderboard Winners
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {LeaderboardCode} boardCode The type of leaderboard. What the \&quot;values\&quot; represent.  Allowed values:   - __complete_count__ *(COMPLETE_COUNT)*: Number of Completes  - __largest_user_payout__ *(LARGEST_PAYOUT)*: Largest Single Payout  - __sum_user_payout__ *(SUM_PAYOUTS)*: (Sum of) Total Payouts
         * @param {LeaderboardFrequency} freq The time period range for the leaderboard.  Allowed values:   - __daily__ *(DAILY)*: UTC midnight to UTC midnight  - __weekly__ *(WEEKLY)*: Sunday Midnight to Sunday Midnight UTC  - __monthly__ *(MONTHLY)*: Jan 1 00:00:00
         * @param {string} [countryIso] Country ISO Code (ISO 3166-1 alpha-2, lowercase) of the requested leaderboard. If not passed, thecountry is determined from the IP address of the HTTP request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaderboardWinnersProductIdLeaderboardTimespanBoardCodeWinnersGet(productId: string, boardCode: LeaderboardCode, freq: LeaderboardFrequency, countryIso?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LeaderboardWinnerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaderboardWinnersProductIdLeaderboardTimespanBoardCodeWinnersGet(productId, boardCode, freq, countryIso, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LeaderboardApi.leaderboardWinnersProductIdLeaderboardTimespanBoardCodeWinnersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Timespan Leaderboard
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {LeaderboardCode} boardCode The type of leaderboard. What the \&quot;values\&quot; represent.  Allowed values:   - __complete_count__ *(COMPLETE_COUNT)*: Number of Completes  - __largest_user_payout__ *(LARGEST_PAYOUT)*: Largest Single Payout  - __sum_user_payout__ *(SUM_PAYOUTS)*: (Sum of) Total Payouts
         * @param {LeaderboardFrequency} freq The time period range for the leaderboard.  Allowed values:   - __daily__ *(DAILY)*: UTC midnight to UTC midnight  - __weekly__ *(WEEKLY)*: Sunday Midnight to Sunday Midnight UTC  - __monthly__ *(MONTHLY)*: Jan 1 00:00:00
         * @param {string} [countryIso] Country ISO Code (ISO 3166-1 alpha-2, lowercase) of the requested leaderboard. If not passed, thecountry is determined from the IP address of the HTTP request.
         * @param {string} [bpuid] Brokerage Product User ID. If passed, this results in the filtering of rows to include this user\&#39;s row, plus rows above and below in rank (up to &#x60;limit&#x60; rows). Otherwise, the top &#x60;limit&#x60; rows are returned.
         * @param {string} [withinTime] Any local timestamp falling within the desired leaderboard\&#39;s period. If not passed, uses the country\&#39;s current time period.
         * @param {number} [limit] Max number of rows to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async timespanLeaderboardProductIdLeaderboardTimespanBoardCodeGet(productId: string, boardCode: LeaderboardCode, freq: LeaderboardFrequency, countryIso?: string, bpuid?: string, withinTime?: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LeaderboardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.timespanLeaderboardProductIdLeaderboardTimespanBoardCodeGet(productId, boardCode, freq, countryIso, bpuid, withinTime, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LeaderboardApi.timespanLeaderboardProductIdLeaderboardTimespanBoardCodeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LeaderboardApi - factory interface
 * @export
 */
export const LeaderboardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LeaderboardApiFp(configuration)
    return {
        /**
         * Get the Winners of leaderboard contests
         * @summary Leaderboard Winners
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {LeaderboardCode} boardCode The type of leaderboard. What the \&quot;values\&quot; represent.  Allowed values:   - __complete_count__ *(COMPLETE_COUNT)*: Number of Completes  - __largest_user_payout__ *(LARGEST_PAYOUT)*: Largest Single Payout  - __sum_user_payout__ *(SUM_PAYOUTS)*: (Sum of) Total Payouts
         * @param {LeaderboardFrequency} freq The time period range for the leaderboard.  Allowed values:   - __daily__ *(DAILY)*: UTC midnight to UTC midnight  - __weekly__ *(WEEKLY)*: Sunday Midnight to Sunday Midnight UTC  - __monthly__ *(MONTHLY)*: Jan 1 00:00:00
         * @param {string} [countryIso] Country ISO Code (ISO 3166-1 alpha-2, lowercase) of the requested leaderboard. If not passed, thecountry is determined from the IP address of the HTTP request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboardWinnersProductIdLeaderboardTimespanBoardCodeWinnersGet(productId: string, boardCode: LeaderboardCode, freq: LeaderboardFrequency, countryIso?: string, options?: RawAxiosRequestConfig): AxiosPromise<LeaderboardWinnerResponse> {
            return localVarFp.leaderboardWinnersProductIdLeaderboardTimespanBoardCodeWinnersGet(productId, boardCode, freq, countryIso, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Timespan Leaderboard
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {LeaderboardCode} boardCode The type of leaderboard. What the \&quot;values\&quot; represent.  Allowed values:   - __complete_count__ *(COMPLETE_COUNT)*: Number of Completes  - __largest_user_payout__ *(LARGEST_PAYOUT)*: Largest Single Payout  - __sum_user_payout__ *(SUM_PAYOUTS)*: (Sum of) Total Payouts
         * @param {LeaderboardFrequency} freq The time period range for the leaderboard.  Allowed values:   - __daily__ *(DAILY)*: UTC midnight to UTC midnight  - __weekly__ *(WEEKLY)*: Sunday Midnight to Sunday Midnight UTC  - __monthly__ *(MONTHLY)*: Jan 1 00:00:00
         * @param {string} [countryIso] Country ISO Code (ISO 3166-1 alpha-2, lowercase) of the requested leaderboard. If not passed, thecountry is determined from the IP address of the HTTP request.
         * @param {string} [bpuid] Brokerage Product User ID. If passed, this results in the filtering of rows to include this user\&#39;s row, plus rows above and below in rank (up to &#x60;limit&#x60; rows). Otherwise, the top &#x60;limit&#x60; rows are returned.
         * @param {string} [withinTime] Any local timestamp falling within the desired leaderboard\&#39;s period. If not passed, uses the country\&#39;s current time period.
         * @param {number} [limit] Max number of rows to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timespanLeaderboardProductIdLeaderboardTimespanBoardCodeGet(productId: string, boardCode: LeaderboardCode, freq: LeaderboardFrequency, countryIso?: string, bpuid?: string, withinTime?: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<LeaderboardResponse> {
            return localVarFp.timespanLeaderboardProductIdLeaderboardTimespanBoardCodeGet(productId, boardCode, freq, countryIso, bpuid, withinTime, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LeaderboardApi - object-oriented interface
 * @export
 * @class LeaderboardApi
 * @extends {BaseAPI}
 */
export class LeaderboardApi extends BaseAPI {
    /**
     * Get the Winners of leaderboard contests
     * @summary Leaderboard Winners
     * @param {string} productId The Brokerage Product ID provided by GRL.
     * @param {LeaderboardCode} boardCode The type of leaderboard. What the \&quot;values\&quot; represent.  Allowed values:   - __complete_count__ *(COMPLETE_COUNT)*: Number of Completes  - __largest_user_payout__ *(LARGEST_PAYOUT)*: Largest Single Payout  - __sum_user_payout__ *(SUM_PAYOUTS)*: (Sum of) Total Payouts
     * @param {LeaderboardFrequency} freq The time period range for the leaderboard.  Allowed values:   - __daily__ *(DAILY)*: UTC midnight to UTC midnight  - __weekly__ *(WEEKLY)*: Sunday Midnight to Sunday Midnight UTC  - __monthly__ *(MONTHLY)*: Jan 1 00:00:00
     * @param {string} [countryIso] Country ISO Code (ISO 3166-1 alpha-2, lowercase) of the requested leaderboard. If not passed, thecountry is determined from the IP address of the HTTP request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaderboardApi
     */
    public leaderboardWinnersProductIdLeaderboardTimespanBoardCodeWinnersGet(productId: string, boardCode: LeaderboardCode, freq: LeaderboardFrequency, countryIso?: string, options?: RawAxiosRequestConfig) {
        return LeaderboardApiFp(this.configuration).leaderboardWinnersProductIdLeaderboardTimespanBoardCodeWinnersGet(productId, boardCode, freq, countryIso, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Timespan Leaderboard
     * @param {string} productId The Brokerage Product ID provided by GRL.
     * @param {LeaderboardCode} boardCode The type of leaderboard. What the \&quot;values\&quot; represent.  Allowed values:   - __complete_count__ *(COMPLETE_COUNT)*: Number of Completes  - __largest_user_payout__ *(LARGEST_PAYOUT)*: Largest Single Payout  - __sum_user_payout__ *(SUM_PAYOUTS)*: (Sum of) Total Payouts
     * @param {LeaderboardFrequency} freq The time period range for the leaderboard.  Allowed values:   - __daily__ *(DAILY)*: UTC midnight to UTC midnight  - __weekly__ *(WEEKLY)*: Sunday Midnight to Sunday Midnight UTC  - __monthly__ *(MONTHLY)*: Jan 1 00:00:00
     * @param {string} [countryIso] Country ISO Code (ISO 3166-1 alpha-2, lowercase) of the requested leaderboard. If not passed, thecountry is determined from the IP address of the HTTP request.
     * @param {string} [bpuid] Brokerage Product User ID. If passed, this results in the filtering of rows to include this user\&#39;s row, plus rows above and below in rank (up to &#x60;limit&#x60; rows). Otherwise, the top &#x60;limit&#x60; rows are returned.
     * @param {string} [withinTime] Any local timestamp falling within the desired leaderboard\&#39;s period. If not passed, uses the country\&#39;s current time period.
     * @param {number} [limit] Max number of rows to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaderboardApi
     */
    public timespanLeaderboardProductIdLeaderboardTimespanBoardCodeGet(productId: string, boardCode: LeaderboardCode, freq: LeaderboardFrequency, countryIso?: string, bpuid?: string, withinTime?: string, limit?: number, options?: RawAxiosRequestConfig) {
        return LeaderboardApiFp(this.configuration).timespanLeaderboardProductIdLeaderboardTimespanBoardCodeGet(productId, boardCode, freq, countryIso, bpuid, withinTime, limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OfferwallApi - axios parameter creator
 * @export
 */
export const OfferwallApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns buckets grouped by marketplace, one per marketplace, with the tasks ordered by quality.
         * @summary Marketplace Offerwall
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
         * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
         * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
         * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
         * @param {number} [duration] Maximum length of desired task (in seconds).
         * @param {number} [minBinSize] Minimum number of tasks that need to be in a bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceOfferwallProductIdOfferwall5fa23085Get: async (productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, minBinSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('marketplaceOfferwallProductIdOfferwall5fa23085Get', 'productId', productId)
            // verify required parameter 'bpuid' is not null or undefined
            assertParamExists('marketplaceOfferwallProductIdOfferwall5fa23085Get', 'bpuid', bpuid)
            const localVarPath = `/{product_id}/offerwall/5fa23085/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (bpuid !== undefined) {
                localVarQueryParameter['bpuid'] = bpuid;
            }

            if (ip !== undefined) {
                localVarQueryParameter['ip'] = ip;
            }

            if (countryIso !== undefined) {
                localVarQueryParameter['country_iso'] = countryIso;
            }

            if (languages) {
                localVarQueryParameter['languages'] = languages;
            }

            if (behavior !== undefined) {
                localVarQueryParameter['behavior'] = behavior;
            }

            if (minPayout !== undefined) {
                localVarQueryParameter['min_payout'] = minPayout;
            }

            if (duration !== undefined) {
                localVarQueryParameter['duration'] = duration;
            }

            if (minBinSize !== undefined) {
                localVarQueryParameter['min_bin_size'] = minBinSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is a custom endpoint for a softpair-style offerwall that allows you to update profiling answers and then immediately get back the updated offerwall
         * @summary Offerwall Softpair Block Post
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} offerwallId The offerwall ID the user is interacting with
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {BodyOfferwallSoftpairBlockPostProductIdOfferwall7a89dcdbOfferwallIdPost} bodyOfferwallSoftpairBlockPostProductIdOfferwall7a89dcdbOfferwallIdPost 
         * @param {string | null} [sessionId] A session id (uuid4.hex)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        offerwallSoftpairBlockPostProductIdOfferwall7a89dcdbOfferwallIdPost: async (productId: string, offerwallId: string, bpuid: string, bodyOfferwallSoftpairBlockPostProductIdOfferwall7a89dcdbOfferwallIdPost: BodyOfferwallSoftpairBlockPostProductIdOfferwall7a89dcdbOfferwallIdPost, sessionId?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('offerwallSoftpairBlockPostProductIdOfferwall7a89dcdbOfferwallIdPost', 'productId', productId)
            // verify required parameter 'offerwallId' is not null or undefined
            assertParamExists('offerwallSoftpairBlockPostProductIdOfferwall7a89dcdbOfferwallIdPost', 'offerwallId', offerwallId)
            // verify required parameter 'bpuid' is not null or undefined
            assertParamExists('offerwallSoftpairBlockPostProductIdOfferwall7a89dcdbOfferwallIdPost', 'bpuid', bpuid)
            // verify required parameter 'bodyOfferwallSoftpairBlockPostProductIdOfferwall7a89dcdbOfferwallIdPost' is not null or undefined
            assertParamExists('offerwallSoftpairBlockPostProductIdOfferwall7a89dcdbOfferwallIdPost', 'bodyOfferwallSoftpairBlockPostProductIdOfferwall7a89dcdbOfferwallIdPost', bodyOfferwallSoftpairBlockPostProductIdOfferwall7a89dcdbOfferwallIdPost)
            const localVarPath = `/{product_id}/offerwall/7a89dcdb/{offerwall_id}/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"offerwall_id"}}`, encodeURIComponent(String(offerwallId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (bpuid !== undefined) {
                localVarQueryParameter['bpuid'] = bpuid;
            }

            if (sessionId !== undefined) {
                localVarQueryParameter['session_id'] = sessionId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bodyOfferwallSoftpairBlockPostProductIdOfferwall7a89dcdbOfferwallIdPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This offerwall contains tasks for which the user has a conditional eligibility. The questions that a user must answer to determine the eligibility are included within each bucket. Additionally, the question definitions are included for convenience. No buckets are returned if the user is blocked.
         * @summary Offerwall Softpair Block
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
         * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
         * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
         * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
         * @param {number} [duration] Maximum length of desired task (in seconds).
         * @param {number} [nBins] Number of bins requested in the offerwall. If n_bins&#x3D;1 there is no grouping and you get all      duration + payout metrics on across all (as shown by the  availability_count).     n_bins&#x3D;0 will return back an empty bucket array, however, the availability_count will still show      the total opportunities available for that bpuid + passed in parameter settings.     n_bins&#x3D;âˆž (or any positive integer) will return back the total number of bins capable of being uniquely split.
         * @param {number} [minBinSize] Minimum number of tasks that need to be in a bucket
         * @param {number} [maxOptions] Max number of options an allowed question can have (allowed to be asked)
         * @param {number} [maxQuestions] Max number of missing questions on a single bin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        offerwallSoftpairBlockProductIdOfferwall7a89dcdbGet: async (productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, nBins?: number, minBinSize?: number, maxOptions?: number, maxQuestions?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('offerwallSoftpairBlockProductIdOfferwall7a89dcdbGet', 'productId', productId)
            // verify required parameter 'bpuid' is not null or undefined
            assertParamExists('offerwallSoftpairBlockProductIdOfferwall7a89dcdbGet', 'bpuid', bpuid)
            const localVarPath = `/{product_id}/offerwall/7a89dcdb/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (bpuid !== undefined) {
                localVarQueryParameter['bpuid'] = bpuid;
            }

            if (ip !== undefined) {
                localVarQueryParameter['ip'] = ip;
            }

            if (countryIso !== undefined) {
                localVarQueryParameter['country_iso'] = countryIso;
            }

            if (languages) {
                localVarQueryParameter['languages'] = languages;
            }

            if (behavior !== undefined) {
                localVarQueryParameter['behavior'] = behavior;
            }

            if (minPayout !== undefined) {
                localVarQueryParameter['min_payout'] = minPayout;
            }

            if (duration !== undefined) {
                localVarQueryParameter['duration'] = duration;
            }

            if (nBins !== undefined) {
                localVarQueryParameter['n_bins'] = nBins;
            }

            if (minBinSize !== undefined) {
                localVarQueryParameter['min_bin_size'] = minBinSize;
            }

            if (maxOptions !== undefined) {
                localVarQueryParameter['max_options'] = maxOptions;
            }

            if (maxQuestions !== undefined) {
                localVarQueryParameter['max_questions'] = maxQuestions;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is a custom endpoint for a softpair-style offerwall that allows you to update profiling answers and then immediately get back the updated offerwall
         * @summary Offerwall Softpair Post
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} offerwallId The offerwall ID the user is interacting with
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {BodyOfferwallSoftpairPostProductIdOfferwall37d1da64OfferwallIdPost} bodyOfferwallSoftpairPostProductIdOfferwall37d1da64OfferwallIdPost 
         * @param {string | null} [sessionId] A session id (uuid4.hex)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        offerwallSoftpairPostProductIdOfferwall37d1da64OfferwallIdPost: async (productId: string, offerwallId: string, bpuid: string, bodyOfferwallSoftpairPostProductIdOfferwall37d1da64OfferwallIdPost: BodyOfferwallSoftpairPostProductIdOfferwall37d1da64OfferwallIdPost, sessionId?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('offerwallSoftpairPostProductIdOfferwall37d1da64OfferwallIdPost', 'productId', productId)
            // verify required parameter 'offerwallId' is not null or undefined
            assertParamExists('offerwallSoftpairPostProductIdOfferwall37d1da64OfferwallIdPost', 'offerwallId', offerwallId)
            // verify required parameter 'bpuid' is not null or undefined
            assertParamExists('offerwallSoftpairPostProductIdOfferwall37d1da64OfferwallIdPost', 'bpuid', bpuid)
            // verify required parameter 'bodyOfferwallSoftpairPostProductIdOfferwall37d1da64OfferwallIdPost' is not null or undefined
            assertParamExists('offerwallSoftpairPostProductIdOfferwall37d1da64OfferwallIdPost', 'bodyOfferwallSoftpairPostProductIdOfferwall37d1da64OfferwallIdPost', bodyOfferwallSoftpairPostProductIdOfferwall37d1da64OfferwallIdPost)
            const localVarPath = `/{product_id}/offerwall/37d1da64/{offerwall_id}/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"offerwall_id"}}`, encodeURIComponent(String(offerwallId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (bpuid !== undefined) {
                localVarQueryParameter['bpuid'] = bpuid;
            }

            if (sessionId !== undefined) {
                localVarQueryParameter['session_id'] = sessionId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bodyOfferwallSoftpairPostProductIdOfferwall37d1da64OfferwallIdPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This offerwall contains tasks for which the user has a conditional eligibility. The questions that a user must answer to determine the eligibility are included within each bucket. Additionally, the question definitions are included for convenience.
         * @summary Offerwall Softpair
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
         * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
         * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
         * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
         * @param {number} [duration] Maximum length of desired task (in seconds).
         * @param {number} [nBins] Number of bins requested in the offerwall. If n_bins&#x3D;1 there is no grouping and you get all      duration + payout metrics on across all (as shown by the  availability_count).     n_bins&#x3D;0 will return back an empty bucket array, however, the availability_count will still show      the total opportunities available for that bpuid + passed in parameter settings.     n_bins&#x3D;âˆž (or any positive integer) will return back the total number of bins capable of being uniquely split.
         * @param {number} [minBinSize] Minimum number of tasks that need to be in a bucket
         * @param {number} [maxOptions] Max number of options an allowed question can have (allowed to be asked)
         * @param {number} [maxQuestions] Max number of missing questions on a single bin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        offerwallSoftpairProductIdOfferwall37d1da64Get: async (productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, nBins?: number, minBinSize?: number, maxOptions?: number, maxQuestions?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('offerwallSoftpairProductIdOfferwall37d1da64Get', 'productId', productId)
            // verify required parameter 'bpuid' is not null or undefined
            assertParamExists('offerwallSoftpairProductIdOfferwall37d1da64Get', 'bpuid', bpuid)
            const localVarPath = `/{product_id}/offerwall/37d1da64/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (bpuid !== undefined) {
                localVarQueryParameter['bpuid'] = bpuid;
            }

            if (ip !== undefined) {
                localVarQueryParameter['ip'] = ip;
            }

            if (countryIso !== undefined) {
                localVarQueryParameter['country_iso'] = countryIso;
            }

            if (languages) {
                localVarQueryParameter['languages'] = languages;
            }

            if (behavior !== undefined) {
                localVarQueryParameter['behavior'] = behavior;
            }

            if (minPayout !== undefined) {
                localVarQueryParameter['min_payout'] = minPayout;
            }

            if (duration !== undefined) {
                localVarQueryParameter['duration'] = duration;
            }

            if (nBins !== undefined) {
                localVarQueryParameter['n_bins'] = nBins;
            }

            if (minBinSize !== undefined) {
                localVarQueryParameter['min_bin_size'] = minBinSize;
            }

            if (maxOptions !== undefined) {
                localVarQueryParameter['max_options'] = maxOptions;
            }

            if (maxQuestions !== undefined) {
                localVarQueryParameter['max_questions'] = maxQuestions;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Each bucket has only 1 single task, and only basic info is returned     about each bucket.
         * @summary One Shot Offerwall
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
         * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
         * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
         * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
         * @param {number} [duration] Maximum length of desired task (in seconds).
         * @param {number} [nBins] Number of bins requested in the offerwall. If n_bins&#x3D;1 there is no grouping and you get all      duration + payout metrics on across all (as shown by the  availability_count).     n_bins&#x3D;0 will return back an empty bucket array, however, the availability_count will still show      the total opportunities available for that bpuid + passed in parameter settings.     n_bins&#x3D;âˆž (or any positive integer) will return back the total number of bins capable of being uniquely split.
         * @param {Set<Source>} [sources] Restrict tasks to those from these marketplaces only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oneShotOfferwallProductIdOfferwall6f27b1aeGet: async (productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, nBins?: number, sources?: Set<Source>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('oneShotOfferwallProductIdOfferwall6f27b1aeGet', 'productId', productId)
            // verify required parameter 'bpuid' is not null or undefined
            assertParamExists('oneShotOfferwallProductIdOfferwall6f27b1aeGet', 'bpuid', bpuid)
            const localVarPath = `/{product_id}/offerwall/6f27b1ae/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (bpuid !== undefined) {
                localVarQueryParameter['bpuid'] = bpuid;
            }

            if (ip !== undefined) {
                localVarQueryParameter['ip'] = ip;
            }

            if (countryIso !== undefined) {
                localVarQueryParameter['country_iso'] = countryIso;
            }

            if (languages) {
                localVarQueryParameter['languages'] = languages;
            }

            if (behavior !== undefined) {
                localVarQueryParameter['behavior'] = behavior;
            }

            if (minPayout !== undefined) {
                localVarQueryParameter['min_payout'] = minPayout;
            }

            if (duration !== undefined) {
                localVarQueryParameter['duration'] = duration;
            }

            if (nBins !== undefined) {
                localVarQueryParameter['n_bins'] = nBins;
            }

            if (sources) {
                localVarQueryParameter['sources'] = Array.from(sources);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Only returns a single bucket with the top scoring tasks.
         * @summary Single Offerwall
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
         * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
         * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
         * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
         * @param {number} [duration] Maximum length of desired task (in seconds).
         * @param {number} [minBinSize] Minimum number of tasks that need to be in a bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        singleOfferwallProductIdOfferwall5fl8bpv5Get: async (productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, minBinSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('singleOfferwallProductIdOfferwall5fl8bpv5Get', 'productId', productId)
            // verify required parameter 'bpuid' is not null or undefined
            assertParamExists('singleOfferwallProductIdOfferwall5fl8bpv5Get', 'bpuid', bpuid)
            const localVarPath = `/{product_id}/offerwall/5fl8bpv5/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (bpuid !== undefined) {
                localVarQueryParameter['bpuid'] = bpuid;
            }

            if (ip !== undefined) {
                localVarQueryParameter['ip'] = ip;
            }

            if (countryIso !== undefined) {
                localVarQueryParameter['country_iso'] = countryIso;
            }

            if (languages) {
                localVarQueryParameter['languages'] = languages;
            }

            if (behavior !== undefined) {
                localVarQueryParameter['behavior'] = behavior;
            }

            if (minPayout !== undefined) {
                localVarQueryParameter['min_payout'] = minPayout;
            }

            if (duration !== undefined) {
                localVarQueryParameter['duration'] = duration;
            }

            if (minBinSize !== undefined) {
                localVarQueryParameter['min_bin_size'] = minBinSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an offerwall with buckets that are clustered by setting as seeds the highest scoring surveys for each bin, then the rest are distributed according to their Euclidean distance using the bucket\'s features.
         * @summary Starwall Offerwall
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
         * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
         * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
         * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
         * @param {number} [duration] Maximum length of desired task (in seconds).
         * @param {number} [nBins] Number of bins requested in the offerwall. If n_bins&#x3D;1 there is no grouping and you get all      duration + payout metrics on across all (as shown by the  availability_count).     n_bins&#x3D;0 will return back an empty bucket array, however, the availability_count will still show      the total opportunities available for that bpuid + passed in parameter settings.     n_bins&#x3D;âˆž (or any positive integer) will return back the total number of bins capable of being uniquely split.
         * @param {number} [minBinSize] Minimum number of tasks that need to be in a bucket
         * @param {StarwallOfferwallProductIdOfferwallB59a2d2bGetSplitByEnum} [splitBy] Cluster tasks by payout or duration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        starwallOfferwallProductIdOfferwallB59a2d2bGet: async (productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, nBins?: number, minBinSize?: number, splitBy?: StarwallOfferwallProductIdOfferwallB59a2d2bGetSplitByEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('starwallOfferwallProductIdOfferwallB59a2d2bGet', 'productId', productId)
            // verify required parameter 'bpuid' is not null or undefined
            assertParamExists('starwallOfferwallProductIdOfferwallB59a2d2bGet', 'bpuid', bpuid)
            const localVarPath = `/{product_id}/offerwall/b59a2d2b/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (bpuid !== undefined) {
                localVarQueryParameter['bpuid'] = bpuid;
            }

            if (ip !== undefined) {
                localVarQueryParameter['ip'] = ip;
            }

            if (countryIso !== undefined) {
                localVarQueryParameter['country_iso'] = countryIso;
            }

            if (languages) {
                localVarQueryParameter['languages'] = languages;
            }

            if (behavior !== undefined) {
                localVarQueryParameter['behavior'] = behavior;
            }

            if (minPayout !== undefined) {
                localVarQueryParameter['min_payout'] = minPayout;
            }

            if (duration !== undefined) {
                localVarQueryParameter['duration'] = duration;
            }

            if (nBins !== undefined) {
                localVarQueryParameter['n_bins'] = nBins;
            }

            if (minBinSize !== undefined) {
                localVarQueryParameter['min_bin_size'] = minBinSize;
            }

            if (splitBy !== undefined) {
                localVarQueryParameter['split_by'] = splitBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Same as the StarwallOfferWall, but the buckets include contents and no buckets are returned if the user is blocked.
         * @summary Starwall Plus Block Offerwall
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
         * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
         * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
         * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
         * @param {number} [duration] Maximum length of desired task (in seconds).
         * @param {number} [nBins] Number of bins requested in the offerwall. If n_bins&#x3D;1 there is no grouping and you get all      duration + payout metrics on across all (as shown by the  availability_count).     n_bins&#x3D;0 will return back an empty bucket array, however, the availability_count will still show      the total opportunities available for that bpuid + passed in parameter settings.     n_bins&#x3D;âˆž (or any positive integer) will return back the total number of bins capable of being uniquely split.
         * @param {number} [minBinSize] Minimum number of tasks that need to be in a bucket
         * @param {StarwallPlusBlockOfferwallProductIdOfferwall7fa1b3f4GetSplitByEnum} [splitBy] Cluster tasks by payout or duration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        starwallPlusBlockOfferwallProductIdOfferwall7fa1b3f4Get: async (productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, nBins?: number, minBinSize?: number, splitBy?: StarwallPlusBlockOfferwallProductIdOfferwall7fa1b3f4GetSplitByEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('starwallPlusBlockOfferwallProductIdOfferwall7fa1b3f4Get', 'productId', productId)
            // verify required parameter 'bpuid' is not null or undefined
            assertParamExists('starwallPlusBlockOfferwallProductIdOfferwall7fa1b3f4Get', 'bpuid', bpuid)
            const localVarPath = `/{product_id}/offerwall/7fa1b3f4/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (bpuid !== undefined) {
                localVarQueryParameter['bpuid'] = bpuid;
            }

            if (ip !== undefined) {
                localVarQueryParameter['ip'] = ip;
            }

            if (countryIso !== undefined) {
                localVarQueryParameter['country_iso'] = countryIso;
            }

            if (languages) {
                localVarQueryParameter['languages'] = languages;
            }

            if (behavior !== undefined) {
                localVarQueryParameter['behavior'] = behavior;
            }

            if (minPayout !== undefined) {
                localVarQueryParameter['min_payout'] = minPayout;
            }

            if (duration !== undefined) {
                localVarQueryParameter['duration'] = duration;
            }

            if (nBins !== undefined) {
                localVarQueryParameter['n_bins'] = nBins;
            }

            if (minBinSize !== undefined) {
                localVarQueryParameter['min_bin_size'] = minBinSize;
            }

            if (splitBy !== undefined) {
                localVarQueryParameter['split_by'] = splitBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Same as the StarwallOfferWall, but the buckets include contents, no buckets are returned if the user is blocked, and each bucket includes a `is_recontact` key.
         * @summary Starwall Plus Block Recontact Offerwall
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
         * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
         * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
         * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
         * @param {number} [duration] Maximum length of desired task (in seconds).
         * @param {number} [nBins] Number of bins requested in the offerwall. If n_bins&#x3D;1 there is no grouping and you get all      duration + payout metrics on across all (as shown by the  availability_count).     n_bins&#x3D;0 will return back an empty bucket array, however, the availability_count will still show      the total opportunities available for that bpuid + passed in parameter settings.     n_bins&#x3D;âˆž (or any positive integer) will return back the total number of bins capable of being uniquely split.
         * @param {number} [minBinSize] Minimum number of tasks that need to be in a bucket
         * @param {StarwallPlusBlockRecontactOfferwallProductIdOfferwall630db2a4GetSplitByEnum} [splitBy] Cluster tasks by payout or duration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        starwallPlusBlockRecontactOfferwallProductIdOfferwall630db2a4Get: async (productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, nBins?: number, minBinSize?: number, splitBy?: StarwallPlusBlockRecontactOfferwallProductIdOfferwall630db2a4GetSplitByEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('starwallPlusBlockRecontactOfferwallProductIdOfferwall630db2a4Get', 'productId', productId)
            // verify required parameter 'bpuid' is not null or undefined
            assertParamExists('starwallPlusBlockRecontactOfferwallProductIdOfferwall630db2a4Get', 'bpuid', bpuid)
            const localVarPath = `/{product_id}/offerwall/630db2a4/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (bpuid !== undefined) {
                localVarQueryParameter['bpuid'] = bpuid;
            }

            if (ip !== undefined) {
                localVarQueryParameter['ip'] = ip;
            }

            if (countryIso !== undefined) {
                localVarQueryParameter['country_iso'] = countryIso;
            }

            if (languages) {
                localVarQueryParameter['languages'] = languages;
            }

            if (behavior !== undefined) {
                localVarQueryParameter['behavior'] = behavior;
            }

            if (minPayout !== undefined) {
                localVarQueryParameter['min_payout'] = minPayout;
            }

            if (duration !== undefined) {
                localVarQueryParameter['duration'] = duration;
            }

            if (nBins !== undefined) {
                localVarQueryParameter['n_bins'] = nBins;
            }

            if (minBinSize !== undefined) {
                localVarQueryParameter['min_bin_size'] = minBinSize;
            }

            if (splitBy !== undefined) {
                localVarQueryParameter['split_by'] = splitBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Same as the StarwallOfferWall, but the buckets include contents.
         * @summary Starwall Plus Offerwall
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
         * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
         * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
         * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
         * @param {number} [duration] Maximum length of desired task (in seconds).
         * @param {number} [nBins] Number of bins requested in the offerwall. If n_bins&#x3D;1 there is no grouping and you get all      duration + payout metrics on across all (as shown by the  availability_count).     n_bins&#x3D;0 will return back an empty bucket array, however, the availability_count will still show      the total opportunities available for that bpuid + passed in parameter settings.     n_bins&#x3D;âˆž (or any positive integer) will return back the total number of bins capable of being uniquely split.
         * @param {number} [minBinSize] Minimum number of tasks that need to be in a bucket
         * @param {StarwallPlusOfferwallProductIdOfferwall5481f322GetSplitByEnum} [splitBy] Cluster tasks by payout or duration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        starwallPlusOfferwallProductIdOfferwall5481f322Get: async (productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, nBins?: number, minBinSize?: number, splitBy?: StarwallPlusOfferwallProductIdOfferwall5481f322GetSplitByEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('starwallPlusOfferwallProductIdOfferwall5481f322Get', 'productId', productId)
            // verify required parameter 'bpuid' is not null or undefined
            assertParamExists('starwallPlusOfferwallProductIdOfferwall5481f322Get', 'bpuid', bpuid)
            const localVarPath = `/{product_id}/offerwall/5481f322/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (bpuid !== undefined) {
                localVarQueryParameter['bpuid'] = bpuid;
            }

            if (ip !== undefined) {
                localVarQueryParameter['ip'] = ip;
            }

            if (countryIso !== undefined) {
                localVarQueryParameter['country_iso'] = countryIso;
            }

            if (languages) {
                localVarQueryParameter['languages'] = languages;
            }

            if (behavior !== undefined) {
                localVarQueryParameter['behavior'] = behavior;
            }

            if (minPayout !== undefined) {
                localVarQueryParameter['min_payout'] = minPayout;
            }

            if (duration !== undefined) {
                localVarQueryParameter['duration'] = duration;
            }

            if (nBins !== undefined) {
                localVarQueryParameter['n_bins'] = nBins;
            }

            if (minBinSize !== undefined) {
                localVarQueryParameter['min_bin_size'] = minBinSize;
            }

            if (splitBy !== undefined) {
                localVarQueryParameter['split_by'] = splitBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an offerwall with buckets that are clustered by the `split_by` argument using KMeans clustering.
         * @summary Topn Offerwall
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
         * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
         * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
         * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
         * @param {number} [duration] Maximum length of desired task (in seconds).
         * @param {number} [nBins] Number of bins requested in the offerwall. If n_bins&#x3D;1 there is no grouping and you get all      duration + payout metrics on across all (as shown by the  availability_count).     n_bins&#x3D;0 will return back an empty bucket array, however, the availability_count will still show      the total opportunities available for that bpuid + passed in parameter settings.     n_bins&#x3D;âˆž (or any positive integer) will return back the total number of bins capable of being uniquely split.
         * @param {number} [minBinSize] Minimum number of tasks that need to be in a bucket
         * @param {TopNOfferwallProductIdOfferwall45b7228a7GetSplitByEnum} [splitBy] Cluster tasks by payout or duration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topNOfferwallProductIdOfferwall45b7228a7Get: async (productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, nBins?: number, minBinSize?: number, splitBy?: TopNOfferwallProductIdOfferwall45b7228a7GetSplitByEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('topNOfferwallProductIdOfferwall45b7228a7Get', 'productId', productId)
            // verify required parameter 'bpuid' is not null or undefined
            assertParamExists('topNOfferwallProductIdOfferwall45b7228a7Get', 'bpuid', bpuid)
            const localVarPath = `/{product_id}/offerwall/45b7228a7/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (bpuid !== undefined) {
                localVarQueryParameter['bpuid'] = bpuid;
            }

            if (ip !== undefined) {
                localVarQueryParameter['ip'] = ip;
            }

            if (countryIso !== undefined) {
                localVarQueryParameter['country_iso'] = countryIso;
            }

            if (languages) {
                localVarQueryParameter['languages'] = languages;
            }

            if (behavior !== undefined) {
                localVarQueryParameter['behavior'] = behavior;
            }

            if (minPayout !== undefined) {
                localVarQueryParameter['min_payout'] = minPayout;
            }

            if (duration !== undefined) {
                localVarQueryParameter['duration'] = duration;
            }

            if (nBins !== undefined) {
                localVarQueryParameter['n_bins'] = nBins;
            }

            if (minBinSize !== undefined) {
                localVarQueryParameter['min_bin_size'] = minBinSize;
            }

            if (splitBy !== undefined) {
                localVarQueryParameter['split_by'] = splitBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Same as the TopNOfferWall, but the buckets include contents and no buckets are returned if the user is blocked.
         * @summary Topn Plus Block Offerwall
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
         * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
         * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
         * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
         * @param {number} [duration] Maximum length of desired task (in seconds).
         * @param {number} [nBins] Number of bins requested in the offerwall. If n_bins&#x3D;1 there is no grouping and you get all      duration + payout metrics on across all (as shown by the  availability_count).     n_bins&#x3D;0 will return back an empty bucket array, however, the availability_count will still show      the total opportunities available for that bpuid + passed in parameter settings.     n_bins&#x3D;âˆž (or any positive integer) will return back the total number of bins capable of being uniquely split.
         * @param {number} [minBinSize] Minimum number of tasks that need to be in a bucket
         * @param {TopNPlusBlockOfferwallProductIdOfferwallD48cce47GetSplitByEnum} [splitBy] Cluster tasks by payout or duration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topNPlusBlockOfferwallProductIdOfferwallD48cce47Get: async (productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, nBins?: number, minBinSize?: number, splitBy?: TopNPlusBlockOfferwallProductIdOfferwallD48cce47GetSplitByEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('topNPlusBlockOfferwallProductIdOfferwallD48cce47Get', 'productId', productId)
            // verify required parameter 'bpuid' is not null or undefined
            assertParamExists('topNPlusBlockOfferwallProductIdOfferwallD48cce47Get', 'bpuid', bpuid)
            const localVarPath = `/{product_id}/offerwall/d48cce47/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (bpuid !== undefined) {
                localVarQueryParameter['bpuid'] = bpuid;
            }

            if (ip !== undefined) {
                localVarQueryParameter['ip'] = ip;
            }

            if (countryIso !== undefined) {
                localVarQueryParameter['country_iso'] = countryIso;
            }

            if (languages) {
                localVarQueryParameter['languages'] = languages;
            }

            if (behavior !== undefined) {
                localVarQueryParameter['behavior'] = behavior;
            }

            if (minPayout !== undefined) {
                localVarQueryParameter['min_payout'] = minPayout;
            }

            if (duration !== undefined) {
                localVarQueryParameter['duration'] = duration;
            }

            if (nBins !== undefined) {
                localVarQueryParameter['n_bins'] = nBins;
            }

            if (minBinSize !== undefined) {
                localVarQueryParameter['min_bin_size'] = minBinSize;
            }

            if (splitBy !== undefined) {
                localVarQueryParameter['split_by'] = splitBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Same as the TopNOfferWall, but the buckets include contents, no buckets are returned if the user is blocked, and each bucket includes a `is_recontact` key.
         * @summary Topn Plus Block Recontact Offerwall
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
         * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
         * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
         * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
         * @param {number} [duration] Maximum length of desired task (in seconds).
         * @param {number} [nBins] Number of bins requested in the offerwall. If n_bins&#x3D;1 there is no grouping and you get all      duration + payout metrics on across all (as shown by the  availability_count).     n_bins&#x3D;0 will return back an empty bucket array, however, the availability_count will still show      the total opportunities available for that bpuid + passed in parameter settings.     n_bins&#x3D;âˆž (or any positive integer) will return back the total number of bins capable of being uniquely split.
         * @param {number} [minBinSize] Minimum number of tasks that need to be in a bucket
         * @param {TopNPlusBlockRecontactOfferwallProductIdOfferwall1e5f0af8GetSplitByEnum} [splitBy] Cluster tasks by payout or duration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topNPlusBlockRecontactOfferwallProductIdOfferwall1e5f0af8Get: async (productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, nBins?: number, minBinSize?: number, splitBy?: TopNPlusBlockRecontactOfferwallProductIdOfferwall1e5f0af8GetSplitByEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('topNPlusBlockRecontactOfferwallProductIdOfferwall1e5f0af8Get', 'productId', productId)
            // verify required parameter 'bpuid' is not null or undefined
            assertParamExists('topNPlusBlockRecontactOfferwallProductIdOfferwall1e5f0af8Get', 'bpuid', bpuid)
            const localVarPath = `/{product_id}/offerwall/1e5f0af8/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (bpuid !== undefined) {
                localVarQueryParameter['bpuid'] = bpuid;
            }

            if (ip !== undefined) {
                localVarQueryParameter['ip'] = ip;
            }

            if (countryIso !== undefined) {
                localVarQueryParameter['country_iso'] = countryIso;
            }

            if (languages) {
                localVarQueryParameter['languages'] = languages;
            }

            if (behavior !== undefined) {
                localVarQueryParameter['behavior'] = behavior;
            }

            if (minPayout !== undefined) {
                localVarQueryParameter['min_payout'] = minPayout;
            }

            if (duration !== undefined) {
                localVarQueryParameter['duration'] = duration;
            }

            if (nBins !== undefined) {
                localVarQueryParameter['n_bins'] = nBins;
            }

            if (minBinSize !== undefined) {
                localVarQueryParameter['min_bin_size'] = minBinSize;
            }

            if (splitBy !== undefined) {
                localVarQueryParameter['split_by'] = splitBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Same as the TopNOfferWall, but the buckets include contents.
         * @summary Topn Plus Offerwall
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
         * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
         * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
         * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
         * @param {number} [duration] Maximum length of desired task (in seconds).
         * @param {number} [nBins] Number of bins requested in the offerwall. If n_bins&#x3D;1 there is no grouping and you get all      duration + payout metrics on across all (as shown by the  availability_count).     n_bins&#x3D;0 will return back an empty bucket array, however, the availability_count will still show      the total opportunities available for that bpuid + passed in parameter settings.     n_bins&#x3D;âˆž (or any positive integer) will return back the total number of bins capable of being uniquely split.
         * @param {number} [minBinSize] Minimum number of tasks that need to be in a bucket
         * @param {TopNPlusOfferwallProductIdOfferwallB145b803GetSplitByEnum} [splitBy] Cluster tasks by payout or duration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topNPlusOfferwallProductIdOfferwallB145b803Get: async (productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, nBins?: number, minBinSize?: number, splitBy?: TopNPlusOfferwallProductIdOfferwallB145b803GetSplitByEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('topNPlusOfferwallProductIdOfferwallB145b803Get', 'productId', productId)
            // verify required parameter 'bpuid' is not null or undefined
            assertParamExists('topNPlusOfferwallProductIdOfferwallB145b803Get', 'bpuid', bpuid)
            const localVarPath = `/{product_id}/offerwall/b145b803/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (bpuid !== undefined) {
                localVarQueryParameter['bpuid'] = bpuid;
            }

            if (ip !== undefined) {
                localVarQueryParameter['ip'] = ip;
            }

            if (countryIso !== undefined) {
                localVarQueryParameter['country_iso'] = countryIso;
            }

            if (languages) {
                localVarQueryParameter['languages'] = languages;
            }

            if (behavior !== undefined) {
                localVarQueryParameter['behavior'] = behavior;
            }

            if (minPayout !== undefined) {
                localVarQueryParameter['min_payout'] = minPayout;
            }

            if (duration !== undefined) {
                localVarQueryParameter['duration'] = duration;
            }

            if (nBins !== undefined) {
                localVarQueryParameter['n_bins'] = nBins;
            }

            if (minBinSize !== undefined) {
                localVarQueryParameter['min_bin_size'] = minBinSize;
            }

            if (splitBy !== undefined) {
                localVarQueryParameter['split_by'] = splitBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Each bucket has only 1 single task, and only basic info is returned     about each bucket.
         * @summary Wxet Offerwall
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
         * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
         * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
         * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
         * @param {number} [duration] Maximum length of desired task (in seconds).
         * @param {number} [nBins] Number of bins requested in the offerwall. If n_bins&#x3D;1 there is no grouping and you get all      duration + payout metrics on across all (as shown by the  availability_count).     n_bins&#x3D;0 will return back an empty bucket array, however, the availability_count will still show      the total opportunities available for that bpuid + passed in parameter settings.     n_bins&#x3D;âˆž (or any positive integer) will return back the total number of bins capable of being uniquely split.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wXETOfferwallProductIdOfferwall55a4e1a9Get: async (productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, nBins?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('wXETOfferwallProductIdOfferwall55a4e1a9Get', 'productId', productId)
            // verify required parameter 'bpuid' is not null or undefined
            assertParamExists('wXETOfferwallProductIdOfferwall55a4e1a9Get', 'bpuid', bpuid)
            const localVarPath = `/{product_id}/offerwall/55a4e1a9/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (bpuid !== undefined) {
                localVarQueryParameter['bpuid'] = bpuid;
            }

            if (ip !== undefined) {
                localVarQueryParameter['ip'] = ip;
            }

            if (countryIso !== undefined) {
                localVarQueryParameter['country_iso'] = countryIso;
            }

            if (languages) {
                localVarQueryParameter['languages'] = languages;
            }

            if (behavior !== undefined) {
                localVarQueryParameter['behavior'] = behavior;
            }

            if (minPayout !== undefined) {
                localVarQueryParameter['min_payout'] = minPayout;
            }

            if (duration !== undefined) {
                localVarQueryParameter['duration'] = duration;
            }

            if (nBins !== undefined) {
                localVarQueryParameter['n_bins'] = nBins;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OfferwallApi - functional programming interface
 * @export
 */
export const OfferwallApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OfferwallApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns buckets grouped by marketplace, one per marketplace, with the tasks ordered by quality.
         * @summary Marketplace Offerwall
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
         * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
         * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
         * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
         * @param {number} [duration] Maximum length of desired task (in seconds).
         * @param {number} [minBinSize] Minimum number of tasks that need to be in a bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async marketplaceOfferwallProductIdOfferwall5fa23085Get(productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, minBinSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MarketplaceOfferwallResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.marketplaceOfferwallProductIdOfferwall5fa23085Get(productId, bpuid, ip, countryIso, languages, behavior, minPayout, duration, minBinSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OfferwallApi.marketplaceOfferwallProductIdOfferwall5fa23085Get']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This is a custom endpoint for a softpair-style offerwall that allows you to update profiling answers and then immediately get back the updated offerwall
         * @summary Offerwall Softpair Block Post
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} offerwallId The offerwall ID the user is interacting with
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {BodyOfferwallSoftpairBlockPostProductIdOfferwall7a89dcdbOfferwallIdPost} bodyOfferwallSoftpairBlockPostProductIdOfferwall7a89dcdbOfferwallIdPost 
         * @param {string | null} [sessionId] A session id (uuid4.hex)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async offerwallSoftpairBlockPostProductIdOfferwall7a89dcdbOfferwallIdPost(productId: string, offerwallId: string, bpuid: string, bodyOfferwallSoftpairBlockPostProductIdOfferwall7a89dcdbOfferwallIdPost: BodyOfferwallSoftpairBlockPostProductIdOfferwall7a89dcdbOfferwallIdPost, sessionId?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SoftPairOfferwallResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.offerwallSoftpairBlockPostProductIdOfferwall7a89dcdbOfferwallIdPost(productId, offerwallId, bpuid, bodyOfferwallSoftpairBlockPostProductIdOfferwall7a89dcdbOfferwallIdPost, sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OfferwallApi.offerwallSoftpairBlockPostProductIdOfferwall7a89dcdbOfferwallIdPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This offerwall contains tasks for which the user has a conditional eligibility. The questions that a user must answer to determine the eligibility are included within each bucket. Additionally, the question definitions are included for convenience. No buckets are returned if the user is blocked.
         * @summary Offerwall Softpair Block
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
         * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
         * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
         * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
         * @param {number} [duration] Maximum length of desired task (in seconds).
         * @param {number} [nBins] Number of bins requested in the offerwall. If n_bins&#x3D;1 there is no grouping and you get all      duration + payout metrics on across all (as shown by the  availability_count).     n_bins&#x3D;0 will return back an empty bucket array, however, the availability_count will still show      the total opportunities available for that bpuid + passed in parameter settings.     n_bins&#x3D;âˆž (or any positive integer) will return back the total number of bins capable of being uniquely split.
         * @param {number} [minBinSize] Minimum number of tasks that need to be in a bucket
         * @param {number} [maxOptions] Max number of options an allowed question can have (allowed to be asked)
         * @param {number} [maxQuestions] Max number of missing questions on a single bin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async offerwallSoftpairBlockProductIdOfferwall7a89dcdbGet(productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, nBins?: number, minBinSize?: number, maxOptions?: number, maxQuestions?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SoftPairOfferwallResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.offerwallSoftpairBlockProductIdOfferwall7a89dcdbGet(productId, bpuid, ip, countryIso, languages, behavior, minPayout, duration, nBins, minBinSize, maxOptions, maxQuestions, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OfferwallApi.offerwallSoftpairBlockProductIdOfferwall7a89dcdbGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This is a custom endpoint for a softpair-style offerwall that allows you to update profiling answers and then immediately get back the updated offerwall
         * @summary Offerwall Softpair Post
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} offerwallId The offerwall ID the user is interacting with
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {BodyOfferwallSoftpairPostProductIdOfferwall37d1da64OfferwallIdPost} bodyOfferwallSoftpairPostProductIdOfferwall37d1da64OfferwallIdPost 
         * @param {string | null} [sessionId] A session id (uuid4.hex)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async offerwallSoftpairPostProductIdOfferwall37d1da64OfferwallIdPost(productId: string, offerwallId: string, bpuid: string, bodyOfferwallSoftpairPostProductIdOfferwall37d1da64OfferwallIdPost: BodyOfferwallSoftpairPostProductIdOfferwall37d1da64OfferwallIdPost, sessionId?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SoftPairOfferwallResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.offerwallSoftpairPostProductIdOfferwall37d1da64OfferwallIdPost(productId, offerwallId, bpuid, bodyOfferwallSoftpairPostProductIdOfferwall37d1da64OfferwallIdPost, sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OfferwallApi.offerwallSoftpairPostProductIdOfferwall37d1da64OfferwallIdPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This offerwall contains tasks for which the user has a conditional eligibility. The questions that a user must answer to determine the eligibility are included within each bucket. Additionally, the question definitions are included for convenience.
         * @summary Offerwall Softpair
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
         * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
         * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
         * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
         * @param {number} [duration] Maximum length of desired task (in seconds).
         * @param {number} [nBins] Number of bins requested in the offerwall. If n_bins&#x3D;1 there is no grouping and you get all      duration + payout metrics on across all (as shown by the  availability_count).     n_bins&#x3D;0 will return back an empty bucket array, however, the availability_count will still show      the total opportunities available for that bpuid + passed in parameter settings.     n_bins&#x3D;âˆž (or any positive integer) will return back the total number of bins capable of being uniquely split.
         * @param {number} [minBinSize] Minimum number of tasks that need to be in a bucket
         * @param {number} [maxOptions] Max number of options an allowed question can have (allowed to be asked)
         * @param {number} [maxQuestions] Max number of missing questions on a single bin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async offerwallSoftpairProductIdOfferwall37d1da64Get(productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, nBins?: number, minBinSize?: number, maxOptions?: number, maxQuestions?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SoftPairOfferwallResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.offerwallSoftpairProductIdOfferwall37d1da64Get(productId, bpuid, ip, countryIso, languages, behavior, minPayout, duration, nBins, minBinSize, maxOptions, maxQuestions, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OfferwallApi.offerwallSoftpairProductIdOfferwall37d1da64Get']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Each bucket has only 1 single task, and only basic info is returned     about each bucket.
         * @summary One Shot Offerwall
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
         * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
         * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
         * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
         * @param {number} [duration] Maximum length of desired task (in seconds).
         * @param {number} [nBins] Number of bins requested in the offerwall. If n_bins&#x3D;1 there is no grouping and you get all      duration + payout metrics on across all (as shown by the  availability_count).     n_bins&#x3D;0 will return back an empty bucket array, however, the availability_count will still show      the total opportunities available for that bpuid + passed in parameter settings.     n_bins&#x3D;âˆž (or any positive integer) will return back the total number of bins capable of being uniquely split.
         * @param {Set<Source>} [sources] Restrict tasks to those from these marketplaces only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oneShotOfferwallProductIdOfferwall6f27b1aeGet(productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, nBins?: number, sources?: Set<Source>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OneShotOfferwallResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oneShotOfferwallProductIdOfferwall6f27b1aeGet(productId, bpuid, ip, countryIso, languages, behavior, minPayout, duration, nBins, sources, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OfferwallApi.oneShotOfferwallProductIdOfferwall6f27b1aeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Only returns a single bucket with the top scoring tasks.
         * @summary Single Offerwall
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
         * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
         * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
         * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
         * @param {number} [duration] Maximum length of desired task (in seconds).
         * @param {number} [minBinSize] Minimum number of tasks that need to be in a bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async singleOfferwallProductIdOfferwall5fl8bpv5Get(productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, minBinSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SingleEntryOfferWallResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.singleOfferwallProductIdOfferwall5fl8bpv5Get(productId, bpuid, ip, countryIso, languages, behavior, minPayout, duration, minBinSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OfferwallApi.singleOfferwallProductIdOfferwall5fl8bpv5Get']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns an offerwall with buckets that are clustered by setting as seeds the highest scoring surveys for each bin, then the rest are distributed according to their Euclidean distance using the bucket\'s features.
         * @summary Starwall Offerwall
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
         * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
         * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
         * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
         * @param {number} [duration] Maximum length of desired task (in seconds).
         * @param {number} [nBins] Number of bins requested in the offerwall. If n_bins&#x3D;1 there is no grouping and you get all      duration + payout metrics on across all (as shown by the  availability_count).     n_bins&#x3D;0 will return back an empty bucket array, however, the availability_count will still show      the total opportunities available for that bpuid + passed in parameter settings.     n_bins&#x3D;âˆž (or any positive integer) will return back the total number of bins capable of being uniquely split.
         * @param {number} [minBinSize] Minimum number of tasks that need to be in a bucket
         * @param {StarwallOfferwallProductIdOfferwallB59a2d2bGetSplitByEnum} [splitBy] Cluster tasks by payout or duration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async starwallOfferwallProductIdOfferwallB59a2d2bGet(productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, nBins?: number, minBinSize?: number, splitBy?: StarwallOfferwallProductIdOfferwallB59a2d2bGetSplitByEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StarwallOfferWallResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.starwallOfferwallProductIdOfferwallB59a2d2bGet(productId, bpuid, ip, countryIso, languages, behavior, minPayout, duration, nBins, minBinSize, splitBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OfferwallApi.starwallOfferwallProductIdOfferwallB59a2d2bGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Same as the StarwallOfferWall, but the buckets include contents and no buckets are returned if the user is blocked.
         * @summary Starwall Plus Block Offerwall
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
         * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
         * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
         * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
         * @param {number} [duration] Maximum length of desired task (in seconds).
         * @param {number} [nBins] Number of bins requested in the offerwall. If n_bins&#x3D;1 there is no grouping and you get all      duration + payout metrics on across all (as shown by the  availability_count).     n_bins&#x3D;0 will return back an empty bucket array, however, the availability_count will still show      the total opportunities available for that bpuid + passed in parameter settings.     n_bins&#x3D;âˆž (or any positive integer) will return back the total number of bins capable of being uniquely split.
         * @param {number} [minBinSize] Minimum number of tasks that need to be in a bucket
         * @param {StarwallPlusBlockOfferwallProductIdOfferwall7fa1b3f4GetSplitByEnum} [splitBy] Cluster tasks by payout or duration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async starwallPlusBlockOfferwallProductIdOfferwall7fa1b3f4Get(productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, nBins?: number, minBinSize?: number, splitBy?: StarwallPlusBlockOfferwallProductIdOfferwall7fa1b3f4GetSplitByEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StarwallPlusBlockOfferWallResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.starwallPlusBlockOfferwallProductIdOfferwall7fa1b3f4Get(productId, bpuid, ip, countryIso, languages, behavior, minPayout, duration, nBins, minBinSize, splitBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OfferwallApi.starwallPlusBlockOfferwallProductIdOfferwall7fa1b3f4Get']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Same as the StarwallOfferWall, but the buckets include contents, no buckets are returned if the user is blocked, and each bucket includes a `is_recontact` key.
         * @summary Starwall Plus Block Recontact Offerwall
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
         * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
         * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
         * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
         * @param {number} [duration] Maximum length of desired task (in seconds).
         * @param {number} [nBins] Number of bins requested in the offerwall. If n_bins&#x3D;1 there is no grouping and you get all      duration + payout metrics on across all (as shown by the  availability_count).     n_bins&#x3D;0 will return back an empty bucket array, however, the availability_count will still show      the total opportunities available for that bpuid + passed in parameter settings.     n_bins&#x3D;âˆž (or any positive integer) will return back the total number of bins capable of being uniquely split.
         * @param {number} [minBinSize] Minimum number of tasks that need to be in a bucket
         * @param {StarwallPlusBlockRecontactOfferwallProductIdOfferwall630db2a4GetSplitByEnum} [splitBy] Cluster tasks by payout or duration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async starwallPlusBlockRecontactOfferwallProductIdOfferwall630db2a4Get(productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, nBins?: number, minBinSize?: number, splitBy?: StarwallPlusBlockRecontactOfferwallProductIdOfferwall630db2a4GetSplitByEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StarwallPlusBlockRecontactOfferWallResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.starwallPlusBlockRecontactOfferwallProductIdOfferwall630db2a4Get(productId, bpuid, ip, countryIso, languages, behavior, minPayout, duration, nBins, minBinSize, splitBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OfferwallApi.starwallPlusBlockRecontactOfferwallProductIdOfferwall630db2a4Get']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Same as the StarwallOfferWall, but the buckets include contents.
         * @summary Starwall Plus Offerwall
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
         * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
         * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
         * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
         * @param {number} [duration] Maximum length of desired task (in seconds).
         * @param {number} [nBins] Number of bins requested in the offerwall. If n_bins&#x3D;1 there is no grouping and you get all      duration + payout metrics on across all (as shown by the  availability_count).     n_bins&#x3D;0 will return back an empty bucket array, however, the availability_count will still show      the total opportunities available for that bpuid + passed in parameter settings.     n_bins&#x3D;âˆž (or any positive integer) will return back the total number of bins capable of being uniquely split.
         * @param {number} [minBinSize] Minimum number of tasks that need to be in a bucket
         * @param {StarwallPlusOfferwallProductIdOfferwall5481f322GetSplitByEnum} [splitBy] Cluster tasks by payout or duration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async starwallPlusOfferwallProductIdOfferwall5481f322Get(productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, nBins?: number, minBinSize?: number, splitBy?: StarwallPlusOfferwallProductIdOfferwall5481f322GetSplitByEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StarwallPlusOfferWallResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.starwallPlusOfferwallProductIdOfferwall5481f322Get(productId, bpuid, ip, countryIso, languages, behavior, minPayout, duration, nBins, minBinSize, splitBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OfferwallApi.starwallPlusOfferwallProductIdOfferwall5481f322Get']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns an offerwall with buckets that are clustered by the `split_by` argument using KMeans clustering.
         * @summary Topn Offerwall
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
         * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
         * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
         * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
         * @param {number} [duration] Maximum length of desired task (in seconds).
         * @param {number} [nBins] Number of bins requested in the offerwall. If n_bins&#x3D;1 there is no grouping and you get all      duration + payout metrics on across all (as shown by the  availability_count).     n_bins&#x3D;0 will return back an empty bucket array, however, the availability_count will still show      the total opportunities available for that bpuid + passed in parameter settings.     n_bins&#x3D;âˆž (or any positive integer) will return back the total number of bins capable of being uniquely split.
         * @param {number} [minBinSize] Minimum number of tasks that need to be in a bucket
         * @param {TopNOfferwallProductIdOfferwall45b7228a7GetSplitByEnum} [splitBy] Cluster tasks by payout or duration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async topNOfferwallProductIdOfferwall45b7228a7Get(productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, nBins?: number, minBinSize?: number, splitBy?: TopNOfferwallProductIdOfferwall45b7228a7GetSplitByEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TopNOfferWallResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.topNOfferwallProductIdOfferwall45b7228a7Get(productId, bpuid, ip, countryIso, languages, behavior, minPayout, duration, nBins, minBinSize, splitBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OfferwallApi.topNOfferwallProductIdOfferwall45b7228a7Get']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Same as the TopNOfferWall, but the buckets include contents and no buckets are returned if the user is blocked.
         * @summary Topn Plus Block Offerwall
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
         * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
         * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
         * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
         * @param {number} [duration] Maximum length of desired task (in seconds).
         * @param {number} [nBins] Number of bins requested in the offerwall. If n_bins&#x3D;1 there is no grouping and you get all      duration + payout metrics on across all (as shown by the  availability_count).     n_bins&#x3D;0 will return back an empty bucket array, however, the availability_count will still show      the total opportunities available for that bpuid + passed in parameter settings.     n_bins&#x3D;âˆž (or any positive integer) will return back the total number of bins capable of being uniquely split.
         * @param {number} [minBinSize] Minimum number of tasks that need to be in a bucket
         * @param {TopNPlusBlockOfferwallProductIdOfferwallD48cce47GetSplitByEnum} [splitBy] Cluster tasks by payout or duration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async topNPlusBlockOfferwallProductIdOfferwallD48cce47Get(productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, nBins?: number, minBinSize?: number, splitBy?: TopNPlusBlockOfferwallProductIdOfferwallD48cce47GetSplitByEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TopNPlusBlockOfferWallResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.topNPlusBlockOfferwallProductIdOfferwallD48cce47Get(productId, bpuid, ip, countryIso, languages, behavior, minPayout, duration, nBins, minBinSize, splitBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OfferwallApi.topNPlusBlockOfferwallProductIdOfferwallD48cce47Get']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Same as the TopNOfferWall, but the buckets include contents, no buckets are returned if the user is blocked, and each bucket includes a `is_recontact` key.
         * @summary Topn Plus Block Recontact Offerwall
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
         * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
         * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
         * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
         * @param {number} [duration] Maximum length of desired task (in seconds).
         * @param {number} [nBins] Number of bins requested in the offerwall. If n_bins&#x3D;1 there is no grouping and you get all      duration + payout metrics on across all (as shown by the  availability_count).     n_bins&#x3D;0 will return back an empty bucket array, however, the availability_count will still show      the total opportunities available for that bpuid + passed in parameter settings.     n_bins&#x3D;âˆž (or any positive integer) will return back the total number of bins capable of being uniquely split.
         * @param {number} [minBinSize] Minimum number of tasks that need to be in a bucket
         * @param {TopNPlusBlockRecontactOfferwallProductIdOfferwall1e5f0af8GetSplitByEnum} [splitBy] Cluster tasks by payout or duration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async topNPlusBlockRecontactOfferwallProductIdOfferwall1e5f0af8Get(productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, nBins?: number, minBinSize?: number, splitBy?: TopNPlusBlockRecontactOfferwallProductIdOfferwall1e5f0af8GetSplitByEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TopNPlusBlockRecontactOfferWallResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.topNPlusBlockRecontactOfferwallProductIdOfferwall1e5f0af8Get(productId, bpuid, ip, countryIso, languages, behavior, minPayout, duration, nBins, minBinSize, splitBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OfferwallApi.topNPlusBlockRecontactOfferwallProductIdOfferwall1e5f0af8Get']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Same as the TopNOfferWall, but the buckets include contents.
         * @summary Topn Plus Offerwall
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
         * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
         * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
         * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
         * @param {number} [duration] Maximum length of desired task (in seconds).
         * @param {number} [nBins] Number of bins requested in the offerwall. If n_bins&#x3D;1 there is no grouping and you get all      duration + payout metrics on across all (as shown by the  availability_count).     n_bins&#x3D;0 will return back an empty bucket array, however, the availability_count will still show      the total opportunities available for that bpuid + passed in parameter settings.     n_bins&#x3D;âˆž (or any positive integer) will return back the total number of bins capable of being uniquely split.
         * @param {number} [minBinSize] Minimum number of tasks that need to be in a bucket
         * @param {TopNPlusOfferwallProductIdOfferwallB145b803GetSplitByEnum} [splitBy] Cluster tasks by payout or duration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async topNPlusOfferwallProductIdOfferwallB145b803Get(productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, nBins?: number, minBinSize?: number, splitBy?: TopNPlusOfferwallProductIdOfferwallB145b803GetSplitByEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TopNPlusOfferWallResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.topNPlusOfferwallProductIdOfferwallB145b803Get(productId, bpuid, ip, countryIso, languages, behavior, minPayout, duration, nBins, minBinSize, splitBy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OfferwallApi.topNPlusOfferwallProductIdOfferwallB145b803Get']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Each bucket has only 1 single task, and only basic info is returned     about each bucket.
         * @summary Wxet Offerwall
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
         * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
         * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
         * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
         * @param {number} [duration] Maximum length of desired task (in seconds).
         * @param {number} [nBins] Number of bins requested in the offerwall. If n_bins&#x3D;1 there is no grouping and you get all      duration + payout metrics on across all (as shown by the  availability_count).     n_bins&#x3D;0 will return back an empty bucket array, however, the availability_count will still show      the total opportunities available for that bpuid + passed in parameter settings.     n_bins&#x3D;âˆž (or any positive integer) will return back the total number of bins capable of being uniquely split.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async wXETOfferwallProductIdOfferwall55a4e1a9Get(productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, nBins?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WXETOfferwallResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.wXETOfferwallProductIdOfferwall55a4e1a9Get(productId, bpuid, ip, countryIso, languages, behavior, minPayout, duration, nBins, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OfferwallApi.wXETOfferwallProductIdOfferwall55a4e1a9Get']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OfferwallApi - factory interface
 * @export
 */
export const OfferwallApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OfferwallApiFp(configuration)
    return {
        /**
         * Returns buckets grouped by marketplace, one per marketplace, with the tasks ordered by quality.
         * @summary Marketplace Offerwall
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
         * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
         * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
         * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
         * @param {number} [duration] Maximum length of desired task (in seconds).
         * @param {number} [minBinSize] Minimum number of tasks that need to be in a bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceOfferwallProductIdOfferwall5fa23085Get(productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, minBinSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<MarketplaceOfferwallResponse> {
            return localVarFp.marketplaceOfferwallProductIdOfferwall5fa23085Get(productId, bpuid, ip, countryIso, languages, behavior, minPayout, duration, minBinSize, options).then((request) => request(axios, basePath));
        },
        /**
         * This is a custom endpoint for a softpair-style offerwall that allows you to update profiling answers and then immediately get back the updated offerwall
         * @summary Offerwall Softpair Block Post
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} offerwallId The offerwall ID the user is interacting with
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {BodyOfferwallSoftpairBlockPostProductIdOfferwall7a89dcdbOfferwallIdPost} bodyOfferwallSoftpairBlockPostProductIdOfferwall7a89dcdbOfferwallIdPost 
         * @param {string | null} [sessionId] A session id (uuid4.hex)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        offerwallSoftpairBlockPostProductIdOfferwall7a89dcdbOfferwallIdPost(productId: string, offerwallId: string, bpuid: string, bodyOfferwallSoftpairBlockPostProductIdOfferwall7a89dcdbOfferwallIdPost: BodyOfferwallSoftpairBlockPostProductIdOfferwall7a89dcdbOfferwallIdPost, sessionId?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<SoftPairOfferwallResponse> {
            return localVarFp.offerwallSoftpairBlockPostProductIdOfferwall7a89dcdbOfferwallIdPost(productId, offerwallId, bpuid, bodyOfferwallSoftpairBlockPostProductIdOfferwall7a89dcdbOfferwallIdPost, sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * This offerwall contains tasks for which the user has a conditional eligibility. The questions that a user must answer to determine the eligibility are included within each bucket. Additionally, the question definitions are included for convenience. No buckets are returned if the user is blocked.
         * @summary Offerwall Softpair Block
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
         * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
         * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
         * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
         * @param {number} [duration] Maximum length of desired task (in seconds).
         * @param {number} [nBins] Number of bins requested in the offerwall. If n_bins&#x3D;1 there is no grouping and you get all      duration + payout metrics on across all (as shown by the  availability_count).     n_bins&#x3D;0 will return back an empty bucket array, however, the availability_count will still show      the total opportunities available for that bpuid + passed in parameter settings.     n_bins&#x3D;âˆž (or any positive integer) will return back the total number of bins capable of being uniquely split.
         * @param {number} [minBinSize] Minimum number of tasks that need to be in a bucket
         * @param {number} [maxOptions] Max number of options an allowed question can have (allowed to be asked)
         * @param {number} [maxQuestions] Max number of missing questions on a single bin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        offerwallSoftpairBlockProductIdOfferwall7a89dcdbGet(productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, nBins?: number, minBinSize?: number, maxOptions?: number, maxQuestions?: number, options?: RawAxiosRequestConfig): AxiosPromise<SoftPairOfferwallResponse> {
            return localVarFp.offerwallSoftpairBlockProductIdOfferwall7a89dcdbGet(productId, bpuid, ip, countryIso, languages, behavior, minPayout, duration, nBins, minBinSize, maxOptions, maxQuestions, options).then((request) => request(axios, basePath));
        },
        /**
         * This is a custom endpoint for a softpair-style offerwall that allows you to update profiling answers and then immediately get back the updated offerwall
         * @summary Offerwall Softpair Post
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} offerwallId The offerwall ID the user is interacting with
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {BodyOfferwallSoftpairPostProductIdOfferwall37d1da64OfferwallIdPost} bodyOfferwallSoftpairPostProductIdOfferwall37d1da64OfferwallIdPost 
         * @param {string | null} [sessionId] A session id (uuid4.hex)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        offerwallSoftpairPostProductIdOfferwall37d1da64OfferwallIdPost(productId: string, offerwallId: string, bpuid: string, bodyOfferwallSoftpairPostProductIdOfferwall37d1da64OfferwallIdPost: BodyOfferwallSoftpairPostProductIdOfferwall37d1da64OfferwallIdPost, sessionId?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<SoftPairOfferwallResponse> {
            return localVarFp.offerwallSoftpairPostProductIdOfferwall37d1da64OfferwallIdPost(productId, offerwallId, bpuid, bodyOfferwallSoftpairPostProductIdOfferwall37d1da64OfferwallIdPost, sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * This offerwall contains tasks for which the user has a conditional eligibility. The questions that a user must answer to determine the eligibility are included within each bucket. Additionally, the question definitions are included for convenience.
         * @summary Offerwall Softpair
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
         * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
         * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
         * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
         * @param {number} [duration] Maximum length of desired task (in seconds).
         * @param {number} [nBins] Number of bins requested in the offerwall. If n_bins&#x3D;1 there is no grouping and you get all      duration + payout metrics on across all (as shown by the  availability_count).     n_bins&#x3D;0 will return back an empty bucket array, however, the availability_count will still show      the total opportunities available for that bpuid + passed in parameter settings.     n_bins&#x3D;âˆž (or any positive integer) will return back the total number of bins capable of being uniquely split.
         * @param {number} [minBinSize] Minimum number of tasks that need to be in a bucket
         * @param {number} [maxOptions] Max number of options an allowed question can have (allowed to be asked)
         * @param {number} [maxQuestions] Max number of missing questions on a single bin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        offerwallSoftpairProductIdOfferwall37d1da64Get(productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, nBins?: number, minBinSize?: number, maxOptions?: number, maxQuestions?: number, options?: RawAxiosRequestConfig): AxiosPromise<SoftPairOfferwallResponse> {
            return localVarFp.offerwallSoftpairProductIdOfferwall37d1da64Get(productId, bpuid, ip, countryIso, languages, behavior, minPayout, duration, nBins, minBinSize, maxOptions, maxQuestions, options).then((request) => request(axios, basePath));
        },
        /**
         * Each bucket has only 1 single task, and only basic info is returned     about each bucket.
         * @summary One Shot Offerwall
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
         * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
         * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
         * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
         * @param {number} [duration] Maximum length of desired task (in seconds).
         * @param {number} [nBins] Number of bins requested in the offerwall. If n_bins&#x3D;1 there is no grouping and you get all      duration + payout metrics on across all (as shown by the  availability_count).     n_bins&#x3D;0 will return back an empty bucket array, however, the availability_count will still show      the total opportunities available for that bpuid + passed in parameter settings.     n_bins&#x3D;âˆž (or any positive integer) will return back the total number of bins capable of being uniquely split.
         * @param {Set<Source>} [sources] Restrict tasks to those from these marketplaces only.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oneShotOfferwallProductIdOfferwall6f27b1aeGet(productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, nBins?: number, sources?: Set<Source>, options?: RawAxiosRequestConfig): AxiosPromise<OneShotOfferwallResponse> {
            return localVarFp.oneShotOfferwallProductIdOfferwall6f27b1aeGet(productId, bpuid, ip, countryIso, languages, behavior, minPayout, duration, nBins, sources, options).then((request) => request(axios, basePath));
        },
        /**
         * Only returns a single bucket with the top scoring tasks.
         * @summary Single Offerwall
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
         * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
         * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
         * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
         * @param {number} [duration] Maximum length of desired task (in seconds).
         * @param {number} [minBinSize] Minimum number of tasks that need to be in a bucket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        singleOfferwallProductIdOfferwall5fl8bpv5Get(productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, minBinSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<SingleEntryOfferWallResponse> {
            return localVarFp.singleOfferwallProductIdOfferwall5fl8bpv5Get(productId, bpuid, ip, countryIso, languages, behavior, minPayout, duration, minBinSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an offerwall with buckets that are clustered by setting as seeds the highest scoring surveys for each bin, then the rest are distributed according to their Euclidean distance using the bucket\'s features.
         * @summary Starwall Offerwall
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
         * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
         * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
         * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
         * @param {number} [duration] Maximum length of desired task (in seconds).
         * @param {number} [nBins] Number of bins requested in the offerwall. If n_bins&#x3D;1 there is no grouping and you get all      duration + payout metrics on across all (as shown by the  availability_count).     n_bins&#x3D;0 will return back an empty bucket array, however, the availability_count will still show      the total opportunities available for that bpuid + passed in parameter settings.     n_bins&#x3D;âˆž (or any positive integer) will return back the total number of bins capable of being uniquely split.
         * @param {number} [minBinSize] Minimum number of tasks that need to be in a bucket
         * @param {StarwallOfferwallProductIdOfferwallB59a2d2bGetSplitByEnum} [splitBy] Cluster tasks by payout or duration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        starwallOfferwallProductIdOfferwallB59a2d2bGet(productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, nBins?: number, minBinSize?: number, splitBy?: StarwallOfferwallProductIdOfferwallB59a2d2bGetSplitByEnum, options?: RawAxiosRequestConfig): AxiosPromise<StarwallOfferWallResponse> {
            return localVarFp.starwallOfferwallProductIdOfferwallB59a2d2bGet(productId, bpuid, ip, countryIso, languages, behavior, minPayout, duration, nBins, minBinSize, splitBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Same as the StarwallOfferWall, but the buckets include contents and no buckets are returned if the user is blocked.
         * @summary Starwall Plus Block Offerwall
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
         * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
         * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
         * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
         * @param {number} [duration] Maximum length of desired task (in seconds).
         * @param {number} [nBins] Number of bins requested in the offerwall. If n_bins&#x3D;1 there is no grouping and you get all      duration + payout metrics on across all (as shown by the  availability_count).     n_bins&#x3D;0 will return back an empty bucket array, however, the availability_count will still show      the total opportunities available for that bpuid + passed in parameter settings.     n_bins&#x3D;âˆž (or any positive integer) will return back the total number of bins capable of being uniquely split.
         * @param {number} [minBinSize] Minimum number of tasks that need to be in a bucket
         * @param {StarwallPlusBlockOfferwallProductIdOfferwall7fa1b3f4GetSplitByEnum} [splitBy] Cluster tasks by payout or duration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        starwallPlusBlockOfferwallProductIdOfferwall7fa1b3f4Get(productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, nBins?: number, minBinSize?: number, splitBy?: StarwallPlusBlockOfferwallProductIdOfferwall7fa1b3f4GetSplitByEnum, options?: RawAxiosRequestConfig): AxiosPromise<StarwallPlusBlockOfferWallResponse> {
            return localVarFp.starwallPlusBlockOfferwallProductIdOfferwall7fa1b3f4Get(productId, bpuid, ip, countryIso, languages, behavior, minPayout, duration, nBins, minBinSize, splitBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Same as the StarwallOfferWall, but the buckets include contents, no buckets are returned if the user is blocked, and each bucket includes a `is_recontact` key.
         * @summary Starwall Plus Block Recontact Offerwall
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
         * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
         * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
         * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
         * @param {number} [duration] Maximum length of desired task (in seconds).
         * @param {number} [nBins] Number of bins requested in the offerwall. If n_bins&#x3D;1 there is no grouping and you get all      duration + payout metrics on across all (as shown by the  availability_count).     n_bins&#x3D;0 will return back an empty bucket array, however, the availability_count will still show      the total opportunities available for that bpuid + passed in parameter settings.     n_bins&#x3D;âˆž (or any positive integer) will return back the total number of bins capable of being uniquely split.
         * @param {number} [minBinSize] Minimum number of tasks that need to be in a bucket
         * @param {StarwallPlusBlockRecontactOfferwallProductIdOfferwall630db2a4GetSplitByEnum} [splitBy] Cluster tasks by payout or duration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        starwallPlusBlockRecontactOfferwallProductIdOfferwall630db2a4Get(productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, nBins?: number, minBinSize?: number, splitBy?: StarwallPlusBlockRecontactOfferwallProductIdOfferwall630db2a4GetSplitByEnum, options?: RawAxiosRequestConfig): AxiosPromise<StarwallPlusBlockRecontactOfferWallResponse> {
            return localVarFp.starwallPlusBlockRecontactOfferwallProductIdOfferwall630db2a4Get(productId, bpuid, ip, countryIso, languages, behavior, minPayout, duration, nBins, minBinSize, splitBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Same as the StarwallOfferWall, but the buckets include contents.
         * @summary Starwall Plus Offerwall
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
         * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
         * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
         * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
         * @param {number} [duration] Maximum length of desired task (in seconds).
         * @param {number} [nBins] Number of bins requested in the offerwall. If n_bins&#x3D;1 there is no grouping and you get all      duration + payout metrics on across all (as shown by the  availability_count).     n_bins&#x3D;0 will return back an empty bucket array, however, the availability_count will still show      the total opportunities available for that bpuid + passed in parameter settings.     n_bins&#x3D;âˆž (or any positive integer) will return back the total number of bins capable of being uniquely split.
         * @param {number} [minBinSize] Minimum number of tasks that need to be in a bucket
         * @param {StarwallPlusOfferwallProductIdOfferwall5481f322GetSplitByEnum} [splitBy] Cluster tasks by payout or duration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        starwallPlusOfferwallProductIdOfferwall5481f322Get(productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, nBins?: number, minBinSize?: number, splitBy?: StarwallPlusOfferwallProductIdOfferwall5481f322GetSplitByEnum, options?: RawAxiosRequestConfig): AxiosPromise<StarwallPlusOfferWallResponse> {
            return localVarFp.starwallPlusOfferwallProductIdOfferwall5481f322Get(productId, bpuid, ip, countryIso, languages, behavior, minPayout, duration, nBins, minBinSize, splitBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an offerwall with buckets that are clustered by the `split_by` argument using KMeans clustering.
         * @summary Topn Offerwall
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
         * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
         * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
         * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
         * @param {number} [duration] Maximum length of desired task (in seconds).
         * @param {number} [nBins] Number of bins requested in the offerwall. If n_bins&#x3D;1 there is no grouping and you get all      duration + payout metrics on across all (as shown by the  availability_count).     n_bins&#x3D;0 will return back an empty bucket array, however, the availability_count will still show      the total opportunities available for that bpuid + passed in parameter settings.     n_bins&#x3D;âˆž (or any positive integer) will return back the total number of bins capable of being uniquely split.
         * @param {number} [minBinSize] Minimum number of tasks that need to be in a bucket
         * @param {TopNOfferwallProductIdOfferwall45b7228a7GetSplitByEnum} [splitBy] Cluster tasks by payout or duration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topNOfferwallProductIdOfferwall45b7228a7Get(productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, nBins?: number, minBinSize?: number, splitBy?: TopNOfferwallProductIdOfferwall45b7228a7GetSplitByEnum, options?: RawAxiosRequestConfig): AxiosPromise<TopNOfferWallResponse> {
            return localVarFp.topNOfferwallProductIdOfferwall45b7228a7Get(productId, bpuid, ip, countryIso, languages, behavior, minPayout, duration, nBins, minBinSize, splitBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Same as the TopNOfferWall, but the buckets include contents and no buckets are returned if the user is blocked.
         * @summary Topn Plus Block Offerwall
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
         * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
         * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
         * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
         * @param {number} [duration] Maximum length of desired task (in seconds).
         * @param {number} [nBins] Number of bins requested in the offerwall. If n_bins&#x3D;1 there is no grouping and you get all      duration + payout metrics on across all (as shown by the  availability_count).     n_bins&#x3D;0 will return back an empty bucket array, however, the availability_count will still show      the total opportunities available for that bpuid + passed in parameter settings.     n_bins&#x3D;âˆž (or any positive integer) will return back the total number of bins capable of being uniquely split.
         * @param {number} [minBinSize] Minimum number of tasks that need to be in a bucket
         * @param {TopNPlusBlockOfferwallProductIdOfferwallD48cce47GetSplitByEnum} [splitBy] Cluster tasks by payout or duration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topNPlusBlockOfferwallProductIdOfferwallD48cce47Get(productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, nBins?: number, minBinSize?: number, splitBy?: TopNPlusBlockOfferwallProductIdOfferwallD48cce47GetSplitByEnum, options?: RawAxiosRequestConfig): AxiosPromise<TopNPlusBlockOfferWallResponse> {
            return localVarFp.topNPlusBlockOfferwallProductIdOfferwallD48cce47Get(productId, bpuid, ip, countryIso, languages, behavior, minPayout, duration, nBins, minBinSize, splitBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Same as the TopNOfferWall, but the buckets include contents, no buckets are returned if the user is blocked, and each bucket includes a `is_recontact` key.
         * @summary Topn Plus Block Recontact Offerwall
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
         * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
         * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
         * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
         * @param {number} [duration] Maximum length of desired task (in seconds).
         * @param {number} [nBins] Number of bins requested in the offerwall. If n_bins&#x3D;1 there is no grouping and you get all      duration + payout metrics on across all (as shown by the  availability_count).     n_bins&#x3D;0 will return back an empty bucket array, however, the availability_count will still show      the total opportunities available for that bpuid + passed in parameter settings.     n_bins&#x3D;âˆž (or any positive integer) will return back the total number of bins capable of being uniquely split.
         * @param {number} [minBinSize] Minimum number of tasks that need to be in a bucket
         * @param {TopNPlusBlockRecontactOfferwallProductIdOfferwall1e5f0af8GetSplitByEnum} [splitBy] Cluster tasks by payout or duration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topNPlusBlockRecontactOfferwallProductIdOfferwall1e5f0af8Get(productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, nBins?: number, minBinSize?: number, splitBy?: TopNPlusBlockRecontactOfferwallProductIdOfferwall1e5f0af8GetSplitByEnum, options?: RawAxiosRequestConfig): AxiosPromise<TopNPlusBlockRecontactOfferWallResponse> {
            return localVarFp.topNPlusBlockRecontactOfferwallProductIdOfferwall1e5f0af8Get(productId, bpuid, ip, countryIso, languages, behavior, minPayout, duration, nBins, minBinSize, splitBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Same as the TopNOfferWall, but the buckets include contents.
         * @summary Topn Plus Offerwall
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
         * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
         * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
         * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
         * @param {number} [duration] Maximum length of desired task (in seconds).
         * @param {number} [nBins] Number of bins requested in the offerwall. If n_bins&#x3D;1 there is no grouping and you get all      duration + payout metrics on across all (as shown by the  availability_count).     n_bins&#x3D;0 will return back an empty bucket array, however, the availability_count will still show      the total opportunities available for that bpuid + passed in parameter settings.     n_bins&#x3D;âˆž (or any positive integer) will return back the total number of bins capable of being uniquely split.
         * @param {number} [minBinSize] Minimum number of tasks that need to be in a bucket
         * @param {TopNPlusOfferwallProductIdOfferwallB145b803GetSplitByEnum} [splitBy] Cluster tasks by payout or duration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        topNPlusOfferwallProductIdOfferwallB145b803Get(productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, nBins?: number, minBinSize?: number, splitBy?: TopNPlusOfferwallProductIdOfferwallB145b803GetSplitByEnum, options?: RawAxiosRequestConfig): AxiosPromise<TopNPlusOfferWallResponse> {
            return localVarFp.topNPlusOfferwallProductIdOfferwallB145b803Get(productId, bpuid, ip, countryIso, languages, behavior, minPayout, duration, nBins, minBinSize, splitBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Each bucket has only 1 single task, and only basic info is returned     about each bucket.
         * @summary Wxet Offerwall
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
         * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
         * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
         * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
         * @param {number} [duration] Maximum length of desired task (in seconds).
         * @param {number} [nBins] Number of bins requested in the offerwall. If n_bins&#x3D;1 there is no grouping and you get all      duration + payout metrics on across all (as shown by the  availability_count).     n_bins&#x3D;0 will return back an empty bucket array, however, the availability_count will still show      the total opportunities available for that bpuid + passed in parameter settings.     n_bins&#x3D;âˆž (or any positive integer) will return back the total number of bins capable of being uniquely split.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wXETOfferwallProductIdOfferwall55a4e1a9Get(productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, nBins?: number, options?: RawAxiosRequestConfig): AxiosPromise<WXETOfferwallResponse> {
            return localVarFp.wXETOfferwallProductIdOfferwall55a4e1a9Get(productId, bpuid, ip, countryIso, languages, behavior, minPayout, duration, nBins, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OfferwallApi - object-oriented interface
 * @export
 * @class OfferwallApi
 * @extends {BaseAPI}
 */
export class OfferwallApi extends BaseAPI {
    /**
     * Returns buckets grouped by marketplace, one per marketplace, with the tasks ordered by quality.
     * @summary Marketplace Offerwall
     * @param {string} productId The Brokerage Product ID provided by GRL.
     * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
     * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
     * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
     * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
     * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
     * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
     * @param {number} [duration] Maximum length of desired task (in seconds).
     * @param {number} [minBinSize] Minimum number of tasks that need to be in a bucket
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfferwallApi
     */
    public marketplaceOfferwallProductIdOfferwall5fa23085Get(productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, minBinSize?: number, options?: RawAxiosRequestConfig) {
        return OfferwallApiFp(this.configuration).marketplaceOfferwallProductIdOfferwall5fa23085Get(productId, bpuid, ip, countryIso, languages, behavior, minPayout, duration, minBinSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This is a custom endpoint for a softpair-style offerwall that allows you to update profiling answers and then immediately get back the updated offerwall
     * @summary Offerwall Softpair Block Post
     * @param {string} productId The Brokerage Product ID provided by GRL.
     * @param {string} offerwallId The offerwall ID the user is interacting with
     * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
     * @param {BodyOfferwallSoftpairBlockPostProductIdOfferwall7a89dcdbOfferwallIdPost} bodyOfferwallSoftpairBlockPostProductIdOfferwall7a89dcdbOfferwallIdPost 
     * @param {string | null} [sessionId] A session id (uuid4.hex)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfferwallApi
     */
    public offerwallSoftpairBlockPostProductIdOfferwall7a89dcdbOfferwallIdPost(productId: string, offerwallId: string, bpuid: string, bodyOfferwallSoftpairBlockPostProductIdOfferwall7a89dcdbOfferwallIdPost: BodyOfferwallSoftpairBlockPostProductIdOfferwall7a89dcdbOfferwallIdPost, sessionId?: string | null, options?: RawAxiosRequestConfig) {
        return OfferwallApiFp(this.configuration).offerwallSoftpairBlockPostProductIdOfferwall7a89dcdbOfferwallIdPost(productId, offerwallId, bpuid, bodyOfferwallSoftpairBlockPostProductIdOfferwall7a89dcdbOfferwallIdPost, sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This offerwall contains tasks for which the user has a conditional eligibility. The questions that a user must answer to determine the eligibility are included within each bucket. Additionally, the question definitions are included for convenience. No buckets are returned if the user is blocked.
     * @summary Offerwall Softpair Block
     * @param {string} productId The Brokerage Product ID provided by GRL.
     * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
     * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
     * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
     * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
     * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
     * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
     * @param {number} [duration] Maximum length of desired task (in seconds).
     * @param {number} [nBins] Number of bins requested in the offerwall. If n_bins&#x3D;1 there is no grouping and you get all      duration + payout metrics on across all (as shown by the  availability_count).     n_bins&#x3D;0 will return back an empty bucket array, however, the availability_count will still show      the total opportunities available for that bpuid + passed in parameter settings.     n_bins&#x3D;âˆž (or any positive integer) will return back the total number of bins capable of being uniquely split.
     * @param {number} [minBinSize] Minimum number of tasks that need to be in a bucket
     * @param {number} [maxOptions] Max number of options an allowed question can have (allowed to be asked)
     * @param {number} [maxQuestions] Max number of missing questions on a single bin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfferwallApi
     */
    public offerwallSoftpairBlockProductIdOfferwall7a89dcdbGet(productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, nBins?: number, minBinSize?: number, maxOptions?: number, maxQuestions?: number, options?: RawAxiosRequestConfig) {
        return OfferwallApiFp(this.configuration).offerwallSoftpairBlockProductIdOfferwall7a89dcdbGet(productId, bpuid, ip, countryIso, languages, behavior, minPayout, duration, nBins, minBinSize, maxOptions, maxQuestions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This is a custom endpoint for a softpair-style offerwall that allows you to update profiling answers and then immediately get back the updated offerwall
     * @summary Offerwall Softpair Post
     * @param {string} productId The Brokerage Product ID provided by GRL.
     * @param {string} offerwallId The offerwall ID the user is interacting with
     * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
     * @param {BodyOfferwallSoftpairPostProductIdOfferwall37d1da64OfferwallIdPost} bodyOfferwallSoftpairPostProductIdOfferwall37d1da64OfferwallIdPost 
     * @param {string | null} [sessionId] A session id (uuid4.hex)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfferwallApi
     */
    public offerwallSoftpairPostProductIdOfferwall37d1da64OfferwallIdPost(productId: string, offerwallId: string, bpuid: string, bodyOfferwallSoftpairPostProductIdOfferwall37d1da64OfferwallIdPost: BodyOfferwallSoftpairPostProductIdOfferwall37d1da64OfferwallIdPost, sessionId?: string | null, options?: RawAxiosRequestConfig) {
        return OfferwallApiFp(this.configuration).offerwallSoftpairPostProductIdOfferwall37d1da64OfferwallIdPost(productId, offerwallId, bpuid, bodyOfferwallSoftpairPostProductIdOfferwall37d1da64OfferwallIdPost, sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This offerwall contains tasks for which the user has a conditional eligibility. The questions that a user must answer to determine the eligibility are included within each bucket. Additionally, the question definitions are included for convenience.
     * @summary Offerwall Softpair
     * @param {string} productId The Brokerage Product ID provided by GRL.
     * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
     * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
     * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
     * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
     * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
     * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
     * @param {number} [duration] Maximum length of desired task (in seconds).
     * @param {number} [nBins] Number of bins requested in the offerwall. If n_bins&#x3D;1 there is no grouping and you get all      duration + payout metrics on across all (as shown by the  availability_count).     n_bins&#x3D;0 will return back an empty bucket array, however, the availability_count will still show      the total opportunities available for that bpuid + passed in parameter settings.     n_bins&#x3D;âˆž (or any positive integer) will return back the total number of bins capable of being uniquely split.
     * @param {number} [minBinSize] Minimum number of tasks that need to be in a bucket
     * @param {number} [maxOptions] Max number of options an allowed question can have (allowed to be asked)
     * @param {number} [maxQuestions] Max number of missing questions on a single bin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfferwallApi
     */
    public offerwallSoftpairProductIdOfferwall37d1da64Get(productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, nBins?: number, minBinSize?: number, maxOptions?: number, maxQuestions?: number, options?: RawAxiosRequestConfig) {
        return OfferwallApiFp(this.configuration).offerwallSoftpairProductIdOfferwall37d1da64Get(productId, bpuid, ip, countryIso, languages, behavior, minPayout, duration, nBins, minBinSize, maxOptions, maxQuestions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Each bucket has only 1 single task, and only basic info is returned     about each bucket.
     * @summary One Shot Offerwall
     * @param {string} productId The Brokerage Product ID provided by GRL.
     * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
     * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
     * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
     * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
     * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
     * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
     * @param {number} [duration] Maximum length of desired task (in seconds).
     * @param {number} [nBins] Number of bins requested in the offerwall. If n_bins&#x3D;1 there is no grouping and you get all      duration + payout metrics on across all (as shown by the  availability_count).     n_bins&#x3D;0 will return back an empty bucket array, however, the availability_count will still show      the total opportunities available for that bpuid + passed in parameter settings.     n_bins&#x3D;âˆž (or any positive integer) will return back the total number of bins capable of being uniquely split.
     * @param {Set<Source>} [sources] Restrict tasks to those from these marketplaces only.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfferwallApi
     */
    public oneShotOfferwallProductIdOfferwall6f27b1aeGet(productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, nBins?: number, sources?: Set<Source>, options?: RawAxiosRequestConfig) {
        return OfferwallApiFp(this.configuration).oneShotOfferwallProductIdOfferwall6f27b1aeGet(productId, bpuid, ip, countryIso, languages, behavior, minPayout, duration, nBins, sources, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Only returns a single bucket with the top scoring tasks.
     * @summary Single Offerwall
     * @param {string} productId The Brokerage Product ID provided by GRL.
     * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
     * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
     * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
     * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
     * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
     * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
     * @param {number} [duration] Maximum length of desired task (in seconds).
     * @param {number} [minBinSize] Minimum number of tasks that need to be in a bucket
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfferwallApi
     */
    public singleOfferwallProductIdOfferwall5fl8bpv5Get(productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, minBinSize?: number, options?: RawAxiosRequestConfig) {
        return OfferwallApiFp(this.configuration).singleOfferwallProductIdOfferwall5fl8bpv5Get(productId, bpuid, ip, countryIso, languages, behavior, minPayout, duration, minBinSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an offerwall with buckets that are clustered by setting as seeds the highest scoring surveys for each bin, then the rest are distributed according to their Euclidean distance using the bucket\'s features.
     * @summary Starwall Offerwall
     * @param {string} productId The Brokerage Product ID provided by GRL.
     * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
     * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
     * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
     * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
     * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
     * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
     * @param {number} [duration] Maximum length of desired task (in seconds).
     * @param {number} [nBins] Number of bins requested in the offerwall. If n_bins&#x3D;1 there is no grouping and you get all      duration + payout metrics on across all (as shown by the  availability_count).     n_bins&#x3D;0 will return back an empty bucket array, however, the availability_count will still show      the total opportunities available for that bpuid + passed in parameter settings.     n_bins&#x3D;âˆž (or any positive integer) will return back the total number of bins capable of being uniquely split.
     * @param {number} [minBinSize] Minimum number of tasks that need to be in a bucket
     * @param {StarwallOfferwallProductIdOfferwallB59a2d2bGetSplitByEnum} [splitBy] Cluster tasks by payout or duration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfferwallApi
     */
    public starwallOfferwallProductIdOfferwallB59a2d2bGet(productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, nBins?: number, minBinSize?: number, splitBy?: StarwallOfferwallProductIdOfferwallB59a2d2bGetSplitByEnum, options?: RawAxiosRequestConfig) {
        return OfferwallApiFp(this.configuration).starwallOfferwallProductIdOfferwallB59a2d2bGet(productId, bpuid, ip, countryIso, languages, behavior, minPayout, duration, nBins, minBinSize, splitBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Same as the StarwallOfferWall, but the buckets include contents and no buckets are returned if the user is blocked.
     * @summary Starwall Plus Block Offerwall
     * @param {string} productId The Brokerage Product ID provided by GRL.
     * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
     * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
     * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
     * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
     * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
     * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
     * @param {number} [duration] Maximum length of desired task (in seconds).
     * @param {number} [nBins] Number of bins requested in the offerwall. If n_bins&#x3D;1 there is no grouping and you get all      duration + payout metrics on across all (as shown by the  availability_count).     n_bins&#x3D;0 will return back an empty bucket array, however, the availability_count will still show      the total opportunities available for that bpuid + passed in parameter settings.     n_bins&#x3D;âˆž (or any positive integer) will return back the total number of bins capable of being uniquely split.
     * @param {number} [minBinSize] Minimum number of tasks that need to be in a bucket
     * @param {StarwallPlusBlockOfferwallProductIdOfferwall7fa1b3f4GetSplitByEnum} [splitBy] Cluster tasks by payout or duration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfferwallApi
     */
    public starwallPlusBlockOfferwallProductIdOfferwall7fa1b3f4Get(productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, nBins?: number, minBinSize?: number, splitBy?: StarwallPlusBlockOfferwallProductIdOfferwall7fa1b3f4GetSplitByEnum, options?: RawAxiosRequestConfig) {
        return OfferwallApiFp(this.configuration).starwallPlusBlockOfferwallProductIdOfferwall7fa1b3f4Get(productId, bpuid, ip, countryIso, languages, behavior, minPayout, duration, nBins, minBinSize, splitBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Same as the StarwallOfferWall, but the buckets include contents, no buckets are returned if the user is blocked, and each bucket includes a `is_recontact` key.
     * @summary Starwall Plus Block Recontact Offerwall
     * @param {string} productId The Brokerage Product ID provided by GRL.
     * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
     * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
     * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
     * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
     * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
     * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
     * @param {number} [duration] Maximum length of desired task (in seconds).
     * @param {number} [nBins] Number of bins requested in the offerwall. If n_bins&#x3D;1 there is no grouping and you get all      duration + payout metrics on across all (as shown by the  availability_count).     n_bins&#x3D;0 will return back an empty bucket array, however, the availability_count will still show      the total opportunities available for that bpuid + passed in parameter settings.     n_bins&#x3D;âˆž (or any positive integer) will return back the total number of bins capable of being uniquely split.
     * @param {number} [minBinSize] Minimum number of tasks that need to be in a bucket
     * @param {StarwallPlusBlockRecontactOfferwallProductIdOfferwall630db2a4GetSplitByEnum} [splitBy] Cluster tasks by payout or duration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfferwallApi
     */
    public starwallPlusBlockRecontactOfferwallProductIdOfferwall630db2a4Get(productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, nBins?: number, minBinSize?: number, splitBy?: StarwallPlusBlockRecontactOfferwallProductIdOfferwall630db2a4GetSplitByEnum, options?: RawAxiosRequestConfig) {
        return OfferwallApiFp(this.configuration).starwallPlusBlockRecontactOfferwallProductIdOfferwall630db2a4Get(productId, bpuid, ip, countryIso, languages, behavior, minPayout, duration, nBins, minBinSize, splitBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Same as the StarwallOfferWall, but the buckets include contents.
     * @summary Starwall Plus Offerwall
     * @param {string} productId The Brokerage Product ID provided by GRL.
     * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
     * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
     * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
     * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
     * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
     * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
     * @param {number} [duration] Maximum length of desired task (in seconds).
     * @param {number} [nBins] Number of bins requested in the offerwall. If n_bins&#x3D;1 there is no grouping and you get all      duration + payout metrics on across all (as shown by the  availability_count).     n_bins&#x3D;0 will return back an empty bucket array, however, the availability_count will still show      the total opportunities available for that bpuid + passed in parameter settings.     n_bins&#x3D;âˆž (or any positive integer) will return back the total number of bins capable of being uniquely split.
     * @param {number} [minBinSize] Minimum number of tasks that need to be in a bucket
     * @param {StarwallPlusOfferwallProductIdOfferwall5481f322GetSplitByEnum} [splitBy] Cluster tasks by payout or duration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfferwallApi
     */
    public starwallPlusOfferwallProductIdOfferwall5481f322Get(productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, nBins?: number, minBinSize?: number, splitBy?: StarwallPlusOfferwallProductIdOfferwall5481f322GetSplitByEnum, options?: RawAxiosRequestConfig) {
        return OfferwallApiFp(this.configuration).starwallPlusOfferwallProductIdOfferwall5481f322Get(productId, bpuid, ip, countryIso, languages, behavior, minPayout, duration, nBins, minBinSize, splitBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an offerwall with buckets that are clustered by the `split_by` argument using KMeans clustering.
     * @summary Topn Offerwall
     * @param {string} productId The Brokerage Product ID provided by GRL.
     * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
     * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
     * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
     * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
     * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
     * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
     * @param {number} [duration] Maximum length of desired task (in seconds).
     * @param {number} [nBins] Number of bins requested in the offerwall. If n_bins&#x3D;1 there is no grouping and you get all      duration + payout metrics on across all (as shown by the  availability_count).     n_bins&#x3D;0 will return back an empty bucket array, however, the availability_count will still show      the total opportunities available for that bpuid + passed in parameter settings.     n_bins&#x3D;âˆž (or any positive integer) will return back the total number of bins capable of being uniquely split.
     * @param {number} [minBinSize] Minimum number of tasks that need to be in a bucket
     * @param {TopNOfferwallProductIdOfferwall45b7228a7GetSplitByEnum} [splitBy] Cluster tasks by payout or duration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfferwallApi
     */
    public topNOfferwallProductIdOfferwall45b7228a7Get(productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, nBins?: number, minBinSize?: number, splitBy?: TopNOfferwallProductIdOfferwall45b7228a7GetSplitByEnum, options?: RawAxiosRequestConfig) {
        return OfferwallApiFp(this.configuration).topNOfferwallProductIdOfferwall45b7228a7Get(productId, bpuid, ip, countryIso, languages, behavior, minPayout, duration, nBins, minBinSize, splitBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Same as the TopNOfferWall, but the buckets include contents and no buckets are returned if the user is blocked.
     * @summary Topn Plus Block Offerwall
     * @param {string} productId The Brokerage Product ID provided by GRL.
     * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
     * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
     * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
     * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
     * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
     * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
     * @param {number} [duration] Maximum length of desired task (in seconds).
     * @param {number} [nBins] Number of bins requested in the offerwall. If n_bins&#x3D;1 there is no grouping and you get all      duration + payout metrics on across all (as shown by the  availability_count).     n_bins&#x3D;0 will return back an empty bucket array, however, the availability_count will still show      the total opportunities available for that bpuid + passed in parameter settings.     n_bins&#x3D;âˆž (or any positive integer) will return back the total number of bins capable of being uniquely split.
     * @param {number} [minBinSize] Minimum number of tasks that need to be in a bucket
     * @param {TopNPlusBlockOfferwallProductIdOfferwallD48cce47GetSplitByEnum} [splitBy] Cluster tasks by payout or duration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfferwallApi
     */
    public topNPlusBlockOfferwallProductIdOfferwallD48cce47Get(productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, nBins?: number, minBinSize?: number, splitBy?: TopNPlusBlockOfferwallProductIdOfferwallD48cce47GetSplitByEnum, options?: RawAxiosRequestConfig) {
        return OfferwallApiFp(this.configuration).topNPlusBlockOfferwallProductIdOfferwallD48cce47Get(productId, bpuid, ip, countryIso, languages, behavior, minPayout, duration, nBins, minBinSize, splitBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Same as the TopNOfferWall, but the buckets include contents, no buckets are returned if the user is blocked, and each bucket includes a `is_recontact` key.
     * @summary Topn Plus Block Recontact Offerwall
     * @param {string} productId The Brokerage Product ID provided by GRL.
     * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
     * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
     * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
     * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
     * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
     * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
     * @param {number} [duration] Maximum length of desired task (in seconds).
     * @param {number} [nBins] Number of bins requested in the offerwall. If n_bins&#x3D;1 there is no grouping and you get all      duration + payout metrics on across all (as shown by the  availability_count).     n_bins&#x3D;0 will return back an empty bucket array, however, the availability_count will still show      the total opportunities available for that bpuid + passed in parameter settings.     n_bins&#x3D;âˆž (or any positive integer) will return back the total number of bins capable of being uniquely split.
     * @param {number} [minBinSize] Minimum number of tasks that need to be in a bucket
     * @param {TopNPlusBlockRecontactOfferwallProductIdOfferwall1e5f0af8GetSplitByEnum} [splitBy] Cluster tasks by payout or duration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfferwallApi
     */
    public topNPlusBlockRecontactOfferwallProductIdOfferwall1e5f0af8Get(productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, nBins?: number, minBinSize?: number, splitBy?: TopNPlusBlockRecontactOfferwallProductIdOfferwall1e5f0af8GetSplitByEnum, options?: RawAxiosRequestConfig) {
        return OfferwallApiFp(this.configuration).topNPlusBlockRecontactOfferwallProductIdOfferwall1e5f0af8Get(productId, bpuid, ip, countryIso, languages, behavior, minPayout, duration, nBins, minBinSize, splitBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Same as the TopNOfferWall, but the buckets include contents.
     * @summary Topn Plus Offerwall
     * @param {string} productId The Brokerage Product ID provided by GRL.
     * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
     * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
     * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
     * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
     * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
     * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
     * @param {number} [duration] Maximum length of desired task (in seconds).
     * @param {number} [nBins] Number of bins requested in the offerwall. If n_bins&#x3D;1 there is no grouping and you get all      duration + payout metrics on across all (as shown by the  availability_count).     n_bins&#x3D;0 will return back an empty bucket array, however, the availability_count will still show      the total opportunities available for that bpuid + passed in parameter settings.     n_bins&#x3D;âˆž (or any positive integer) will return back the total number of bins capable of being uniquely split.
     * @param {number} [minBinSize] Minimum number of tasks that need to be in a bucket
     * @param {TopNPlusOfferwallProductIdOfferwallB145b803GetSplitByEnum} [splitBy] Cluster tasks by payout or duration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfferwallApi
     */
    public topNPlusOfferwallProductIdOfferwallB145b803Get(productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, nBins?: number, minBinSize?: number, splitBy?: TopNPlusOfferwallProductIdOfferwallB145b803GetSplitByEnum, options?: RawAxiosRequestConfig) {
        return OfferwallApiFp(this.configuration).topNPlusOfferwallProductIdOfferwallB145b803Get(productId, bpuid, ip, countryIso, languages, behavior, minPayout, duration, nBins, minBinSize, splitBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Each bucket has only 1 single task, and only basic info is returned     about each bucket.
     * @summary Wxet Offerwall
     * @param {string} productId The Brokerage Product ID provided by GRL.
     * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
     * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
     * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
     * @param {Array<string>} [languages] Respondent\&#39;s desired languages (ISO 639-2/B, lowercase)
     * @param {string} [behavior] Allows using custom scoring functions. Please discuss directly with GRL.
     * @param {string} [minPayout] Decimal representation of the minimum amount of USD that any of the tasks will pay
     * @param {number} [duration] Maximum length of desired task (in seconds).
     * @param {number} [nBins] Number of bins requested in the offerwall. If n_bins&#x3D;1 there is no grouping and you get all      duration + payout metrics on across all (as shown by the  availability_count).     n_bins&#x3D;0 will return back an empty bucket array, however, the availability_count will still show      the total opportunities available for that bpuid + passed in parameter settings.     n_bins&#x3D;âˆž (or any positive integer) will return back the total number of bins capable of being uniquely split.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfferwallApi
     */
    public wXETOfferwallProductIdOfferwall55a4e1a9Get(productId: string, bpuid: string, ip?: string, countryIso?: string, languages?: Array<string>, behavior?: string, minPayout?: string, duration?: number, nBins?: number, options?: RawAxiosRequestConfig) {
        return OfferwallApiFp(this.configuration).wXETOfferwallProductIdOfferwall55a4e1a9Get(productId, bpuid, ip, countryIso, languages, behavior, minPayout, duration, nBins, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const StarwallOfferwallProductIdOfferwallB59a2d2bGetSplitByEnum = {
    Payout: 'payout',
    Duration: 'duration'
} as const;
export type StarwallOfferwallProductIdOfferwallB59a2d2bGetSplitByEnum = typeof StarwallOfferwallProductIdOfferwallB59a2d2bGetSplitByEnum[keyof typeof StarwallOfferwallProductIdOfferwallB59a2d2bGetSplitByEnum];
/**
 * @export
 */
export const StarwallPlusBlockOfferwallProductIdOfferwall7fa1b3f4GetSplitByEnum = {
    Payout: 'payout',
    Duration: 'duration'
} as const;
export type StarwallPlusBlockOfferwallProductIdOfferwall7fa1b3f4GetSplitByEnum = typeof StarwallPlusBlockOfferwallProductIdOfferwall7fa1b3f4GetSplitByEnum[keyof typeof StarwallPlusBlockOfferwallProductIdOfferwall7fa1b3f4GetSplitByEnum];
/**
 * @export
 */
export const StarwallPlusBlockRecontactOfferwallProductIdOfferwall630db2a4GetSplitByEnum = {
    Payout: 'payout',
    Duration: 'duration'
} as const;
export type StarwallPlusBlockRecontactOfferwallProductIdOfferwall630db2a4GetSplitByEnum = typeof StarwallPlusBlockRecontactOfferwallProductIdOfferwall630db2a4GetSplitByEnum[keyof typeof StarwallPlusBlockRecontactOfferwallProductIdOfferwall630db2a4GetSplitByEnum];
/**
 * @export
 */
export const StarwallPlusOfferwallProductIdOfferwall5481f322GetSplitByEnum = {
    Payout: 'payout',
    Duration: 'duration'
} as const;
export type StarwallPlusOfferwallProductIdOfferwall5481f322GetSplitByEnum = typeof StarwallPlusOfferwallProductIdOfferwall5481f322GetSplitByEnum[keyof typeof StarwallPlusOfferwallProductIdOfferwall5481f322GetSplitByEnum];
/**
 * @export
 */
export const TopNOfferwallProductIdOfferwall45b7228a7GetSplitByEnum = {
    Payout: 'payout',
    Duration: 'duration'
} as const;
export type TopNOfferwallProductIdOfferwall45b7228a7GetSplitByEnum = typeof TopNOfferwallProductIdOfferwall45b7228a7GetSplitByEnum[keyof typeof TopNOfferwallProductIdOfferwall45b7228a7GetSplitByEnum];
/**
 * @export
 */
export const TopNPlusBlockOfferwallProductIdOfferwallD48cce47GetSplitByEnum = {
    Payout: 'payout',
    Duration: 'duration'
} as const;
export type TopNPlusBlockOfferwallProductIdOfferwallD48cce47GetSplitByEnum = typeof TopNPlusBlockOfferwallProductIdOfferwallD48cce47GetSplitByEnum[keyof typeof TopNPlusBlockOfferwallProductIdOfferwallD48cce47GetSplitByEnum];
/**
 * @export
 */
export const TopNPlusBlockRecontactOfferwallProductIdOfferwall1e5f0af8GetSplitByEnum = {
    Payout: 'payout',
    Duration: 'duration'
} as const;
export type TopNPlusBlockRecontactOfferwallProductIdOfferwall1e5f0af8GetSplitByEnum = typeof TopNPlusBlockRecontactOfferwallProductIdOfferwall1e5f0af8GetSplitByEnum[keyof typeof TopNPlusBlockRecontactOfferwallProductIdOfferwall1e5f0af8GetSplitByEnum];
/**
 * @export
 */
export const TopNPlusOfferwallProductIdOfferwallB145b803GetSplitByEnum = {
    Payout: 'payout',
    Duration: 'duration'
} as const;
export type TopNPlusOfferwallProductIdOfferwallB145b803GetSplitByEnum = typeof TopNPlusOfferwallProductIdOfferwallB145b803GetSplitByEnum[keyof typeof TopNPlusOfferwallProductIdOfferwallB145b803GetSplitByEnum];


/**
 * ProductUserApi - axios parameter creator
 * @export
 */
export const ProductUserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary User Profile Filter By Marketplace Pid
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {Source} source The marketplace to search
         * @param {Array<string>} pid The user\&#39;s marketplace PID. Supports multiple params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userProfileFilterByMarketplacePidProductIdUserByMarketplacePidGet: async (productId: string, source: Source, pid: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('userProfileFilterByMarketplacePidProductIdUserByMarketplacePidGet', 'productId', productId)
            // verify required parameter 'source' is not null or undefined
            assertParamExists('userProfileFilterByMarketplacePidProductIdUserByMarketplacePidGet', 'source', source)
            // verify required parameter 'pid' is not null or undefined
            assertParamExists('userProfileFilterByMarketplacePidProductIdUserByMarketplacePidGet', 'pid', pid)
            const localVarPath = `/{product_id}/user/by-marketplace-pid/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            if (pid) {
                localVarQueryParameter['pid'] = pid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Profile
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} productUserId A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userProfileProductIdUserProductUserIdProfileGet: async (productId: string, productUserId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('userProfileProductIdUserProductUserIdProfileGet', 'productId', productId)
            // verify required parameter 'productUserId' is not null or undefined
            assertParamExists('userProfileProductIdUserProductUserIdProfileGet', 'productUserId', productUserId)
            const localVarPath = `/{product_id}/user/{product_user_id}/profile/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"product_user_id"}}`, encodeURIComponent(String(productUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Profile Update
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} productUserId A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {UserProfileUpdateRequest} userProfileUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userProfileUpdateProductIdUserProductUserIdProfilePatch: async (productId: string, productUserId: string, userProfileUpdateRequest: UserProfileUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('userProfileUpdateProductIdUserProductUserIdProfilePatch', 'productId', productId)
            // verify required parameter 'productUserId' is not null or undefined
            assertParamExists('userProfileUpdateProductIdUserProductUserIdProfilePatch', 'productUserId', productUserId)
            // verify required parameter 'userProfileUpdateRequest' is not null or undefined
            assertParamExists('userProfileUpdateProductIdUserProductUserIdProfilePatch', 'userProfileUpdateRequest', userProfileUpdateRequest)
            const localVarPath = `/{product_id}/user/{product_user_id}/profile/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"product_user_id"}}`, encodeURIComponent(String(productUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userProfileUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductUserApi - functional programming interface
 * @export
 */
export const ProductUserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductUserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary User Profile Filter By Marketplace Pid
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {Source} source The marketplace to search
         * @param {Array<string>} pid The user\&#39;s marketplace PID. Supports multiple params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userProfileFilterByMarketplacePidProductIdUserByMarketplacePidGet(productId: string, source: Source, pid: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfilesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userProfileFilterByMarketplacePidProductIdUserByMarketplacePidGet(productId, source, pid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductUserApi.userProfileFilterByMarketplacePidProductIdUserByMarketplacePidGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary User Profile
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} productUserId A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userProfileProductIdUserProductUserIdProfileGet(productId: string, productUserId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userProfileProductIdUserProductUserIdProfileGet(productId, productUserId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductUserApi.userProfileProductIdUserProductUserIdProfileGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary User Profile Update
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} productUserId A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {UserProfileUpdateRequest} userProfileUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userProfileUpdateProductIdUserProductUserIdProfilePatch(productId: string, productUserId: string, userProfileUpdateRequest: UserProfileUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userProfileUpdateProductIdUserProductUserIdProfilePatch(productId, productUserId, userProfileUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductUserApi.userProfileUpdateProductIdUserProductUserIdProfilePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProductUserApi - factory interface
 * @export
 */
export const ProductUserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductUserApiFp(configuration)
    return {
        /**
         * 
         * @summary User Profile Filter By Marketplace Pid
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {Source} source The marketplace to search
         * @param {Array<string>} pid The user\&#39;s marketplace PID. Supports multiple params
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userProfileFilterByMarketplacePidProductIdUserByMarketplacePidGet(productId: string, source: Source, pid: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<UserProfilesResponse> {
            return localVarFp.userProfileFilterByMarketplacePidProductIdUserByMarketplacePidGet(productId, source, pid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary User Profile
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} productUserId A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userProfileProductIdUserProductUserIdProfileGet(productId: string, productUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<UserProfileResponse> {
            return localVarFp.userProfileProductIdUserProductUserIdProfileGet(productId, productUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary User Profile Update
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} productUserId A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {UserProfileUpdateRequest} userProfileUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userProfileUpdateProductIdUserProductUserIdProfilePatch(productId: string, productUserId: string, userProfileUpdateRequest: UserProfileUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<StatusResponse> {
            return localVarFp.userProfileUpdateProductIdUserProductUserIdProfilePatch(productId, productUserId, userProfileUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductUserApi - object-oriented interface
 * @export
 * @class ProductUserApi
 * @extends {BaseAPI}
 */
export class ProductUserApi extends BaseAPI {
    /**
     * 
     * @summary User Profile Filter By Marketplace Pid
     * @param {string} productId The Brokerage Product ID provided by GRL.
     * @param {Source} source The marketplace to search
     * @param {Array<string>} pid The user\&#39;s marketplace PID. Supports multiple params
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductUserApi
     */
    public userProfileFilterByMarketplacePidProductIdUserByMarketplacePidGet(productId: string, source: Source, pid: Array<string>, options?: RawAxiosRequestConfig) {
        return ProductUserApiFp(this.configuration).userProfileFilterByMarketplacePidProductIdUserByMarketplacePidGet(productId, source, pid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary User Profile
     * @param {string} productId The Brokerage Product ID provided by GRL.
     * @param {string} productUserId A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductUserApi
     */
    public userProfileProductIdUserProductUserIdProfileGet(productId: string, productUserId: string, options?: RawAxiosRequestConfig) {
        return ProductUserApiFp(this.configuration).userProfileProductIdUserProductUserIdProfileGet(productId, productUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary User Profile Update
     * @param {string} productId The Brokerage Product ID provided by GRL.
     * @param {string} productUserId A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
     * @param {UserProfileUpdateRequest} userProfileUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductUserApi
     */
    public userProfileUpdateProductIdUserProductUserIdProfilePatch(productId: string, productUserId: string, userProfileUpdateRequest: UserProfileUpdateRequest, options?: RawAxiosRequestConfig) {
        return ProductUserApiFp(this.configuration).userProfileUpdateProductIdUserProductUserIdProfilePatch(productId, productUserId, userProfileUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProfilingQuestionsApi - axios parameter creator
 * @export
 */
export const ProfilingQuestionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets a list of profiling questions to ask this user. These questions are, as of right now, unanswered. Once a question is answered, it (and any other question whose answer is inferred from other answers) is removed from the list. The questions returned are ordered by importance (the key task_score) in descending order.
         * @summary Get Profiling Questions
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
         * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {string} [languageIso] Respondent\&#39;s desired language (ISO 639-2/B, lowercase)
         * @param {number} [limit] Number of questions to return. Questions are ordered, so, selects the N most important. If no limit is passed, then the number of questions returned is dynamically calculated by the questions\&#39; importance.
         * @param {boolean} [isGrs] If it\&#39;s the GRS system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfilingQuestionsProductIdProfilingQuestionsGet: async (productId: string, bpuid: string, ip?: string, countryIso?: string, languageIso?: string, limit?: number, isGrs?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getProfilingQuestionsProductIdProfilingQuestionsGet', 'productId', productId)
            // verify required parameter 'bpuid' is not null or undefined
            assertParamExists('getProfilingQuestionsProductIdProfilingQuestionsGet', 'bpuid', bpuid)
            const localVarPath = `/{product_id}/profiling-questions/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (bpuid !== undefined) {
                localVarQueryParameter['bpuid'] = bpuid;
            }

            if (ip !== undefined) {
                localVarQueryParameter['ip'] = ip;
            }

            if (countryIso !== undefined) {
                localVarQueryParameter['country_iso'] = countryIso;
            }

            if (languageIso !== undefined) {
                localVarQueryParameter['language_iso'] = languageIso;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (isGrs !== undefined) {
                localVarQueryParameter['is_grs'] = isGrs;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get UPK Ontology (list of properties, property info, and allowed values)
         * @summary Profiling Info
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} countryIso Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {string} [languageIso] Respondent\&#39;s desired language (ISO 639-2/B, lowercase)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilingInfoProductIdProfilingInfoGet: async (productId: string, countryIso: string, languageIso?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('profilingInfoProductIdProfilingInfoGet', 'productId', productId)
            // verify required parameter 'countryIso' is not null or undefined
            assertParamExists('profilingInfoProductIdProfilingInfoGet', 'countryIso', countryIso)
            const localVarPath = `/{product_id}/profiling-info/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (countryIso !== undefined) {
                localVarQueryParameter['country_iso'] = countryIso;
            }

            if (languageIso !== undefined) {
                localVarQueryParameter['language_iso'] = languageIso;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send the answers to one or more of these questions for a user. A question is uniquely specified by the question_id key. The answer is: the choice_id if the question_type is \"MC\" the actual entered text if the question_type is \"TE\"
         * @summary Submit Profiling Questions
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {BodySubmitProfilingQuestionsProductIdProfilingQuestionsPost} bodySubmitProfilingQuestionsProductIdProfilingQuestionsPost 
         * @param {string} [sessionId] The unique identifier for a session in which these questions were asked. Must be a valid UUID. Optional.
         * @param {boolean} [async] For internal use.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitProfilingQuestionsProductIdProfilingQuestionsPost: async (productId: string, bpuid: string, bodySubmitProfilingQuestionsProductIdProfilingQuestionsPost: BodySubmitProfilingQuestionsProductIdProfilingQuestionsPost, sessionId?: string, async?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('submitProfilingQuestionsProductIdProfilingQuestionsPost', 'productId', productId)
            // verify required parameter 'bpuid' is not null or undefined
            assertParamExists('submitProfilingQuestionsProductIdProfilingQuestionsPost', 'bpuid', bpuid)
            // verify required parameter 'bodySubmitProfilingQuestionsProductIdProfilingQuestionsPost' is not null or undefined
            assertParamExists('submitProfilingQuestionsProductIdProfilingQuestionsPost', 'bodySubmitProfilingQuestionsProductIdProfilingQuestionsPost', bodySubmitProfilingQuestionsProductIdProfilingQuestionsPost)
            const localVarPath = `/{product_id}/profiling-questions/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (bpuid !== undefined) {
                localVarQueryParameter['bpuid'] = bpuid;
            }

            if (sessionId !== undefined) {
                localVarQueryParameter['session_id'] = sessionId;
            }

            if (async !== undefined) {
                localVarQueryParameter['async'] = async;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bodySubmitProfilingQuestionsProductIdProfilingQuestionsPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Profile
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {string} countryIso Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {string} [languageIso] Respondent\&#39;s desired language (ISO 639-2/B, lowercase)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userProfileProductIdUserProfileGet: async (productId: string, bpuid: string, countryIso: string, languageIso?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('userProfileProductIdUserProfileGet', 'productId', productId)
            // verify required parameter 'bpuid' is not null or undefined
            assertParamExists('userProfileProductIdUserProfileGet', 'bpuid', bpuid)
            // verify required parameter 'countryIso' is not null or undefined
            assertParamExists('userProfileProductIdUserProfileGet', 'countryIso', countryIso)
            const localVarPath = `/{product_id}/user-profile/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (bpuid !== undefined) {
                localVarQueryParameter['bpuid'] = bpuid;
            }

            if (countryIso !== undefined) {
                localVarQueryParameter['country_iso'] = countryIso;
            }

            if (languageIso !== undefined) {
                localVarQueryParameter['language_iso'] = languageIso;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfilingQuestionsApi - functional programming interface
 * @export
 */
export const ProfilingQuestionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfilingQuestionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets a list of profiling questions to ask this user. These questions are, as of right now, unanswered. Once a question is answered, it (and any other question whose answer is inferred from other answers) is removed from the list. The questions returned are ordered by importance (the key task_score) in descending order.
         * @summary Get Profiling Questions
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
         * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {string} [languageIso] Respondent\&#39;s desired language (ISO 639-2/B, lowercase)
         * @param {number} [limit] Number of questions to return. Questions are ordered, so, selects the N most important. If no limit is passed, then the number of questions returned is dynamically calculated by the questions\&#39; importance.
         * @param {boolean} [isGrs] If it\&#39;s the GRS system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfilingQuestionsProductIdProfilingQuestionsGet(productId: string, bpuid: string, ip?: string, countryIso?: string, languageIso?: string, limit?: number, isGrs?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpkQuestionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfilingQuestionsProductIdProfilingQuestionsGet(productId, bpuid, ip, countryIso, languageIso, limit, isGrs, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfilingQuestionsApi.getProfilingQuestionsProductIdProfilingQuestionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get UPK Ontology (list of properties, property info, and allowed values)
         * @summary Profiling Info
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} countryIso Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {string} [languageIso] Respondent\&#39;s desired language (ISO 639-2/B, lowercase)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profilingInfoProductIdProfilingInfoGet(productId: string, countryIso: string, languageIso?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfilingInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profilingInfoProductIdProfilingInfoGet(productId, countryIso, languageIso, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfilingQuestionsApi.profilingInfoProductIdProfilingInfoGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send the answers to one or more of these questions for a user. A question is uniquely specified by the question_id key. The answer is: the choice_id if the question_type is \"MC\" the actual entered text if the question_type is \"TE\"
         * @summary Submit Profiling Questions
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {BodySubmitProfilingQuestionsProductIdProfilingQuestionsPost} bodySubmitProfilingQuestionsProductIdProfilingQuestionsPost 
         * @param {string} [sessionId] The unique identifier for a session in which these questions were asked. Must be a valid UUID. Optional.
         * @param {boolean} [async] For internal use.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitProfilingQuestionsProductIdProfilingQuestionsPost(productId: string, bpuid: string, bodySubmitProfilingQuestionsProductIdProfilingQuestionsPost: BodySubmitProfilingQuestionsProductIdProfilingQuestionsPost, sessionId?: string, async?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitProfilingQuestionsProductIdProfilingQuestionsPost(productId, bpuid, bodySubmitProfilingQuestionsProductIdProfilingQuestionsPost, sessionId, async, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfilingQuestionsApi.submitProfilingQuestionsProductIdProfilingQuestionsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary User Profile
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {string} countryIso Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {string} [languageIso] Respondent\&#39;s desired language (ISO 639-2/B, lowercase)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userProfileProductIdUserProfileGet(productId: string, bpuid: string, countryIso: string, languageIso?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userProfileProductIdUserProfileGet(productId, bpuid, countryIso, languageIso, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfilingQuestionsApi.userProfileProductIdUserProfileGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProfilingQuestionsApi - factory interface
 * @export
 */
export const ProfilingQuestionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfilingQuestionsApiFp(configuration)
    return {
        /**
         * Gets a list of profiling questions to ask this user. These questions are, as of right now, unanswered. Once a question is answered, it (and any other question whose answer is inferred from other answers) is removed from the list. The questions returned are ordered by importance (the key task_score) in descending order.
         * @summary Get Profiling Questions
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
         * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {string} [languageIso] Respondent\&#39;s desired language (ISO 639-2/B, lowercase)
         * @param {number} [limit] Number of questions to return. Questions are ordered, so, selects the N most important. If no limit is passed, then the number of questions returned is dynamically calculated by the questions\&#39; importance.
         * @param {boolean} [isGrs] If it\&#39;s the GRS system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfilingQuestionsProductIdProfilingQuestionsGet(productId: string, bpuid: string, ip?: string, countryIso?: string, languageIso?: string, limit?: number, isGrs?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<UpkQuestionResponse> {
            return localVarFp.getProfilingQuestionsProductIdProfilingQuestionsGet(productId, bpuid, ip, countryIso, languageIso, limit, isGrs, options).then((request) => request(axios, basePath));
        },
        /**
         * Get UPK Ontology (list of properties, property info, and allowed values)
         * @summary Profiling Info
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} countryIso Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {string} [languageIso] Respondent\&#39;s desired language (ISO 639-2/B, lowercase)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilingInfoProductIdProfilingInfoGet(productId: string, countryIso: string, languageIso?: string, options?: RawAxiosRequestConfig): AxiosPromise<ProfilingInfoResponse> {
            return localVarFp.profilingInfoProductIdProfilingInfoGet(productId, countryIso, languageIso, options).then((request) => request(axios, basePath));
        },
        /**
         * Send the answers to one or more of these questions for a user. A question is uniquely specified by the question_id key. The answer is: the choice_id if the question_type is \"MC\" the actual entered text if the question_type is \"TE\"
         * @summary Submit Profiling Questions
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {BodySubmitProfilingQuestionsProductIdProfilingQuestionsPost} bodySubmitProfilingQuestionsProductIdProfilingQuestionsPost 
         * @param {string} [sessionId] The unique identifier for a session in which these questions were asked. Must be a valid UUID. Optional.
         * @param {boolean} [async] For internal use.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitProfilingQuestionsProductIdProfilingQuestionsPost(productId: string, bpuid: string, bodySubmitProfilingQuestionsProductIdProfilingQuestionsPost: BodySubmitProfilingQuestionsProductIdProfilingQuestionsPost, sessionId?: string, async?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<StatusResponse> {
            return localVarFp.submitProfilingQuestionsProductIdProfilingQuestionsPost(productId, bpuid, bodySubmitProfilingQuestionsProductIdProfilingQuestionsPost, sessionId, async, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary User Profile
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {string} countryIso Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {string} [languageIso] Respondent\&#39;s desired language (ISO 639-2/B, lowercase)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userProfileProductIdUserProfileGet(productId: string, bpuid: string, countryIso: string, languageIso?: string, options?: RawAxiosRequestConfig): AxiosPromise<UserInfoResponse> {
            return localVarFp.userProfileProductIdUserProfileGet(productId, bpuid, countryIso, languageIso, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProfilingQuestionsApi - object-oriented interface
 * @export
 * @class ProfilingQuestionsApi
 * @extends {BaseAPI}
 */
export class ProfilingQuestionsApi extends BaseAPI {
    /**
     * Gets a list of profiling questions to ask this user. These questions are, as of right now, unanswered. Once a question is answered, it (and any other question whose answer is inferred from other answers) is removed from the list. The questions returned are ordered by importance (the key task_score) in descending order.
     * @summary Get Profiling Questions
     * @param {string} productId The Brokerage Product ID provided by GRL.
     * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
     * @param {string} [ip] Respondent\&#39;s IP address (IPv4 or IPv6). Either \&#39;ip\&#39; must be provided, or \&#39;country_iso\&#39; must be provided if \&#39;ip\&#39; is not provided.
     * @param {string} [countryIso] Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
     * @param {string} [languageIso] Respondent\&#39;s desired language (ISO 639-2/B, lowercase)
     * @param {number} [limit] Number of questions to return. Questions are ordered, so, selects the N most important. If no limit is passed, then the number of questions returned is dynamically calculated by the questions\&#39; importance.
     * @param {boolean} [isGrs] If it\&#39;s the GRS system.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilingQuestionsApi
     */
    public getProfilingQuestionsProductIdProfilingQuestionsGet(productId: string, bpuid: string, ip?: string, countryIso?: string, languageIso?: string, limit?: number, isGrs?: boolean, options?: RawAxiosRequestConfig) {
        return ProfilingQuestionsApiFp(this.configuration).getProfilingQuestionsProductIdProfilingQuestionsGet(productId, bpuid, ip, countryIso, languageIso, limit, isGrs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get UPK Ontology (list of properties, property info, and allowed values)
     * @summary Profiling Info
     * @param {string} productId The Brokerage Product ID provided by GRL.
     * @param {string} countryIso Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
     * @param {string} [languageIso] Respondent\&#39;s desired language (ISO 639-2/B, lowercase)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilingQuestionsApi
     */
    public profilingInfoProductIdProfilingInfoGet(productId: string, countryIso: string, languageIso?: string, options?: RawAxiosRequestConfig) {
        return ProfilingQuestionsApiFp(this.configuration).profilingInfoProductIdProfilingInfoGet(productId, countryIso, languageIso, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send the answers to one or more of these questions for a user. A question is uniquely specified by the question_id key. The answer is: the choice_id if the question_type is \"MC\" the actual entered text if the question_type is \"TE\"
     * @summary Submit Profiling Questions
     * @param {string} productId The Brokerage Product ID provided by GRL.
     * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
     * @param {BodySubmitProfilingQuestionsProductIdProfilingQuestionsPost} bodySubmitProfilingQuestionsProductIdProfilingQuestionsPost 
     * @param {string} [sessionId] The unique identifier for a session in which these questions were asked. Must be a valid UUID. Optional.
     * @param {boolean} [async] For internal use.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilingQuestionsApi
     */
    public submitProfilingQuestionsProductIdProfilingQuestionsPost(productId: string, bpuid: string, bodySubmitProfilingQuestionsProductIdProfilingQuestionsPost: BodySubmitProfilingQuestionsProductIdProfilingQuestionsPost, sessionId?: string, async?: boolean, options?: RawAxiosRequestConfig) {
        return ProfilingQuestionsApiFp(this.configuration).submitProfilingQuestionsProductIdProfilingQuestionsPost(productId, bpuid, bodySubmitProfilingQuestionsProductIdProfilingQuestionsPost, sessionId, async, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary User Profile
     * @param {string} productId The Brokerage Product ID provided by GRL.
     * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
     * @param {string} countryIso Respondent\&#39;s country code (ISO 3166-1 alpha-2, lowercase)
     * @param {string} [languageIso] Respondent\&#39;s desired language (ISO 639-2/B, lowercase)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilingQuestionsApi
     */
    public userProfileProductIdUserProfileGet(productId: string, bpuid: string, countryIso: string, languageIso?: string, options?: RawAxiosRequestConfig) {
        return ProfilingQuestionsApiFp(this.configuration).userProfileProductIdUserProfileGet(productId, bpuid, countryIso, languageIso, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ReportApi - axios parameter creator
 * @export
 */
export const ReportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Send a \"Task Report\" for a respondent\'s latest started survey, regardless of the survey\'s outcome. Task Reports cannot be provided for task attempts by tsid, or through any other method, they must be given immediately after the respondent\'s task attempt.  If a latest attempt can\'t be found, a ReportTaskResponse is still returned.  If multiple reasons want to be provided, they should be done at the same time. If multiple reports are given for the same latest started task, the note attribute will be overwritten, while the new unique reasons will be appended to the task attempt.  Task Report system contributions by client applications are immediately leveraged to aid yield management strategies. For those reasons, it\'s important that the respondent submits a Task Report as soon as possible and applications doesn\'t offload this request for a later time. Task Report timestamps are a critical component of understanding a Task experience for a respondent.  For the BP to tell us about a bad survey they want to report The POSTed data looks like:     {       \'bpuid\': \'1234\',       \'reasons\': [2],       \'notes\': \"This survey was the worst!\"     } Returns {\'status\': \'success\', \'msg\': error_msg}
         * @summary Report Task
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {ReportTask} reportTask 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportTaskProductIdReportPost: async (productId: string, reportTask: ReportTask, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('reportTaskProductIdReportPost', 'productId', productId)
            // verify required parameter 'reportTask' is not null or undefined
            assertParamExists('reportTaskProductIdReportPost', 'reportTask', reportTask)
            const localVarPath = `/{product_id}/report/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reportTask, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportApi - functional programming interface
 * @export
 */
export const ReportApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReportApiAxiosParamCreator(configuration)
    return {
        /**
         * Send a \"Task Report\" for a respondent\'s latest started survey, regardless of the survey\'s outcome. Task Reports cannot be provided for task attempts by tsid, or through any other method, they must be given immediately after the respondent\'s task attempt.  If a latest attempt can\'t be found, a ReportTaskResponse is still returned.  If multiple reasons want to be provided, they should be done at the same time. If multiple reports are given for the same latest started task, the note attribute will be overwritten, while the new unique reasons will be appended to the task attempt.  Task Report system contributions by client applications are immediately leveraged to aid yield management strategies. For those reasons, it\'s important that the respondent submits a Task Report as soon as possible and applications doesn\'t offload this request for a later time. Task Report timestamps are a critical component of understanding a Task experience for a respondent.  For the BP to tell us about a bad survey they want to report The POSTed data looks like:     {       \'bpuid\': \'1234\',       \'reasons\': [2],       \'notes\': \"This survey was the worst!\"     } Returns {\'status\': \'success\', \'msg\': error_msg}
         * @summary Report Task
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {ReportTask} reportTask 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportTaskProductIdReportPost(productId: string, reportTask: ReportTask, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportTaskProductIdReportPost(productId, reportTask, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ReportApi.reportTaskProductIdReportPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ReportApi - factory interface
 * @export
 */
export const ReportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReportApiFp(configuration)
    return {
        /**
         * Send a \"Task Report\" for a respondent\'s latest started survey, regardless of the survey\'s outcome. Task Reports cannot be provided for task attempts by tsid, or through any other method, they must be given immediately after the respondent\'s task attempt.  If a latest attempt can\'t be found, a ReportTaskResponse is still returned.  If multiple reasons want to be provided, they should be done at the same time. If multiple reports are given for the same latest started task, the note attribute will be overwritten, while the new unique reasons will be appended to the task attempt.  Task Report system contributions by client applications are immediately leveraged to aid yield management strategies. For those reasons, it\'s important that the respondent submits a Task Report as soon as possible and applications doesn\'t offload this request for a later time. Task Report timestamps are a critical component of understanding a Task experience for a respondent.  For the BP to tell us about a bad survey they want to report The POSTed data looks like:     {       \'bpuid\': \'1234\',       \'reasons\': [2],       \'notes\': \"This survey was the worst!\"     } Returns {\'status\': \'success\', \'msg\': error_msg}
         * @summary Report Task
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {ReportTask} reportTask 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportTaskProductIdReportPost(productId: string, reportTask: ReportTask, options?: RawAxiosRequestConfig): AxiosPromise<StatusResponse> {
            return localVarFp.reportTaskProductIdReportPost(productId, reportTask, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReportApi - object-oriented interface
 * @export
 * @class ReportApi
 * @extends {BaseAPI}
 */
export class ReportApi extends BaseAPI {
    /**
     * Send a \"Task Report\" for a respondent\'s latest started survey, regardless of the survey\'s outcome. Task Reports cannot be provided for task attempts by tsid, or through any other method, they must be given immediately after the respondent\'s task attempt.  If a latest attempt can\'t be found, a ReportTaskResponse is still returned.  If multiple reasons want to be provided, they should be done at the same time. If multiple reports are given for the same latest started task, the note attribute will be overwritten, while the new unique reasons will be appended to the task attempt.  Task Report system contributions by client applications are immediately leveraged to aid yield management strategies. For those reasons, it\'s important that the respondent submits a Task Report as soon as possible and applications doesn\'t offload this request for a later time. Task Report timestamps are a critical component of understanding a Task experience for a respondent.  For the BP to tell us about a bad survey they want to report The POSTed data looks like:     {       \'bpuid\': \'1234\',       \'reasons\': [2],       \'notes\': \"This survey was the worst!\"     } Returns {\'status\': \'success\', \'msg\': error_msg}
     * @summary Report Task
     * @param {string} productId The Brokerage Product ID provided by GRL.
     * @param {ReportTask} reportTask 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public reportTaskProductIdReportPost(productId: string, reportTask: ReportTask, options?: RawAxiosRequestConfig) {
        return ReportApiFp(this.configuration).reportTaskProductIdReportPost(productId, reportTask, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StatusApi - axios parameter creator
 * @export
 */
export const StatusApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve the status of a session by a specific Task Status ID (`tsid`) that is provided in the redirect.  Given a `tsid`, get back the status of the wall event. This endpoint conflates the idea of a wall event and a session, but for these purposes, the status and payout of the last wall event in a session equals the status and payout for the session.
         * @summary Get Task Status
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} tsid A unique identifier for the session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskStatusProductIdStatusTsidGet: async (productId: string, tsid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getTaskStatusProductIdStatusTsidGet', 'productId', productId)
            // verify required parameter 'tsid' is not null or undefined
            assertParamExists('getTaskStatusProductIdStatusTsidGet', 'tsid', tsid)
            const localVarPath = `/{product_id}/status/{tsid}/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"tsid"}}`, encodeURIComponent(String(tsid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Task Statuses
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} [bpuid] A unique identifier for each user, which is set by the Supplier. Filters the returned task status to only include those done by this user.
         * @param {number} [startedAfter] (unix timestamp) Retrieve sessions which were started after this timestamp. If &#x60;NULL&#x60;, default is 10 days ago.
         * @param {number} [startedBefore] (unix timestamp) Retrieve sessions which were started before this timestamp. If &#x60;NULL&#x60;, default is now.
         * @param {number} [status] Filter for sessions with this status. See Task Status for description of status.
         * @param {boolean} [reconciled] Only retrieve sessions that have been adjusted. If &#x60;reconciled&#x60; is True, &#x60;adjusted_after&#x60; is required.
         * @param {number} [adjustedAfter] (unix timestamp) Retrieve sessions which were adjusted after this timestamp.
         * @param {number} [adjustedBefore] (unix timestamp) Retrieve sessions which were adjusted before this timestamp. Default is now.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTaskStatusesProductIdStatusGet: async (productId: string, bpuid?: string, startedAfter?: number, startedBefore?: number, status?: number, reconciled?: boolean, adjustedAfter?: number, adjustedBefore?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('listTaskStatusesProductIdStatusGet', 'productId', productId)
            const localVarPath = `/{product_id}/status/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (bpuid !== undefined) {
                localVarQueryParameter['bpuid'] = bpuid;
            }

            if (startedAfter !== undefined) {
                localVarQueryParameter['started_after'] = startedAfter;
            }

            if (startedBefore !== undefined) {
                localVarQueryParameter['started_before'] = startedBefore;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (reconciled !== undefined) {
                localVarQueryParameter['reconciled'] = reconciled;
            }

            if (adjustedAfter !== undefined) {
                localVarQueryParameter['adjusted_after'] = adjustedAfter;
            }

            if (adjustedBefore !== undefined) {
                localVarQueryParameter['adjusted_before'] = adjustedBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatusApi - functional programming interface
 * @export
 */
export const StatusApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatusApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve the status of a session by a specific Task Status ID (`tsid`) that is provided in the redirect.  Given a `tsid`, get back the status of the wall event. This endpoint conflates the idea of a wall event and a session, but for these purposes, the status and payout of the last wall event in a session equals the status and payout for the session.
         * @summary Get Task Status
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} tsid A unique identifier for the session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaskStatusProductIdStatusTsidGet(productId: string, tsid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskStatusResponseOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTaskStatusProductIdStatusTsidGet(productId, tsid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatusApi.getTaskStatusProductIdStatusTsidGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Task Statuses
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} [bpuid] A unique identifier for each user, which is set by the Supplier. Filters the returned task status to only include those done by this user.
         * @param {number} [startedAfter] (unix timestamp) Retrieve sessions which were started after this timestamp. If &#x60;NULL&#x60;, default is 10 days ago.
         * @param {number} [startedBefore] (unix timestamp) Retrieve sessions which were started before this timestamp. If &#x60;NULL&#x60;, default is now.
         * @param {number} [status] Filter for sessions with this status. See Task Status for description of status.
         * @param {boolean} [reconciled] Only retrieve sessions that have been adjusted. If &#x60;reconciled&#x60; is True, &#x60;adjusted_after&#x60; is required.
         * @param {number} [adjustedAfter] (unix timestamp) Retrieve sessions which were adjusted after this timestamp.
         * @param {number} [adjustedBefore] (unix timestamp) Retrieve sessions which were adjusted before this timestamp. Default is now.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTaskStatusesProductIdStatusGet(productId: string, bpuid?: string, startedAfter?: number, startedBefore?: number, status?: number, reconciled?: boolean, adjustedAfter?: number, adjustedBefore?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TasksStatusResponseOut>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTaskStatusesProductIdStatusGet(productId, bpuid, startedAfter, startedBefore, status, reconciled, adjustedAfter, adjustedBefore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatusApi.listTaskStatusesProductIdStatusGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StatusApi - factory interface
 * @export
 */
export const StatusApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatusApiFp(configuration)
    return {
        /**
         * Retrieve the status of a session by a specific Task Status ID (`tsid`) that is provided in the redirect.  Given a `tsid`, get back the status of the wall event. This endpoint conflates the idea of a wall event and a session, but for these purposes, the status and payout of the last wall event in a session equals the status and payout for the session.
         * @summary Get Task Status
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} tsid A unique identifier for the session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskStatusProductIdStatusTsidGet(productId: string, tsid: string, options?: RawAxiosRequestConfig): AxiosPromise<TaskStatusResponseOut> {
            return localVarFp.getTaskStatusProductIdStatusTsidGet(productId, tsid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Task Statuses
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} [bpuid] A unique identifier for each user, which is set by the Supplier. Filters the returned task status to only include those done by this user.
         * @param {number} [startedAfter] (unix timestamp) Retrieve sessions which were started after this timestamp. If &#x60;NULL&#x60;, default is 10 days ago.
         * @param {number} [startedBefore] (unix timestamp) Retrieve sessions which were started before this timestamp. If &#x60;NULL&#x60;, default is now.
         * @param {number} [status] Filter for sessions with this status. See Task Status for description of status.
         * @param {boolean} [reconciled] Only retrieve sessions that have been adjusted. If &#x60;reconciled&#x60; is True, &#x60;adjusted_after&#x60; is required.
         * @param {number} [adjustedAfter] (unix timestamp) Retrieve sessions which were adjusted after this timestamp.
         * @param {number} [adjustedBefore] (unix timestamp) Retrieve sessions which were adjusted before this timestamp. Default is now.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTaskStatusesProductIdStatusGet(productId: string, bpuid?: string, startedAfter?: number, startedBefore?: number, status?: number, reconciled?: boolean, adjustedAfter?: number, adjustedBefore?: number, options?: RawAxiosRequestConfig): AxiosPromise<TasksStatusResponseOut> {
            return localVarFp.listTaskStatusesProductIdStatusGet(productId, bpuid, startedAfter, startedBefore, status, reconciled, adjustedAfter, adjustedBefore, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatusApi - object-oriented interface
 * @export
 * @class StatusApi
 * @extends {BaseAPI}
 */
export class StatusApi extends BaseAPI {
    /**
     * Retrieve the status of a session by a specific Task Status ID (`tsid`) that is provided in the redirect.  Given a `tsid`, get back the status of the wall event. This endpoint conflates the idea of a wall event and a session, but for these purposes, the status and payout of the last wall event in a session equals the status and payout for the session.
     * @summary Get Task Status
     * @param {string} productId The Brokerage Product ID provided by GRL.
     * @param {string} tsid A unique identifier for the session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    public getTaskStatusProductIdStatusTsidGet(productId: string, tsid: string, options?: RawAxiosRequestConfig) {
        return StatusApiFp(this.configuration).getTaskStatusProductIdStatusTsidGet(productId, tsid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Task Statuses
     * @param {string} productId The Brokerage Product ID provided by GRL.
     * @param {string} [bpuid] A unique identifier for each user, which is set by the Supplier. Filters the returned task status to only include those done by this user.
     * @param {number} [startedAfter] (unix timestamp) Retrieve sessions which were started after this timestamp. If &#x60;NULL&#x60;, default is 10 days ago.
     * @param {number} [startedBefore] (unix timestamp) Retrieve sessions which were started before this timestamp. If &#x60;NULL&#x60;, default is now.
     * @param {number} [status] Filter for sessions with this status. See Task Status for description of status.
     * @param {boolean} [reconciled] Only retrieve sessions that have been adjusted. If &#x60;reconciled&#x60; is True, &#x60;adjusted_after&#x60; is required.
     * @param {number} [adjustedAfter] (unix timestamp) Retrieve sessions which were adjusted after this timestamp.
     * @param {number} [adjustedBefore] (unix timestamp) Retrieve sessions which were adjusted before this timestamp. Default is now.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    public listTaskStatusesProductIdStatusGet(productId: string, bpuid?: string, startedAfter?: number, startedBefore?: number, status?: number, reconciled?: boolean, adjustedAfter?: number, adjustedBefore?: number, options?: RawAxiosRequestConfig) {
        return StatusApiFp(this.configuration).listTaskStatusesProductIdStatusGet(productId, bpuid, startedAfter, startedBefore, status, reconciled, adjustedAfter, adjustedBefore, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WalletApi - axios parameter creator
 * @export
 */
export const WalletApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * A user can only have 1 unique Cashout Method of any type at a time (eg. they can\'t create multiple paypal payout methods). Cashout Methods cannot be edited, they can only be created or deleted. Creating different Cashout Methods will require type-dependent request data attributes in order to be successfully created.  Currently only creating paypal or Cash in Mail cashout methods are supported
         * @summary Create Cashout Method
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {Body} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCashoutMethodProductIdCashoutMethodsPost: async (productId: string, body: Body, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('createCashoutMethodProductIdCashoutMethodsPost', 'productId', productId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createCashoutMethodProductIdCashoutMethodsPost', 'body', body)
            const localVarPath = `/{product_id}/cashout_methods/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a cashout method
         * @summary Delete Cashout Method
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} cashoutMethodId The ID of the cashout method to delete
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCashoutMethodProductIdCashoutMethodsCashoutMethodIdDelete: async (productId: string, cashoutMethodId: string, bpuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('deleteCashoutMethodProductIdCashoutMethodsCashoutMethodIdDelete', 'productId', productId)
            // verify required parameter 'cashoutMethodId' is not null or undefined
            assertParamExists('deleteCashoutMethodProductIdCashoutMethodsCashoutMethodIdDelete', 'cashoutMethodId', cashoutMethodId)
            // verify required parameter 'bpuid' is not null or undefined
            assertParamExists('deleteCashoutMethodProductIdCashoutMethodsCashoutMethodIdDelete', 'bpuid', bpuid)
            const localVarPath = `/{product_id}/cashout_methods/{cashout_method_id}/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"cashout_method_id"}}`, encodeURIComponent(String(cashoutMethodId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (bpuid !== undefined) {
                localVarQueryParameter['bpuid'] = bpuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the details for a specific Cashout event
         * @summary Get Cashout Detail
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} cashoutId The cashout event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCashoutDetailProductIdCashoutCashoutIdGet: async (productId: string, cashoutId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getCashoutDetailProductIdCashoutCashoutIdGet', 'productId', productId)
            // verify required parameter 'cashoutId' is not null or undefined
            assertParamExists('getCashoutDetailProductIdCashoutCashoutIdGet', 'cashoutId', cashoutId)
            const localVarPath = `/{product_id}/cashout/{cashout_id}/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"cashout_id"}}`, encodeURIComponent(String(cashoutId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the current available mechanisms that a user can use to retrieve funds.
         * @summary Get Cashout Methods
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCashoutMethodsProductIdCashoutMethodsGet: async (productId: string, bpuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getCashoutMethodsProductIdCashoutMethodsGet', 'productId', productId)
            // verify required parameter 'bpuid' is not null or undefined
            assertParamExists('getCashoutMethodsProductIdCashoutMethodsGet', 'bpuid', bpuid)
            const localVarPath = `/{product_id}/cashout_methods/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (bpuid !== undefined) {
                localVarQueryParameter['bpuid'] = bpuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this function to get the \"value\" (in local currency, e.g. CAD, BTC) for this   cashout_method, for amount (in USD cents).
         * @summary Get Expected Redemption Value
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} cashoutMethodId The ID of the cashout method
         * @param {number} amount (USD cents) The amount to convert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpectedRedemptionValueProductIdCashoutMethodCashoutMethodIdValueGet: async (productId: string, cashoutMethodId: string, amount: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getExpectedRedemptionValueProductIdCashoutMethodCashoutMethodIdValueGet', 'productId', productId)
            // verify required parameter 'cashoutMethodId' is not null or undefined
            assertParamExists('getExpectedRedemptionValueProductIdCashoutMethodCashoutMethodIdValueGet', 'cashoutMethodId', cashoutMethodId)
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('getExpectedRedemptionValueProductIdCashoutMethodCashoutMethodIdValueGet', 'amount', amount)
            const localVarPath = `/{product_id}/cashout_method/{cashout_method_id}/value/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"cashout_method_id"}}`, encodeURIComponent(String(cashoutMethodId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return array of user events that altered their wallet balance
         * @summary Get User Transaction History
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTransactionHistoryProductIdTransactionHistoryGet: async (productId: string, bpuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getUserTransactionHistoryProductIdTransactionHistoryGet', 'productId', productId)
            // verify required parameter 'bpuid' is not null or undefined
            assertParamExists('getUserTransactionHistoryProductIdTransactionHistoryGet', 'bpuid', bpuid)
            const localVarPath = `/{product_id}/transaction_history/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (bpuid !== undefined) {
                localVarQueryParameter['bpuid'] = bpuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the current balance of a respondent\'s wallet balance for display
         * @summary Get User Wallet Balance
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletBalanceProductIdWalletGet: async (productId: string, bpuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('getUserWalletBalanceProductIdWalletGet', 'productId', productId)
            // verify required parameter 'bpuid' is not null or undefined
            assertParamExists('getUserWalletBalanceProductIdWalletGet', 'bpuid', bpuid)
            const localVarPath = `/{product_id}/wallet/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (bpuid !== undefined) {
                localVarQueryParameter['bpuid'] = bpuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request a cashout taken from a user\'s available wallet balance, to be paid via a particular cashout method.
         * @summary Submit User Cashout
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {CreateCashoutRequest} createCashoutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitUserCashoutProductIdCashoutPost: async (productId: string, createCashoutRequest: CreateCashoutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('submitUserCashoutProductIdCashoutPost', 'productId', productId)
            // verify required parameter 'createCashoutRequest' is not null or undefined
            assertParamExists('submitUserCashoutProductIdCashoutPost', 'createCashoutRequest', createCashoutRequest)
            const localVarPath = `/{product_id}/cashout/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCashoutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WalletApi - functional programming interface
 * @export
 */
export const WalletApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WalletApiAxiosParamCreator(configuration)
    return {
        /**
         * A user can only have 1 unique Cashout Method of any type at a time (eg. they can\'t create multiple paypal payout methods). Cashout Methods cannot be edited, they can only be created or deleted. Creating different Cashout Methods will require type-dependent request data attributes in order to be successfully created.  Currently only creating paypal or Cash in Mail cashout methods are supported
         * @summary Create Cashout Method
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {Body} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCashoutMethodProductIdCashoutMethodsPost(productId: string, body: Body, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CashoutMethodResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCashoutMethodProductIdCashoutMethodsPost(productId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletApi.createCashoutMethodProductIdCashoutMethodsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a cashout method
         * @summary Delete Cashout Method
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} cashoutMethodId The ID of the cashout method to delete
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCashoutMethodProductIdCashoutMethodsCashoutMethodIdDelete(productId: string, cashoutMethodId: string, bpuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCashoutMethodProductIdCashoutMethodsCashoutMethodIdDelete(productId, cashoutMethodId, bpuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletApi.deleteCashoutMethodProductIdCashoutMethodsCashoutMethodIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the details for a specific Cashout event
         * @summary Get Cashout Detail
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} cashoutId The cashout event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCashoutDetailProductIdCashoutCashoutIdGet(productId: string, cashoutId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CashoutRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCashoutDetailProductIdCashoutCashoutIdGet(productId, cashoutId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletApi.getCashoutDetailProductIdCashoutCashoutIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the current available mechanisms that a user can use to retrieve funds.
         * @summary Get Cashout Methods
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCashoutMethodsProductIdCashoutMethodsGet(productId: string, bpuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CashoutMethodsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCashoutMethodsProductIdCashoutMethodsGet(productId, bpuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletApi.getCashoutMethodsProductIdCashoutMethodsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this function to get the \"value\" (in local currency, e.g. CAD, BTC) for this   cashout_method, for amount (in USD cents).
         * @summary Get Expected Redemption Value
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} cashoutMethodId The ID of the cashout method
         * @param {number} amount (USD cents) The amount to convert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExpectedRedemptionValueProductIdCashoutMethodCashoutMethodIdValueGet(productId: string, cashoutMethodId: string, amount: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CashoutMethodForeignValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExpectedRedemptionValueProductIdCashoutMethodCashoutMethodIdValueGet(productId, cashoutMethodId, amount, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletApi.getExpectedRedemptionValueProductIdCashoutMethodCashoutMethodIdValueGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Return array of user events that altered their wallet balance
         * @summary Get User Transaction History
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTransactionHistoryProductIdTransactionHistoryGet(productId: string, bpuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTransactionHistoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTransactionHistoryProductIdTransactionHistoryGet(productId, bpuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletApi.getUserTransactionHistoryProductIdTransactionHistoryGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the current balance of a respondent\'s wallet balance for display
         * @summary Get User Wallet Balance
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserWalletBalanceProductIdWalletGet(productId: string, bpuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserWalletBalanceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserWalletBalanceProductIdWalletGet(productId, bpuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletApi.getUserWalletBalanceProductIdWalletGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Request a cashout taken from a user\'s available wallet balance, to be paid via a particular cashout method.
         * @summary Submit User Cashout
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {CreateCashoutRequest} createCashoutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitUserCashoutProductIdCashoutPost(productId: string, createCashoutRequest: CreateCashoutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CashoutRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitUserCashoutProductIdCashoutPost(productId, createCashoutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletApi.submitUserCashoutProductIdCashoutPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WalletApi - factory interface
 * @export
 */
export const WalletApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WalletApiFp(configuration)
    return {
        /**
         * A user can only have 1 unique Cashout Method of any type at a time (eg. they can\'t create multiple paypal payout methods). Cashout Methods cannot be edited, they can only be created or deleted. Creating different Cashout Methods will require type-dependent request data attributes in order to be successfully created.  Currently only creating paypal or Cash in Mail cashout methods are supported
         * @summary Create Cashout Method
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {Body} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCashoutMethodProductIdCashoutMethodsPost(productId: string, body: Body, options?: RawAxiosRequestConfig): AxiosPromise<CashoutMethodResponse> {
            return localVarFp.createCashoutMethodProductIdCashoutMethodsPost(productId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a cashout method
         * @summary Delete Cashout Method
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} cashoutMethodId The ID of the cashout method to delete
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCashoutMethodProductIdCashoutMethodsCashoutMethodIdDelete(productId: string, cashoutMethodId: string, bpuid: string, options?: RawAxiosRequestConfig): AxiosPromise<StatusResponse> {
            return localVarFp.deleteCashoutMethodProductIdCashoutMethodsCashoutMethodIdDelete(productId, cashoutMethodId, bpuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the details for a specific Cashout event
         * @summary Get Cashout Detail
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} cashoutId The cashout event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCashoutDetailProductIdCashoutCashoutIdGet(productId: string, cashoutId: string, options?: RawAxiosRequestConfig): AxiosPromise<CashoutRequestResponse> {
            return localVarFp.getCashoutDetailProductIdCashoutCashoutIdGet(productId, cashoutId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the current available mechanisms that a user can use to retrieve funds.
         * @summary Get Cashout Methods
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCashoutMethodsProductIdCashoutMethodsGet(productId: string, bpuid: string, options?: RawAxiosRequestConfig): AxiosPromise<CashoutMethodsResponse> {
            return localVarFp.getCashoutMethodsProductIdCashoutMethodsGet(productId, bpuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this function to get the \"value\" (in local currency, e.g. CAD, BTC) for this   cashout_method, for amount (in USD cents).
         * @summary Get Expected Redemption Value
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} cashoutMethodId The ID of the cashout method
         * @param {number} amount (USD cents) The amount to convert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpectedRedemptionValueProductIdCashoutMethodCashoutMethodIdValueGet(productId: string, cashoutMethodId: string, amount: number, options?: RawAxiosRequestConfig): AxiosPromise<CashoutMethodForeignValueResponse> {
            return localVarFp.getExpectedRedemptionValueProductIdCashoutMethodCashoutMethodIdValueGet(productId, cashoutMethodId, amount, options).then((request) => request(axios, basePath));
        },
        /**
         * Return array of user events that altered their wallet balance
         * @summary Get User Transaction History
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTransactionHistoryProductIdTransactionHistoryGet(productId: string, bpuid: string, options?: RawAxiosRequestConfig): AxiosPromise<UserTransactionHistoryResponse> {
            return localVarFp.getUserTransactionHistoryProductIdTransactionHistoryGet(productId, bpuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the current balance of a respondent\'s wallet balance for display
         * @summary Get User Wallet Balance
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletBalanceProductIdWalletGet(productId: string, bpuid: string, options?: RawAxiosRequestConfig): AxiosPromise<UserWalletBalanceResponse> {
            return localVarFp.getUserWalletBalanceProductIdWalletGet(productId, bpuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Request a cashout taken from a user\'s available wallet balance, to be paid via a particular cashout method.
         * @summary Submit User Cashout
         * @param {string} productId The Brokerage Product ID provided by GRL.
         * @param {CreateCashoutRequest} createCashoutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitUserCashoutProductIdCashoutPost(productId: string, createCashoutRequest: CreateCashoutRequest, options?: RawAxiosRequestConfig): AxiosPromise<CashoutRequestResponse> {
            return localVarFp.submitUserCashoutProductIdCashoutPost(productId, createCashoutRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WalletApi - object-oriented interface
 * @export
 * @class WalletApi
 * @extends {BaseAPI}
 */
export class WalletApi extends BaseAPI {
    /**
     * A user can only have 1 unique Cashout Method of any type at a time (eg. they can\'t create multiple paypal payout methods). Cashout Methods cannot be edited, they can only be created or deleted. Creating different Cashout Methods will require type-dependent request data attributes in order to be successfully created.  Currently only creating paypal or Cash in Mail cashout methods are supported
     * @summary Create Cashout Method
     * @param {string} productId The Brokerage Product ID provided by GRL.
     * @param {Body} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public createCashoutMethodProductIdCashoutMethodsPost(productId: string, body: Body, options?: RawAxiosRequestConfig) {
        return WalletApiFp(this.configuration).createCashoutMethodProductIdCashoutMethodsPost(productId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a cashout method
     * @summary Delete Cashout Method
     * @param {string} productId The Brokerage Product ID provided by GRL.
     * @param {string} cashoutMethodId The ID of the cashout method to delete
     * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public deleteCashoutMethodProductIdCashoutMethodsCashoutMethodIdDelete(productId: string, cashoutMethodId: string, bpuid: string, options?: RawAxiosRequestConfig) {
        return WalletApiFp(this.configuration).deleteCashoutMethodProductIdCashoutMethodsCashoutMethodIdDelete(productId, cashoutMethodId, bpuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the details for a specific Cashout event
     * @summary Get Cashout Detail
     * @param {string} productId The Brokerage Product ID provided by GRL.
     * @param {string} cashoutId The cashout event ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public getCashoutDetailProductIdCashoutCashoutIdGet(productId: string, cashoutId: string, options?: RawAxiosRequestConfig) {
        return WalletApiFp(this.configuration).getCashoutDetailProductIdCashoutCashoutIdGet(productId, cashoutId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the current available mechanisms that a user can use to retrieve funds.
     * @summary Get Cashout Methods
     * @param {string} productId The Brokerage Product ID provided by GRL.
     * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public getCashoutMethodsProductIdCashoutMethodsGet(productId: string, bpuid: string, options?: RawAxiosRequestConfig) {
        return WalletApiFp(this.configuration).getCashoutMethodsProductIdCashoutMethodsGet(productId, bpuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this function to get the \"value\" (in local currency, e.g. CAD, BTC) for this   cashout_method, for amount (in USD cents).
     * @summary Get Expected Redemption Value
     * @param {string} productId The Brokerage Product ID provided by GRL.
     * @param {string} cashoutMethodId The ID of the cashout method
     * @param {number} amount (USD cents) The amount to convert
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public getExpectedRedemptionValueProductIdCashoutMethodCashoutMethodIdValueGet(productId: string, cashoutMethodId: string, amount: number, options?: RawAxiosRequestConfig) {
        return WalletApiFp(this.configuration).getExpectedRedemptionValueProductIdCashoutMethodCashoutMethodIdValueGet(productId, cashoutMethodId, amount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return array of user events that altered their wallet balance
     * @summary Get User Transaction History
     * @param {string} productId The Brokerage Product ID provided by GRL.
     * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public getUserTransactionHistoryProductIdTransactionHistoryGet(productId: string, bpuid: string, options?: RawAxiosRequestConfig) {
        return WalletApiFp(this.configuration).getUserTransactionHistoryProductIdTransactionHistoryGet(productId, bpuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the current balance of a respondent\'s wallet balance for display
     * @summary Get User Wallet Balance
     * @param {string} productId The Brokerage Product ID provided by GRL.
     * @param {string} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public getUserWalletBalanceProductIdWalletGet(productId: string, bpuid: string, options?: RawAxiosRequestConfig) {
        return WalletApiFp(this.configuration).getUserWalletBalanceProductIdWalletGet(productId, bpuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request a cashout taken from a user\'s available wallet balance, to be paid via a particular cashout method.
     * @summary Submit User Cashout
     * @param {string} productId The Brokerage Product ID provided by GRL.
     * @param {CreateCashoutRequest} createCashoutRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public submitUserCashoutProductIdCashoutPost(productId: string, createCashoutRequest: CreateCashoutRequest, options?: RawAxiosRequestConfig) {
        return WalletApiFp(this.configuration).submitUserCashoutProductIdCashoutPost(productId, createCashoutRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



