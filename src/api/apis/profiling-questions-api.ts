/* tslint:disable */
/* eslint-disable */
/**
 * General Research Full Service Brokerage API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { BodySubmitProfilingQuestionsProductIdProfilingQuestionsPost } from '../models';
import { HTTPValidationError } from '../models';
import { ProfilingInfoResponse } from '../models';
import { StatusResponse } from '../models';
import { UpkQuestionResponse } from '../models';
import { UserInfoResponse } from '../models';
/**
 * ProfilingQuestionsApi - axios parameter creator
 * @export
 */
export const ProfilingQuestionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets a list of profiling questions to ask this user. These questions are, as of right now, unanswered. Once a question is answered, it (and any other question whose answer is inferred from other answers) is removed from the list. The questions returned are ordered by importance (the key task_score) in descending order.
         * @summary Get Profiling Questions
         * @param {any} productId The Brokerage Product ID provided by GRL.
         * @param {any} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {any} [ip] Respondent&#x27;s IP address (IPv4 or IPv6). Either &#x27;ip&#x27; must be provided, or &#x27;country_iso&#x27; must be provided if &#x27;ip&#x27; is not provided.
         * @param {any} [countryIso] Respondent&#x27;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {any} [languageIso] Respondent&#x27;s desired language (ISO 639-2/B, lowercase)
         * @param {any} [limit] Number of questions to return. Questions are ordered, so, selects the N most important. If no limit is passed, then the number of questions returned is dynamically calculated by the questions&#x27; importance.
         * @param {any} [isGrs] If it&#x27;s the GRS system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfilingQuestionsProductIdProfilingQuestionsGet: async (productId: any, bpuid: any, ip?: any, countryIso?: any, languageIso?: any, limit?: any, isGrs?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling getProfilingQuestionsProductIdProfilingQuestionsGet.');
            }
            // verify required parameter 'bpuid' is not null or undefined
            if (bpuid === null || bpuid === undefined) {
                throw new RequiredError('bpuid','Required parameter bpuid was null or undefined when calling getProfilingQuestionsProductIdProfilingQuestionsGet.');
            }
            const localVarPath = `/{product_id}/profiling-questions/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (bpuid !== undefined) {
                localVarQueryParameter['bpuid'] = bpuid;
            }

            if (ip !== undefined) {
                localVarQueryParameter['ip'] = ip;
            }

            if (countryIso !== undefined) {
                localVarQueryParameter['country_iso'] = countryIso;
            }

            if (languageIso !== undefined) {
                localVarQueryParameter['language_iso'] = languageIso;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (isGrs !== undefined) {
                localVarQueryParameter['is_grs'] = isGrs;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get UPK Ontology (list of properties, property info, and allowed values)
         * @summary Profiling Info
         * @param {any} productId The Brokerage Product ID provided by GRL.
         * @param {any} countryIso Respondent&#x27;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {any} [languageIso] Respondent&#x27;s desired language (ISO 639-2/B, lowercase)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profilingInfoProductIdProfilingInfoGet: async (productId: any, countryIso: any, languageIso?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling profilingInfoProductIdProfilingInfoGet.');
            }
            // verify required parameter 'countryIso' is not null or undefined
            if (countryIso === null || countryIso === undefined) {
                throw new RequiredError('countryIso','Required parameter countryIso was null or undefined when calling profilingInfoProductIdProfilingInfoGet.');
            }
            const localVarPath = `/{product_id}/profiling-info/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (countryIso !== undefined) {
                localVarQueryParameter['country_iso'] = countryIso;
            }

            if (languageIso !== undefined) {
                localVarQueryParameter['language_iso'] = languageIso;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Send the answers to one or more of these questions for a user. A question is uniquely specified by the question_id key. The answer is: the choice_id if the question_type is \"MC\" the actual entered text if the question_type is \"TE\"
         * @summary Submit Profiling Questions
         * @param {BodySubmitProfilingQuestionsProductIdProfilingQuestionsPost} body 
         * @param {any} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {any} productId The Brokerage Product ID provided by GRL.
         * @param {any} [sessionId] The unique identifier for a session in which these questions were asked. Must be a valid UUID. Optional.
         * @param {any} [async] For internal use.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitProfilingQuestionsProductIdProfilingQuestionsPost: async (body: BodySubmitProfilingQuestionsProductIdProfilingQuestionsPost, bpuid: any, productId: any, sessionId?: any, async?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling submitProfilingQuestionsProductIdProfilingQuestionsPost.');
            }
            // verify required parameter 'bpuid' is not null or undefined
            if (bpuid === null || bpuid === undefined) {
                throw new RequiredError('bpuid','Required parameter bpuid was null or undefined when calling submitProfilingQuestionsProductIdProfilingQuestionsPost.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling submitProfilingQuestionsProductIdProfilingQuestionsPost.');
            }
            const localVarPath = `/{product_id}/profiling-questions/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (bpuid !== undefined) {
                localVarQueryParameter['bpuid'] = bpuid;
            }

            if (sessionId !== undefined) {
                localVarQueryParameter['session_id'] = sessionId;
            }

            if (async !== undefined) {
                localVarQueryParameter['async'] = async;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Profile
         * @param {any} productId The Brokerage Product ID provided by GRL.
         * @param {any} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {any} countryIso Respondent&#x27;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {any} [languageIso] Respondent&#x27;s desired language (ISO 639-2/B, lowercase)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userProfileProductIdUserProfileGet: async (productId: any, bpuid: any, countryIso: any, languageIso?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling userProfileProductIdUserProfileGet.');
            }
            // verify required parameter 'bpuid' is not null or undefined
            if (bpuid === null || bpuid === undefined) {
                throw new RequiredError('bpuid','Required parameter bpuid was null or undefined when calling userProfileProductIdUserProfileGet.');
            }
            // verify required parameter 'countryIso' is not null or undefined
            if (countryIso === null || countryIso === undefined) {
                throw new RequiredError('countryIso','Required parameter countryIso was null or undefined when calling userProfileProductIdUserProfileGet.');
            }
            const localVarPath = `/{product_id}/user-profile/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (bpuid !== undefined) {
                localVarQueryParameter['bpuid'] = bpuid;
            }

            if (countryIso !== undefined) {
                localVarQueryParameter['country_iso'] = countryIso;
            }

            if (languageIso !== undefined) {
                localVarQueryParameter['language_iso'] = languageIso;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfilingQuestionsApi - functional programming interface
 * @export
 */
export const ProfilingQuestionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Gets a list of profiling questions to ask this user. These questions are, as of right now, unanswered. Once a question is answered, it (and any other question whose answer is inferred from other answers) is removed from the list. The questions returned are ordered by importance (the key task_score) in descending order.
         * @summary Get Profiling Questions
         * @param {any} productId The Brokerage Product ID provided by GRL.
         * @param {any} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {any} [ip] Respondent&#x27;s IP address (IPv4 or IPv6). Either &#x27;ip&#x27; must be provided, or &#x27;country_iso&#x27; must be provided if &#x27;ip&#x27; is not provided.
         * @param {any} [countryIso] Respondent&#x27;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {any} [languageIso] Respondent&#x27;s desired language (ISO 639-2/B, lowercase)
         * @param {any} [limit] Number of questions to return. Questions are ordered, so, selects the N most important. If no limit is passed, then the number of questions returned is dynamically calculated by the questions&#x27; importance.
         * @param {any} [isGrs] If it&#x27;s the GRS system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfilingQuestionsProductIdProfilingQuestionsGet(productId: any, bpuid: any, ip?: any, countryIso?: any, languageIso?: any, limit?: any, isGrs?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<UpkQuestionResponse>>> {
            const localVarAxiosArgs = await ProfilingQuestionsApiAxiosParamCreator(configuration).getProfilingQuestionsProductIdProfilingQuestionsGet(productId, bpuid, ip, countryIso, languageIso, limit, isGrs, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get UPK Ontology (list of properties, property info, and allowed values)
         * @summary Profiling Info
         * @param {any} productId The Brokerage Product ID provided by GRL.
         * @param {any} countryIso Respondent&#x27;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {any} [languageIso] Respondent&#x27;s desired language (ISO 639-2/B, lowercase)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profilingInfoProductIdProfilingInfoGet(productId: any, countryIso: any, languageIso?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ProfilingInfoResponse>>> {
            const localVarAxiosArgs = await ProfilingQuestionsApiAxiosParamCreator(configuration).profilingInfoProductIdProfilingInfoGet(productId, countryIso, languageIso, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Send the answers to one or more of these questions for a user. A question is uniquely specified by the question_id key. The answer is: the choice_id if the question_type is \"MC\" the actual entered text if the question_type is \"TE\"
         * @summary Submit Profiling Questions
         * @param {BodySubmitProfilingQuestionsProductIdProfilingQuestionsPost} body 
         * @param {any} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {any} productId The Brokerage Product ID provided by GRL.
         * @param {any} [sessionId] The unique identifier for a session in which these questions were asked. Must be a valid UUID. Optional.
         * @param {any} [async] For internal use.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitProfilingQuestionsProductIdProfilingQuestionsPost(body: BodySubmitProfilingQuestionsProductIdProfilingQuestionsPost, bpuid: any, productId: any, sessionId?: any, async?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<StatusResponse>>> {
            const localVarAxiosArgs = await ProfilingQuestionsApiAxiosParamCreator(configuration).submitProfilingQuestionsProductIdProfilingQuestionsPost(body, bpuid, productId, sessionId, async, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary User Profile
         * @param {any} productId The Brokerage Product ID provided by GRL.
         * @param {any} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {any} countryIso Respondent&#x27;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {any} [languageIso] Respondent&#x27;s desired language (ISO 639-2/B, lowercase)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userProfileProductIdUserProfileGet(productId: any, bpuid: any, countryIso: any, languageIso?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<UserInfoResponse>>> {
            const localVarAxiosArgs = await ProfilingQuestionsApiAxiosParamCreator(configuration).userProfileProductIdUserProfileGet(productId, bpuid, countryIso, languageIso, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ProfilingQuestionsApi - factory interface
 * @export
 */
export const ProfilingQuestionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Gets a list of profiling questions to ask this user. These questions are, as of right now, unanswered. Once a question is answered, it (and any other question whose answer is inferred from other answers) is removed from the list. The questions returned are ordered by importance (the key task_score) in descending order.
         * @summary Get Profiling Questions
         * @param {any} productId The Brokerage Product ID provided by GRL.
         * @param {any} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {any} [ip] Respondent&#x27;s IP address (IPv4 or IPv6). Either &#x27;ip&#x27; must be provided, or &#x27;country_iso&#x27; must be provided if &#x27;ip&#x27; is not provided.
         * @param {any} [countryIso] Respondent&#x27;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {any} [languageIso] Respondent&#x27;s desired language (ISO 639-2/B, lowercase)
         * @param {any} [limit] Number of questions to return. Questions are ordered, so, selects the N most important. If no limit is passed, then the number of questions returned is dynamically calculated by the questions&#x27; importance.
         * @param {any} [isGrs] If it&#x27;s the GRS system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfilingQuestionsProductIdProfilingQuestionsGet(productId: any, bpuid: any, ip?: any, countryIso?: any, languageIso?: any, limit?: any, isGrs?: any, options?: AxiosRequestConfig): Promise<AxiosResponse<UpkQuestionResponse>> {
            return ProfilingQuestionsApiFp(configuration).getProfilingQuestionsProductIdProfilingQuestionsGet(productId, bpuid, ip, countryIso, languageIso, limit, isGrs, options).then((request) => request(axios, basePath));
        },
        /**
         * Get UPK Ontology (list of properties, property info, and allowed values)
         * @summary Profiling Info
         * @param {any} productId The Brokerage Product ID provided by GRL.
         * @param {any} countryIso Respondent&#x27;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {any} [languageIso] Respondent&#x27;s desired language (ISO 639-2/B, lowercase)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profilingInfoProductIdProfilingInfoGet(productId: any, countryIso: any, languageIso?: any, options?: AxiosRequestConfig): Promise<AxiosResponse<ProfilingInfoResponse>> {
            return ProfilingQuestionsApiFp(configuration).profilingInfoProductIdProfilingInfoGet(productId, countryIso, languageIso, options).then((request) => request(axios, basePath));
        },
        /**
         * Send the answers to one or more of these questions for a user. A question is uniquely specified by the question_id key. The answer is: the choice_id if the question_type is \"MC\" the actual entered text if the question_type is \"TE\"
         * @summary Submit Profiling Questions
         * @param {BodySubmitProfilingQuestionsProductIdProfilingQuestionsPost} body 
         * @param {any} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {any} productId The Brokerage Product ID provided by GRL.
         * @param {any} [sessionId] The unique identifier for a session in which these questions were asked. Must be a valid UUID. Optional.
         * @param {any} [async] For internal use.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitProfilingQuestionsProductIdProfilingQuestionsPost(body: BodySubmitProfilingQuestionsProductIdProfilingQuestionsPost, bpuid: any, productId: any, sessionId?: any, async?: any, options?: AxiosRequestConfig): Promise<AxiosResponse<StatusResponse>> {
            return ProfilingQuestionsApiFp(configuration).submitProfilingQuestionsProductIdProfilingQuestionsPost(body, bpuid, productId, sessionId, async, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary User Profile
         * @param {any} productId The Brokerage Product ID provided by GRL.
         * @param {any} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {any} countryIso Respondent&#x27;s country code (ISO 3166-1 alpha-2, lowercase)
         * @param {any} [languageIso] Respondent&#x27;s desired language (ISO 639-2/B, lowercase)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userProfileProductIdUserProfileGet(productId: any, bpuid: any, countryIso: any, languageIso?: any, options?: AxiosRequestConfig): Promise<AxiosResponse<UserInfoResponse>> {
            return ProfilingQuestionsApiFp(configuration).userProfileProductIdUserProfileGet(productId, bpuid, countryIso, languageIso, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProfilingQuestionsApi - object-oriented interface
 * @export
 * @class ProfilingQuestionsApi
 * @extends {BaseAPI}
 */
export class ProfilingQuestionsApi extends BaseAPI {
    /**
     * Gets a list of profiling questions to ask this user. These questions are, as of right now, unanswered. Once a question is answered, it (and any other question whose answer is inferred from other answers) is removed from the list. The questions returned are ordered by importance (the key task_score) in descending order.
     * @summary Get Profiling Questions
     * @param {any} productId The Brokerage Product ID provided by GRL.
     * @param {any} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
     * @param {any} [ip] Respondent&#x27;s IP address (IPv4 or IPv6). Either &#x27;ip&#x27; must be provided, or &#x27;country_iso&#x27; must be provided if &#x27;ip&#x27; is not provided.
     * @param {any} [countryIso] Respondent&#x27;s country code (ISO 3166-1 alpha-2, lowercase)
     * @param {any} [languageIso] Respondent&#x27;s desired language (ISO 639-2/B, lowercase)
     * @param {any} [limit] Number of questions to return. Questions are ordered, so, selects the N most important. If no limit is passed, then the number of questions returned is dynamically calculated by the questions&#x27; importance.
     * @param {any} [isGrs] If it&#x27;s the GRS system.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilingQuestionsApi
     */
    public async getProfilingQuestionsProductIdProfilingQuestionsGet(productId: any, bpuid: any, ip?: any, countryIso?: any, languageIso?: any, limit?: any, isGrs?: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<UpkQuestionResponse>> {
        return ProfilingQuestionsApiFp(this.configuration).getProfilingQuestionsProductIdProfilingQuestionsGet(productId, bpuid, ip, countryIso, languageIso, limit, isGrs, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get UPK Ontology (list of properties, property info, and allowed values)
     * @summary Profiling Info
     * @param {any} productId The Brokerage Product ID provided by GRL.
     * @param {any} countryIso Respondent&#x27;s country code (ISO 3166-1 alpha-2, lowercase)
     * @param {any} [languageIso] Respondent&#x27;s desired language (ISO 639-2/B, lowercase)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilingQuestionsApi
     */
    public async profilingInfoProductIdProfilingInfoGet(productId: any, countryIso: any, languageIso?: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<ProfilingInfoResponse>> {
        return ProfilingQuestionsApiFp(this.configuration).profilingInfoProductIdProfilingInfoGet(productId, countryIso, languageIso, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Send the answers to one or more of these questions for a user. A question is uniquely specified by the question_id key. The answer is: the choice_id if the question_type is \"MC\" the actual entered text if the question_type is \"TE\"
     * @summary Submit Profiling Questions
     * @param {BodySubmitProfilingQuestionsProductIdProfilingQuestionsPost} body 
     * @param {any} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
     * @param {any} productId The Brokerage Product ID provided by GRL.
     * @param {any} [sessionId] The unique identifier for a session in which these questions were asked. Must be a valid UUID. Optional.
     * @param {any} [async] For internal use.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilingQuestionsApi
     */
    public async submitProfilingQuestionsProductIdProfilingQuestionsPost(body: BodySubmitProfilingQuestionsProductIdProfilingQuestionsPost, bpuid: any, productId: any, sessionId?: any, async?: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<StatusResponse>> {
        return ProfilingQuestionsApiFp(this.configuration).submitProfilingQuestionsProductIdProfilingQuestionsPost(body, bpuid, productId, sessionId, async, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary User Profile
     * @param {any} productId The Brokerage Product ID provided by GRL.
     * @param {any} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
     * @param {any} countryIso Respondent&#x27;s country code (ISO 3166-1 alpha-2, lowercase)
     * @param {any} [languageIso] Respondent&#x27;s desired language (ISO 639-2/B, lowercase)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilingQuestionsApi
     */
    public async userProfileProductIdUserProfileGet(productId: any, bpuid: any, countryIso: any, languageIso?: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<UserInfoResponse>> {
        return ProfilingQuestionsApiFp(this.configuration).userProfileProductIdUserProfileGet(productId, bpuid, countryIso, languageIso, options).then((request) => request(this.axios, this.basePath));
    }
}
