/* tslint:disable */
/* eslint-disable */
/**
 * General Research Full Service Brokerage API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { CashoutMethodForeignValueResponse } from '../models';
import { CashoutMethodResponse } from '../models';
import { CashoutMethodsResponse } from '../models';
import { CashoutRequestResponse } from '../models';
import { CreateCashoutRequest } from '../models';
import { HTTPValidationError } from '../models';
import { StatusResponse } from '../models';
import { UserTransactionHistoryResponse } from '../models';
import { UserWalletBalanceResponse } from '../models';
/**
 * WalletApi - axios parameter creator
 * @export
 */
export const WalletApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * A user can only have 1 unique Cashout Method of any type at a time (eg. they can't create multiple paypal payout methods). Cashout Methods cannot be edited, they can only be created or deleted. Creating different Cashout Methods will require type-dependent request data attributes in order to be successfully created.  Currently only creating paypal or Cash in Mail cashout methods are supported
         * @summary Create Cashout Method
         * @param {any} body 
         * @param {any} productId The Brokerage Product ID provided by GRL.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCashoutMethodProductIdCashoutMethodsPost: async (body: any, productId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createCashoutMethodProductIdCashoutMethodsPost.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling createCashoutMethodProductIdCashoutMethodsPost.');
            }
            const localVarPath = `/{product_id}/cashout_methods/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a cashout method
         * @summary Delete Cashout Method
         * @param {any} productId The Brokerage Product ID provided by GRL.
         * @param {any} cashoutMethodId The ID of the cashout method to delete
         * @param {any} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCashoutMethodProductIdCashoutMethodsCashoutMethodIdDelete: async (productId: any, cashoutMethodId: any, bpuid: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling deleteCashoutMethodProductIdCashoutMethodsCashoutMethodIdDelete.');
            }
            // verify required parameter 'cashoutMethodId' is not null or undefined
            if (cashoutMethodId === null || cashoutMethodId === undefined) {
                throw new RequiredError('cashoutMethodId','Required parameter cashoutMethodId was null or undefined when calling deleteCashoutMethodProductIdCashoutMethodsCashoutMethodIdDelete.');
            }
            // verify required parameter 'bpuid' is not null or undefined
            if (bpuid === null || bpuid === undefined) {
                throw new RequiredError('bpuid','Required parameter bpuid was null or undefined when calling deleteCashoutMethodProductIdCashoutMethodsCashoutMethodIdDelete.');
            }
            const localVarPath = `/{product_id}/cashout_methods/{cashout_method_id}/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"cashout_method_id"}}`, encodeURIComponent(String(cashoutMethodId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (bpuid !== undefined) {
                localVarQueryParameter['bpuid'] = bpuid;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the details for a specific Cashout event
         * @summary Get Cashout Detail
         * @param {any} productId The Brokerage Product ID provided by GRL.
         * @param {any} cashoutId The cashout event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCashoutDetailProductIdCashoutCashoutIdGet: async (productId: any, cashoutId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling getCashoutDetailProductIdCashoutCashoutIdGet.');
            }
            // verify required parameter 'cashoutId' is not null or undefined
            if (cashoutId === null || cashoutId === undefined) {
                throw new RequiredError('cashoutId','Required parameter cashoutId was null or undefined when calling getCashoutDetailProductIdCashoutCashoutIdGet.');
            }
            const localVarPath = `/{product_id}/cashout/{cashout_id}/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"cashout_id"}}`, encodeURIComponent(String(cashoutId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the current available mechanisms that a user can use to retrieve funds.
         * @summary Get Cashout Methods
         * @param {any} productId The Brokerage Product ID provided by GRL.
         * @param {any} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCashoutMethodsProductIdCashoutMethodsGet: async (productId: any, bpuid: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling getCashoutMethodsProductIdCashoutMethodsGet.');
            }
            // verify required parameter 'bpuid' is not null or undefined
            if (bpuid === null || bpuid === undefined) {
                throw new RequiredError('bpuid','Required parameter bpuid was null or undefined when calling getCashoutMethodsProductIdCashoutMethodsGet.');
            }
            const localVarPath = `/{product_id}/cashout_methods/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (bpuid !== undefined) {
                localVarQueryParameter['bpuid'] = bpuid;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this function to get the \"value\" (in local currency, e.g. CAD, BTC) for this   cashout_method, for amount (in USD cents).
         * @summary Get Expected Redemption Value
         * @param {any} productId The Brokerage Product ID provided by GRL.
         * @param {any} cashoutMethodId The ID of the cashout method
         * @param {any} amount (USD cents) The amount to convert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpectedRedemptionValueProductIdCashoutMethodCashoutMethodIdValueGet: async (productId: any, cashoutMethodId: any, amount: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling getExpectedRedemptionValueProductIdCashoutMethodCashoutMethodIdValueGet.');
            }
            // verify required parameter 'cashoutMethodId' is not null or undefined
            if (cashoutMethodId === null || cashoutMethodId === undefined) {
                throw new RequiredError('cashoutMethodId','Required parameter cashoutMethodId was null or undefined when calling getExpectedRedemptionValueProductIdCashoutMethodCashoutMethodIdValueGet.');
            }
            // verify required parameter 'amount' is not null or undefined
            if (amount === null || amount === undefined) {
                throw new RequiredError('amount','Required parameter amount was null or undefined when calling getExpectedRedemptionValueProductIdCashoutMethodCashoutMethodIdValueGet.');
            }
            const localVarPath = `/{product_id}/cashout_method/{cashout_method_id}/value/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)))
                .replace(`{${"cashout_method_id"}}`, encodeURIComponent(String(cashoutMethodId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Return array of user events that altered their wallet balance
         * @summary Get User Transaction History
         * @param {any} productId The Brokerage Product ID provided by GRL.
         * @param {any} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTransactionHistoryProductIdTransactionHistoryGet: async (productId: any, bpuid: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling getUserTransactionHistoryProductIdTransactionHistoryGet.');
            }
            // verify required parameter 'bpuid' is not null or undefined
            if (bpuid === null || bpuid === undefined) {
                throw new RequiredError('bpuid','Required parameter bpuid was null or undefined when calling getUserTransactionHistoryProductIdTransactionHistoryGet.');
            }
            const localVarPath = `/{product_id}/transaction_history/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (bpuid !== undefined) {
                localVarQueryParameter['bpuid'] = bpuid;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the current balance of a respondent's wallet balance for display
         * @summary Get User Wallet Balance
         * @param {any} productId The Brokerage Product ID provided by GRL.
         * @param {any} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWalletBalanceProductIdWalletGet: async (productId: any, bpuid: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling getUserWalletBalanceProductIdWalletGet.');
            }
            // verify required parameter 'bpuid' is not null or undefined
            if (bpuid === null || bpuid === undefined) {
                throw new RequiredError('bpuid','Required parameter bpuid was null or undefined when calling getUserWalletBalanceProductIdWalletGet.');
            }
            const localVarPath = `/{product_id}/wallet/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (bpuid !== undefined) {
                localVarQueryParameter['bpuid'] = bpuid;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Request a cashout taken from a user's available wallet balance, to be paid via a particular cashout method.
         * @summary Submit User Cashout
         * @param {CreateCashoutRequest} body 
         * @param {any} productId The Brokerage Product ID provided by GRL.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitUserCashoutProductIdCashoutPost: async (body: CreateCashoutRequest, productId: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling submitUserCashoutProductIdCashoutPost.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling submitUserCashoutProductIdCashoutPost.');
            }
            const localVarPath = `/{product_id}/cashout/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(productId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WalletApi - functional programming interface
 * @export
 */
export const WalletApiFp = function(configuration?: Configuration) {
    return {
        /**
         * A user can only have 1 unique Cashout Method of any type at a time (eg. they can't create multiple paypal payout methods). Cashout Methods cannot be edited, they can only be created or deleted. Creating different Cashout Methods will require type-dependent request data attributes in order to be successfully created.  Currently only creating paypal or Cash in Mail cashout methods are supported
         * @summary Create Cashout Method
         * @param {any} body 
         * @param {any} productId The Brokerage Product ID provided by GRL.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCashoutMethodProductIdCashoutMethodsPost(body: any, productId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<CashoutMethodResponse>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).createCashoutMethodProductIdCashoutMethodsPost(body, productId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a cashout method
         * @summary Delete Cashout Method
         * @param {any} productId The Brokerage Product ID provided by GRL.
         * @param {any} cashoutMethodId The ID of the cashout method to delete
         * @param {any} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCashoutMethodProductIdCashoutMethodsCashoutMethodIdDelete(productId: any, cashoutMethodId: any, bpuid: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<StatusResponse>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).deleteCashoutMethodProductIdCashoutMethodsCashoutMethodIdDelete(productId, cashoutMethodId, bpuid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve the details for a specific Cashout event
         * @summary Get Cashout Detail
         * @param {any} productId The Brokerage Product ID provided by GRL.
         * @param {any} cashoutId The cashout event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCashoutDetailProductIdCashoutCashoutIdGet(productId: any, cashoutId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<CashoutRequestResponse>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).getCashoutDetailProductIdCashoutCashoutIdGet(productId, cashoutId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve the current available mechanisms that a user can use to retrieve funds.
         * @summary Get Cashout Methods
         * @param {any} productId The Brokerage Product ID provided by GRL.
         * @param {any} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCashoutMethodsProductIdCashoutMethodsGet(productId: any, bpuid: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<CashoutMethodsResponse>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).getCashoutMethodsProductIdCashoutMethodsGet(productId, bpuid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this function to get the \"value\" (in local currency, e.g. CAD, BTC) for this   cashout_method, for amount (in USD cents).
         * @summary Get Expected Redemption Value
         * @param {any} productId The Brokerage Product ID provided by GRL.
         * @param {any} cashoutMethodId The ID of the cashout method
         * @param {any} amount (USD cents) The amount to convert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExpectedRedemptionValueProductIdCashoutMethodCashoutMethodIdValueGet(productId: any, cashoutMethodId: any, amount: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<CashoutMethodForeignValueResponse>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).getExpectedRedemptionValueProductIdCashoutMethodCashoutMethodIdValueGet(productId, cashoutMethodId, amount, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Return array of user events that altered their wallet balance
         * @summary Get User Transaction History
         * @param {any} productId The Brokerage Product ID provided by GRL.
         * @param {any} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTransactionHistoryProductIdTransactionHistoryGet(productId: any, bpuid: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<UserTransactionHistoryResponse>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).getUserTransactionHistoryProductIdTransactionHistoryGet(productId, bpuid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve the current balance of a respondent's wallet balance for display
         * @summary Get User Wallet Balance
         * @param {any} productId The Brokerage Product ID provided by GRL.
         * @param {any} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserWalletBalanceProductIdWalletGet(productId: any, bpuid: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<UserWalletBalanceResponse>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).getUserWalletBalanceProductIdWalletGet(productId, bpuid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Request a cashout taken from a user's available wallet balance, to be paid via a particular cashout method.
         * @summary Submit User Cashout
         * @param {CreateCashoutRequest} body 
         * @param {any} productId The Brokerage Product ID provided by GRL.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitUserCashoutProductIdCashoutPost(body: CreateCashoutRequest, productId: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<CashoutRequestResponse>>> {
            const localVarAxiosArgs = await WalletApiAxiosParamCreator(configuration).submitUserCashoutProductIdCashoutPost(body, productId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * WalletApi - factory interface
 * @export
 */
export const WalletApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * A user can only have 1 unique Cashout Method of any type at a time (eg. they can't create multiple paypal payout methods). Cashout Methods cannot be edited, they can only be created or deleted. Creating different Cashout Methods will require type-dependent request data attributes in order to be successfully created.  Currently only creating paypal or Cash in Mail cashout methods are supported
         * @summary Create Cashout Method
         * @param {any} body 
         * @param {any} productId The Brokerage Product ID provided by GRL.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCashoutMethodProductIdCashoutMethodsPost(body: any, productId: any, options?: AxiosRequestConfig): Promise<AxiosResponse<CashoutMethodResponse>> {
            return WalletApiFp(configuration).createCashoutMethodProductIdCashoutMethodsPost(body, productId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a cashout method
         * @summary Delete Cashout Method
         * @param {any} productId The Brokerage Product ID provided by GRL.
         * @param {any} cashoutMethodId The ID of the cashout method to delete
         * @param {any} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCashoutMethodProductIdCashoutMethodsCashoutMethodIdDelete(productId: any, cashoutMethodId: any, bpuid: any, options?: AxiosRequestConfig): Promise<AxiosResponse<StatusResponse>> {
            return WalletApiFp(configuration).deleteCashoutMethodProductIdCashoutMethodsCashoutMethodIdDelete(productId, cashoutMethodId, bpuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the details for a specific Cashout event
         * @summary Get Cashout Detail
         * @param {any} productId The Brokerage Product ID provided by GRL.
         * @param {any} cashoutId The cashout event ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCashoutDetailProductIdCashoutCashoutIdGet(productId: any, cashoutId: any, options?: AxiosRequestConfig): Promise<AxiosResponse<CashoutRequestResponse>> {
            return WalletApiFp(configuration).getCashoutDetailProductIdCashoutCashoutIdGet(productId, cashoutId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the current available mechanisms that a user can use to retrieve funds.
         * @summary Get Cashout Methods
         * @param {any} productId The Brokerage Product ID provided by GRL.
         * @param {any} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCashoutMethodsProductIdCashoutMethodsGet(productId: any, bpuid: any, options?: AxiosRequestConfig): Promise<AxiosResponse<CashoutMethodsResponse>> {
            return WalletApiFp(configuration).getCashoutMethodsProductIdCashoutMethodsGet(productId, bpuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this function to get the \"value\" (in local currency, e.g. CAD, BTC) for this   cashout_method, for amount (in USD cents).
         * @summary Get Expected Redemption Value
         * @param {any} productId The Brokerage Product ID provided by GRL.
         * @param {any} cashoutMethodId The ID of the cashout method
         * @param {any} amount (USD cents) The amount to convert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExpectedRedemptionValueProductIdCashoutMethodCashoutMethodIdValueGet(productId: any, cashoutMethodId: any, amount: any, options?: AxiosRequestConfig): Promise<AxiosResponse<CashoutMethodForeignValueResponse>> {
            return WalletApiFp(configuration).getExpectedRedemptionValueProductIdCashoutMethodCashoutMethodIdValueGet(productId, cashoutMethodId, amount, options).then((request) => request(axios, basePath));
        },
        /**
         * Return array of user events that altered their wallet balance
         * @summary Get User Transaction History
         * @param {any} productId The Brokerage Product ID provided by GRL.
         * @param {any} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTransactionHistoryProductIdTransactionHistoryGet(productId: any, bpuid: any, options?: AxiosRequestConfig): Promise<AxiosResponse<UserTransactionHistoryResponse>> {
            return WalletApiFp(configuration).getUserTransactionHistoryProductIdTransactionHistoryGet(productId, bpuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the current balance of a respondent's wallet balance for display
         * @summary Get User Wallet Balance
         * @param {any} productId The Brokerage Product ID provided by GRL.
         * @param {any} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserWalletBalanceProductIdWalletGet(productId: any, bpuid: any, options?: AxiosRequestConfig): Promise<AxiosResponse<UserWalletBalanceResponse>> {
            return WalletApiFp(configuration).getUserWalletBalanceProductIdWalletGet(productId, bpuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Request a cashout taken from a user's available wallet balance, to be paid via a particular cashout method.
         * @summary Submit User Cashout
         * @param {CreateCashoutRequest} body 
         * @param {any} productId The Brokerage Product ID provided by GRL.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitUserCashoutProductIdCashoutPost(body: CreateCashoutRequest, productId: any, options?: AxiosRequestConfig): Promise<AxiosResponse<CashoutRequestResponse>> {
            return WalletApiFp(configuration).submitUserCashoutProductIdCashoutPost(body, productId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WalletApi - object-oriented interface
 * @export
 * @class WalletApi
 * @extends {BaseAPI}
 */
export class WalletApi extends BaseAPI {
    /**
     * A user can only have 1 unique Cashout Method of any type at a time (eg. they can't create multiple paypal payout methods). Cashout Methods cannot be edited, they can only be created or deleted. Creating different Cashout Methods will require type-dependent request data attributes in order to be successfully created.  Currently only creating paypal or Cash in Mail cashout methods are supported
     * @summary Create Cashout Method
     * @param {any} body 
     * @param {any} productId The Brokerage Product ID provided by GRL.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async createCashoutMethodProductIdCashoutMethodsPost(body: any, productId: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<CashoutMethodResponse>> {
        return WalletApiFp(this.configuration).createCashoutMethodProductIdCashoutMethodsPost(body, productId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a cashout method
     * @summary Delete Cashout Method
     * @param {any} productId The Brokerage Product ID provided by GRL.
     * @param {any} cashoutMethodId The ID of the cashout method to delete
     * @param {any} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async deleteCashoutMethodProductIdCashoutMethodsCashoutMethodIdDelete(productId: any, cashoutMethodId: any, bpuid: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<StatusResponse>> {
        return WalletApiFp(this.configuration).deleteCashoutMethodProductIdCashoutMethodsCashoutMethodIdDelete(productId, cashoutMethodId, bpuid, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve the details for a specific Cashout event
     * @summary Get Cashout Detail
     * @param {any} productId The Brokerage Product ID provided by GRL.
     * @param {any} cashoutId The cashout event ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async getCashoutDetailProductIdCashoutCashoutIdGet(productId: any, cashoutId: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<CashoutRequestResponse>> {
        return WalletApiFp(this.configuration).getCashoutDetailProductIdCashoutCashoutIdGet(productId, cashoutId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve the current available mechanisms that a user can use to retrieve funds.
     * @summary Get Cashout Methods
     * @param {any} productId The Brokerage Product ID provided by GRL.
     * @param {any} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async getCashoutMethodsProductIdCashoutMethodsGet(productId: any, bpuid: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<CashoutMethodsResponse>> {
        return WalletApiFp(this.configuration).getCashoutMethodsProductIdCashoutMethodsGet(productId, bpuid, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Use this function to get the \"value\" (in local currency, e.g. CAD, BTC) for this   cashout_method, for amount (in USD cents).
     * @summary Get Expected Redemption Value
     * @param {any} productId The Brokerage Product ID provided by GRL.
     * @param {any} cashoutMethodId The ID of the cashout method
     * @param {any} amount (USD cents) The amount to convert
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async getExpectedRedemptionValueProductIdCashoutMethodCashoutMethodIdValueGet(productId: any, cashoutMethodId: any, amount: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<CashoutMethodForeignValueResponse>> {
        return WalletApiFp(this.configuration).getExpectedRedemptionValueProductIdCashoutMethodCashoutMethodIdValueGet(productId, cashoutMethodId, amount, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Return array of user events that altered their wallet balance
     * @summary Get User Transaction History
     * @param {any} productId The Brokerage Product ID provided by GRL.
     * @param {any} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async getUserTransactionHistoryProductIdTransactionHistoryGet(productId: any, bpuid: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<UserTransactionHistoryResponse>> {
        return WalletApiFp(this.configuration).getUserTransactionHistoryProductIdTransactionHistoryGet(productId, bpuid, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve the current balance of a respondent's wallet balance for display
     * @summary Get User Wallet Balance
     * @param {any} productId The Brokerage Product ID provided by GRL.
     * @param {any} bpuid A unique identifier for each user, which is set by the Supplier. Must be consistent across respondent entrances and unique to the platform. It should not contain any sensitive information like email or names, and should avoid using any incrementing values.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async getUserWalletBalanceProductIdWalletGet(productId: any, bpuid: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<UserWalletBalanceResponse>> {
        return WalletApiFp(this.configuration).getUserWalletBalanceProductIdWalletGet(productId, bpuid, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Request a cashout taken from a user's available wallet balance, to be paid via a particular cashout method.
     * @summary Submit User Cashout
     * @param {CreateCashoutRequest} body 
     * @param {any} productId The Brokerage Product ID provided by GRL.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WalletApi
     */
    public async submitUserCashoutProductIdCashoutPost(body: CreateCashoutRequest, productId: any, options?: AxiosRequestConfig) : Promise<AxiosResponse<CashoutRequestResponse>> {
        return WalletApiFp(this.configuration).submitUserCashoutProductIdCashoutPost(body, productId, options).then((request) => request(this.axios, this.basePath));
    }
}
